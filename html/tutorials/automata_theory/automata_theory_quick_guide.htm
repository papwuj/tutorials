<!DOCTYPE html>
<html lang="en-US">
<head>
<title>Automata Theory - Quick Guide</title>
<meta charset="utf-8">
<meta name="description" content="Automata Theory - Quick Guide - The term Automata is derived from the Greek word Î±á½ÏÏÎ¼Î±ÏÎ± which means self-acting. An automaton (Automata in plural) is an abstr"/>
<meta name="keywords" content="C, C++, Python, Java, HTML, CSS, JavaScript, SQL, PHP, jQuery, XML, DOM, Bootstrap, Tutorials, Articles, Programming, training, learning, quiz, preferences, examples, code"/>
<link rel="canonical" href="https://www.tutorialspoint.com/automata_theory/automata_theory_quick_guide.htm" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<script src="/theme/js/script-min-v2.js?v=3"></script>
<link rel="stylesheet" href="/theme/css/style-min-v2.css?v=6">
<script src="//services.bilsyndication.com/adv1/?d=901" defer="" async=""></script>
<script> var vitag = vitag || {};</script>
<script> vitag.outStreamConfig = { enablePC: false, enableMobile: false };</script>  
<style>
.right-menu .mui-btn {
    background-color:#578A79;
}
a.demo {
    background:#578A79;
}
li.heading {
    background:#578A79;
}
.course-box{background:#578A79}
.home-intro-sub p{color:#578A79}
</style>
</head>
<body>
<header id="header">
<!-- Top sub-menu Starts Here -->
<div class="mui-appbar mui-container-fulid top-menu">
<div class="mui-container">
<div class="top-menu-item home">
<a href="https://www.tutorialspoint.com/index.htm" target="_blank" title="TutorialsPoint - Home"><i class="fal fa-home"></i> <span>Home</span></a>
</div>
<div class="top-menu-item qa">
<a href="https://www.tutorialspoint.com/about/about_careers.htm" target="_blank" title="Job @ Tutorials Point"><i class="fa fa-suitcase"></i> <span>Jobs</span></a>
</div>
<div class="top-menu-item tools">
<a href="https://www.tutorialspoint.com/online_dev_tools.htm" target="_blank" title="Tools - Online Development and Testing Tools"><i class="fal fa-cogs"></i> <span>Tools</span></a>
</div>
<div class="top-menu-item coding-ground">
<a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" title="Coding Ground - Free Online IDE and Terminal"><i class="fal fa-code"></i> <span>Coding Ground </span></a> 
</div>
<div class="top-menu-item current-affairs">
<a href="https://www.tutorialspoint.com/current_affairs.htm" target="_blank" title="Daily Current Affairs"><i class="fal fa-layer-plus"></i> <span>Current Affairs</span></a>
</div>
<div class="top-menu-item upsc-notes">
<a href="https://www.tutorialspoint.com/upsc_ias_exams.htm" target="_blank" title="UPSC IAS Exams Notes - TutorialsPoint"><i class="fal fa-user-tie"></i> <span>UPSC Notes</span></a>
</div>      
<div class="top-menu-item online-tutoris">
<a href="https://www.tutorialspoint.com/tutor_connect/index.php" target="_blank" title="Top Online Tutors - Tutor Connect"><i class="fal fa-user"></i> <span>Online Tutors</span></a>
</div>
<div class="top-menu-item whiteboard">
<a href="https://www.tutorialspoint.com/whiteboard.htm" target="_blank" title="Free Online Whiteboard"><i class="fal fa-chalkboard"></i> <span>Whiteboard</span></a>
</div>
<div class="top-menu-item net-meeting">
<a href="https://www.tutorialspoint.com/netmeeting.php" target="_blank" title="A free tool for online video conferencing"><i class="fal fa-chalkboard-teacher"></i> <span>Net Meeting</span></a> 
</div>
<div class="top-menu-item articles">
<a href="https://www.tutorix.com" target="_blank" title="Tutorx - The Best Learning App" rel="nofollow"><i class="fal fa-video"></i> <span>Tutorix</span></a> 
</div>        
<div class="social-menu-item">
<a href="https://www.facebook.com/tutorialspointindia" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Facebook"><i class="fab fa-facebook-f"></i></a> 
<a href="https://www.twitter.com/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Twitter"><i class="fab fa-twitter"></i></a>
<a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Linkedin"><i class="fab fa-linkedin-in"></i></a>
<a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint YouTube"><i class="fab fa-youtube"></i></a>
</div>        
</div>
</div>
<!-- Top sub-menu Ends Here -->
<!-- Top main-menu Starts Here -->
<div class="mui-appbar mui-container-fulid mui--appbar-line-height mui--z1" id="logo-menu">
<div class="mui-container">
<div class="left-menu">
<a href="https://www.tutorialspoint.com/index.htm" title="Tutorialspoint">
<img class="tp-logo" alt="tutorialspoint" src="/automata_theory/images/logo.png">
</a>
<div class="mui-dropdown">
<a class="mui-btn mui-btn--primary categories" data-mui-toggle="dropdown"><i class="fa fa-th-large"></i> 
<span>Categories <span class="mui-caret"></span></span></a>            
<ul class="mui-dropdown__menu cat-menu">
<li>
<ul>
<li><a href="/academic_tutorials.htm"><i class="fa fa-caret-right"></i> Academic Tutorials</a></li>
<li><a href="/big_data_tutorials.htm"><i class="fa fa-caret-right"></i> Big Data &amp; Analytics </a></li>
<li><a href="/computer_programming_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Programming </a></li>
<li><a href="/computer_science_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Science </a></li>
<li><a href="/database_tutorials.htm"><i class="fa fa-caret-right"></i> Databases </a></li>
<li><a href="/devops_tutorials.htm"><i class="fa fa-caret-right"></i> DevOps </a></li>
<li><a href="/digital_marketing_tutorials.htm"><i class="fa fa-caret-right"></i> Digital Marketing </a></li>
<li><a href="/engineering_tutorials.htm"><i class="fa fa-caret-right"></i> Engineering Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> Exams Syllabus </a></li>
<li><a href="/famous_monuments.htm"><i class="fa fa-caret-right"></i> Famous Monuments </a></li>
<li><a href="/gate_exams_tutorials.htm"><i class="fa fa-caret-right"></i> GATE Exams Tutorials</a></li>
<li><a href="/latest_technologies.htm"><i class="fa fa-caret-right"></i> Latest Technologies </a></li>
<li><a href="/machine_learning_tutorials.htm"><i class="fa fa-caret-right"></i> Machine Learning </a></li>
<li><a href="/mainframe_tutorials.htm"><i class="fa fa-caret-right"></i> Mainframe Development </a></li>
<li><a href="/management_tutorials.htm"><i class="fa fa-caret-right"></i> Management Tutorials </a></li>
<li><a href="/maths_tutorials.htm"><i class="fa fa-caret-right"></i> Mathematics Tutorials</a></li>
<li><a href="/microsoft_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Microsoft Technologies </a></li>
<li><a href="/misc_tutorials.htm"><i class="fa fa-caret-right"></i> Misc tutorials </a></li>
<li><a href="/mobile_development_tutorials.htm"><i class="fa fa-caret-right"></i> Mobile Development </a></li>
<li><a href="/java_technology_tutorials.htm"><i class="fa fa-caret-right"></i> Java Technologies </a></li>
<li><a href="/python_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Python Technologies </a></li>
<li><a href="/sap_tutorials.htm"><i class="fa fa-caret-right"></i> SAP Tutorials </a></li>
<li><a href="/scripting_lnaguage_tutorials.htm"><i class="fa fa-caret-right"></i>Programming Scripts </a></li>
<li><a href="/selected_reading.htm"><i class="fa fa-caret-right"></i> Selected Reading </a></li>
<li><a href="/software_quality_tutorials.htm"><i class="fa fa-caret-right"></i> Software Quality </a></li>
<li><a href="/soft_skill_tutorials.htm"><i class="fa fa-caret-right"></i> Soft Skills </a></li>
<li><a href="/telecom_tutorials.htm"><i class="fa fa-caret-right"></i> Telecom Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> UPSC IAS Exams </a></li>
<li><a href="/web_development_tutorials.htm"><i class="fa fa-caret-right"></i> Web Development </a></li>
<li><a href="/sports_tutorials.htm"><i class="fa fa-caret-right"></i> Sports Tutorials </a></li>
<li><a href="/xml_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> XML Technologies </a></li>
<li><a href="/multi_language_tutorials.htm"><i class="fa fa-caret-right"></i> Multi-Language Tutorials</a></li>
<li><a href="/questions_and_answers.htm"><i class="fa fa-caret-right"></i> Interview Questions</a></li>
</ul>
</li>
</ul>
<div class="clear"></div>
</div> 
</div>
<div class="right-menu">
<div class="toc-toggle">
<a href="javascript:void(0);"><i class="fa fa-bars"></i></a>
</div>
<div class="mobile-search-btn">
<a href="https://www.tutorialspoint.com/search.htm"><i class="fal fa-search"></i></a>
</div>
<div class="search-box">
<form method="get" class="" name="searchform" action="https://www.google.com/search" target="_blank" novalidate="">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com" class="user-valid valid">
<input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
<button><i class="fal fa-search"></i></button>
</form>
</div>
<div class="menu-btn library-btn">
<a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a>
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a> 
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/questions/index.php"><i class="fa fa-location-arrow"></i> <span>Q/A</span></a>
</div>
<div class="menu-btn ebooks-btn">
<a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a>
</div>
<div class="mui-dropdown">
<button class="mui-btn mui-btn--primary" data-mui-toggle="dropdown">
<span class="mui-caret"></span>
</button>
<ul class="mui-dropdown__menu">
<li><a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a></li>
<li><a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a></li>
<li><a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a></li>
</ul>
</div>
</div>
</div>
</div>
<!-- Top main-menu Ends Here -->
</header>
<div class="mui-container-fluid content">
<div class="mui-container">
<!-- Tutorial ToC Starts Here -->
<div class="mui-col-md-3 tutorial-toc">
<div class="mini-logo">
<img src="/automata_theory/images/finite-language-and-automata-theory-mini-logo.jpg" alt="Automata Theory Tutorial" />
</div>
<ul class="toc chapters">
<li class="heading">Automata Theory Tutorial</li>
<li><a href="/automata_theory/index.htm">Automata Theory - Home</a></li>
<li><a href="/automata_theory/automata_theory_introduction.htm">Automata Theory Introduction</a></li>
<li><a href="/automata_theory/deterministic_finite_automaton.htm">Deterministic Finite Automaton</a></li>
<li><a href="/automata_theory/non_deterministic_finite_automaton.htm">Non-deterministic Finite Automaton</a></li>
<li><a href="/automata_theory/ndfa_to_dfa_conversion.htm">NDFA to DFA Conversion</a></li>
<li><a href="/automata_theory/dfa_minimization.htm">DFA Minimization</a></li>
<li><a href="/automata_theory/moore_and_mealy_machines.htm">Moore &amp; Mealy Machines</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Classification of Grammars</li>
<li><a href="/automata_theory/introduction_to_grammars.htm">Introduction to Grammars</a></li>
<li><a href="/automata_theory/language_generated_by_grammars.htm">Language Generated by Grammars</a></li>
<li><a href="/automata_theory/chomsky_classification_of_grammars.htm">Chomsky Grammar Classification</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Regular Grammar</li>
<li><a href="/automata_theory/regular_expressions.htm">Regular Expressions</a></li>
<li><a href="/automata_theory/regular_sets.htm">Regular Sets</a></li>
<li><a href="/automata_theory/ardens_theorem.htm">Arden's Theorem</a></li>
<li><a href="/automata_theory/constructing_fa_from_re.htm">Constructing FA from RE</a></li>
<li><a href="/automata_theory/pumping_lemma_for_regular_grammar.htm">Pumping Lemma for Regular Grammar</a></li>
<li><a href="/automata_theory/dfa_complement.htm">DFA Complement</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Context-Free Grammars</li>
<li><a href="/automata_theory/context_free_grammar_introduction.htm">Context-Free Grammar Introduction</a></li>
<li><a href="/automata_theory/ambiguity_in_grammar.htm">Ambiguity in Grammar</a></li>
<li><a href="/automata_theory/cfl_closure_properties.htm">CFL Closure Properties</a></li>
<li><a href="/automata_theory/cfg_simplification.htm">CFG Simplification</a></li>
<li><a href="/automata_theory/chomsky_normal_form.htm">Chomsky Normal Form</a></li>
<li><a href="/automata_theory/greibach_normal_form.htm">Greibach Normal Form</a></li>
<li><a href="/automata_theory/pumping_lemma_for_cfg.htm">Pumping Lemma for CFG</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Pushdown Automata</li>
<li><a href="/automata_theory/pushdown_automata_introduction.htm">Pushdown Automata Introduction</a></li>
<li><a href="/automata_theory/pushdown_automata_acceptance.htm">Pushdown Automata Acceptance</a></li>
<li><a href="/automata_theory/pda_context_free_grammar.htm">PDA &amp; Context Free Grammar</a></li>
<li><a href="/automata_theory/pda_and_parsing.htm">PDA &amp; Parsing</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Turing Machine</li>   
<li><a href="/automata_theory/turing_machine_introduction.htm">Turing Machine Introduction</a></li>
<li><a href="/automata_theory/accepted_and_decided_language.htm">Accepted &amp; Decided Language</a></li>
<li><a href="/automata_theory/multi_tape_turing_machine.htm">Multi-tape Turing Machine</a></li>
<li><a href="/automata_theory/multi_track_turing_machine.htm">Multi-Track Turing Machine</a></li>
<li><a href="/automata_theory/non_deterministic_turing_machine.htm">Non-Deterministic Turing Machine</a></li>
<li><a href="/automata_theory/semi_infinite_tape_turing_machine.htm">Semi-Infinite Tape Turing Machine</a></li>
<li><a href="/automata_theory/linear_bounded_automata.htm">Linear Bounded Automata</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Decidability</li>
<li><a href="/automata_theory/language_decidability.htm">Language Decidability</a></li>
<li><a href="/automata_theory/undecidable_languages.htm">Undecidable Language</a></li>
<li><a href="/automata_theory/turing_machine_halting_problem.htm">Turing Machine Halting Problem</a></li>
<li><a href="/automata_theory/rice_theorem.htm">Rice Theorem</a></li>
<li><a href="/automata_theory/post_correspondence_problem.htm">Post Correspondence Problem</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">Automata Theory Useful Resources</li>
<li><a href="/automata_theory/automata_theory_quick_guide.htm">Automata Theory - Quick Guide</a></li>
<li><a href="/automata_theory/automata_theory_useful_resources.htm">Automata Theory - Useful Resources</a></li>
<li><a href="/automata_theory/automata_theory_discussion.htm">Automata Theory - Discussion</a></li>
</ul>
<ul class="toc reading">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="/upsc_ias_exams.htm">UPSC IAS Exams Notes</a></li>
<li><a target="_top" href="/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</div>
<!-- Tutorial ToC Ends Here -->
<!-- Tutorial Content Starts Here -->
<div class="mui-col-md-6 tutorial-content">
<h1>Automata Theory - Quick Guide</h1>
<hr />
<div class="top-ad-heading">Advertisements</div>
<div style="text-align: center;">
<script><!--
google_ad_client = "pub-7133395778201029";
var width = document.getElementsByClassName("tutorial-content")[0].clientWidth - 40;
google_ad_width = width;
google_ad_height = 150;
google_ad_format = width + "x150_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="mui-container-fluid button-borders">
<div class="pre-btn">
<a href="/automata_theory/post_correspondence_problem.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/automata_theory/automata_theory_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="clearer"></div>
<h1>Automata Theory Introduction</h1>
<h2>Automata – What is it?</h2>
<p>The term "Automata" is derived from the Greek word "αὐτόματα" which means "self-acting". An automaton (Automata in plural) is an abstract self-propelled computing device which follows a predetermined sequence of operations automatically.</p>
<p>An automaton with a finite number of states is called a <b>Finite Automaton</b> (FA) or <b>Finite State Machine</b> (FSM).</p>
<h3>Formal definition of a Finite Automaton</h3>
<p>An automaton can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states.</p></li>
<li><p><b>&sum;</b> is a finite set of symbols, called the <b>alphabet</b> of the automaton.</p></li>
<li><p><b>&delta;</b> is the transition function.</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p></li>
<li><p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p></li>
</ul>
<h2>Related Terminologies </h2>
<h3>Alphabet</h3>
<ul class="list">
<li><p><b>Definition</b> &minus; An <b>alphabet</b> is any finite set of symbols.</p></li>
<li><p><b>Example</b> &minus; &sum; = {a, b, c, d} is an <b>alphabet set</b> where ‘a’, ‘b’, ‘c’, and ‘d’ are <b>symbols</b>.</p></li>
</ul>
<h3>String</h3>
<ul class="list">
<li><p><b>Definition</b> &minus; A <b>string</b> is a finite sequence of symbols taken from &sum;.</p></li>
<li><p><b>Example</b> &minus; ‘cabcad’ is a valid string on the alphabet set &sum; = {a, b, c, d}</p></li>
</ul>
<h3>Length of a String</h3>
<ul class="list">
<li><p><b>Definition</b> &minus; It is the number of symbols present in a string. (Denoted by <b>|S|</b>).</p></li>
<li><p><b>Examples</b> &minus;</p>
<ul class="list">
<li><p>If S = ‘cabcad’, |S|= 6</p></li>
<li><p>If |S|= 0, it is called an <b>empty string</b> (Denoted by <b>&lambda;</b> or <b>&epsilon;</b>)</p></li>
</ul>
</li>
</ul>
<h3>Kleene Star</h3>
<ul class="list">
<li><p><b>Definition</b> &minus; The Kleene star, <b>&sum;*</b>, is a unary operator on a set of symbols or strings, <b>&sum;</b>, that gives the infinite set of all possible strings of all possible lengths over <b>&sum;</b> including <b>&lambda;</b>.</p></li>
<li><p><b>Representation</b> &minus; &sum;* = &sum;<sub>0</sub> &cup; &sum;<sub>1</sub> &cup; &sum;<sub>2</sub> &cup;……. where &sum;<sub>p</sub> is the set of all possible strings of length p.</p></li>
<li><p><b>Example</b> &minus; If &sum; = {a, b}, &sum;* = {&lambda;, a, b, aa, ab, ba, bb,………..}</p></li>
</ul>
<h3>Kleene Closure / Plus</h3>
<ul class="list">
<li><p><b>Definition</b> &minus; The set <b>&sum;<sup>+</sup></b> is the infinite set of all possible strings of all possible lengths over &sum; excluding &lambda;.</p></li>
<li><p><b>Representation</b> &minus; &sum;<sup>+</sup> = &sum;<sub>1</sub> &cup; &sum;<sub>2</sub> &cup; &sum;<sub>3</sub> &cup;…….</p>
<p style="padding-left:25%;">&sum;<sup>+</sup>  = &sum;* − { &lambda; }</p></li>
<li><p><b>Example</b> &minus; If &sum; = { a, b } , &sum;<sup>+</sup> = { a, b, aa, ab, ba, bb,………..}</p></li>
</ul>
<h3>Language</h3>
<ul class="list">
<li><p><b>Definition</b> &minus; A language is a subset of &sum;* for some alphabet &sum;. It can be finite or infinite.</p></li>
<li><p><b>Example</b> &minus; If the language takes all possible strings of length 2 over &sum; = {a, b}, then L = { ab, aa, ba, bb }</p></li>
</ul>
<h1>Deterministic Finite Automaton</h1>
<p>Finite Automaton can be classified into two types &minus;</p>
<ul class="list">
<li>Deterministic Finite Automaton (DFA)</li>
<li>Non-deterministic Finite Automaton (NDFA / NFA)</li>
</ul>
<h2>Deterministic Finite Automaton (DFA)</h2>
<p>In DFA, for each input symbol, one can determine the state to which the machine will move. Hence, it is called <b>Deterministic Automaton</b>. As it has a finite number of states, the machine is called <b>Deterministic Finite Machine</b> or <b>Deterministic Finite Automaton.</b></p>
<h2>Formal Definition of a DFA</h2>
<p>A DFA can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states.</p></li>
<li><p><b>&sum;</b> is a finite set of symbols called the alphabet.</p></li>
<li><p><b>&delta;</b> is the transition function where &delta;: Q &times; &sum; &rarr; Q </p></li>
<li><p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p></li>
<li><p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p></li>
</ul>
<h2>Graphical Representation of a DFA</h2>
<p>A DFA is represented by digraphs called <b>state diagram</b>.</b></p>
<ul class="list">
<li>The vertices represent the states.</li>
<li>The arcs labeled with an input alphabet show the transitions.</li>
<li>The initial state is denoted by an empty single incoming arc.</li>
<li>The final state is indicated by double circles.</li>
</ul>
<h3>Example</h3>
<p>Let a deterministic finite automaton be &rarr;</p>
<ul class="list">
<li>Q = {a, b, c},</li>
<li>&sum; = {0, 1},</li>
<li>q<sub>0</sub> = {a},</li>
<li>F = {c}, and</li>
</ul>
<p>Transition function &delta; as shown by the following table &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Present State</th>
<th style="text-align:center;">Next State for Input 0</th>
<th style="text-align:center;">Next State for Input 1</th>
</tr>
<tr>
<td><b>a</b></td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td><b>b</b></td>
<td>c</td>
<td>a</td>
</tr>
<tr>
<td><b>c</b></td>
<td>b</td>
<td>c</td>
</tr>
</table>
<p>Its graphical representation would be as follows &minus;</p>
<img src="/automata_theory/images/dfa_graphical_representation.jpg" alt="DFA Graphical Representation" />
<h1>Non-deterministic Finite Automaton</h1>
<p>In NDFA, for a particular input symbol, the machine can move to any combination of the states in the machine. In other words, the exact state to which the machine moves cannot be determined. Hence, it is called <b>Non-deterministic Automaton</b>. As it has finite number of states, the machine is called <b>Non-deterministic Finite Machine</b> or <b>Non-deterministic Finite Automaton</b>.</p>
<h3>Formal Definition of an NDFA</h3>
<p>An NDFA can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states.</p></li>
<li><p><b>&sum;</b> is a finite set of symbols called the alphabets.</p></li>
<li><p><b>&delta;</b> is the transition function where &delta;: Q &times; &sum; &rarr; 2<sup>Q</sup></p> 
<p>(Here the power set of Q (2<sup>Q</sup>) has been taken because in case of NDFA, from a state, transition can occur to any combination of Q states)</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p></li>
<li><p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p></li>
</ul>
<h3>Graphical Representation of an NDFA: (same as DFA)</h3>
<p>An NDFA is represented by digraphs called state diagram.</p>
<ul class="list">
<li>The vertices represent the states.</li>
<li>The arcs labeled with an input alphabet show the transitions.</li>
<li>The initial state is denoted by an empty single incoming arc.</li>
<li>The final state is indicated by double circles.</li>
</ul>
<p><b>Example</b></p>
<p>Let a non-deterministic finite automaton be &rarr;</p>
<ul class="list">
<li>Q = {a, b, c}</li>
<li>&sum; = {0, 1}</li>
<li>q<sub>0</sub> = {a}</li>
<li>F = {c}</li>
</ul>
<p>The transition function &delta; as shown below &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Present State</th>
<th style="text-align:center;">Next State for Input 0</th>
<th style="text-align:center;">Next State for Input 1</th>
</tr>
<tr>
<td>a</td>
<td>a, b</td>
<td>b</td>
</tr>
<tr  >
<td>b</td>
<td>c</td>
<td>a, c</td>
</tr>
<tr>
<td>c</td>
<td>b, c</td>
<td>c</td>
</tr>
</table>
<p>Its graphical representation would be as follows &minus;</p>
<img src="/automata_theory/images/ndfa_graphical_representation.jpg" alt="NDFA Graphical Representation" />
<h2>DFA vs NDFA</h2>
<p>The following table lists the differences between DFA and NDFA.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">DFA</th>
<th style="text-align:center;">NDFA</th>
</tr>
<tr>
<td>The transition from a state is to a single particular next state for each input symbol. Hence it is called <i>deterministic</i>.</td>
<td>The transition from a state can be to multiple next states for each input symbol. Hence it is called <i>non-deterministic</i>.</td>
</tr>
<tr>
<td>Empty string transitions are not seen in DFA.</td>
<td>NDFA permits empty string transitions.</td>
</tr>
<tr>
<td>Backtracking is allowed in DFA</td>
<td>In NDFA, backtracking is not always possible.</td>
</tr>
<tr>
<td>Requires more space.</td>
<td>Requires less space.</td>
</tr>
<tr>
<td>A string is accepted by a DFA, if it transits to a final state.</td>
<td>A string is accepted by a NDFA, if at least one of all possible transitions ends in a final state.</td>
</tr>
</table>
<h2>Acceptors, Classifiers, and Transducers</h2>
<h3>Acceptor (Recognizer)</h3>
<p>An automaton that computes a Boolean function is called an <b>acceptor</b>. All the states of an acceptor is either accepting or rejecting the inputs given to it.</p>
<h3>Classifier</h3>
<p>A <b>classifier</b> has more than two final states and it gives a single output when it terminates.</p>
<h3>Transducer</h3>
<p>An automaton that produces outputs based on current input and/or previous state is called a <b>transducer</b>. Transducers can be of two types &minus;</p>
<ul class="list">
<li><p><b>Mealy Machine</b> &minus; The output depends both on the current state and the current input.</p></li>
<li><p><b>Moore Machine</b> &minus; The output depends only on the current state.</p></li>
</ul>
<h2>Acceptability by DFA and NDFA</h2>
<p>A string is accepted by a DFA/NDFA iff the DFA/NDFA starting at the initial state ends in an accepting state (any of the final states) after reading the string wholly.</p>
<p>A string S is accepted by a DFA/NDFA (Q, &sum;, &delta;, q<sub>0</sub>, F), iff</p>
<p style="padding-left:15%;"><b>&delta;*(q<sub>0</sub>, S) &isin; F</b></p>
<p>The language <b>L</b> accepted by DFA/NDFA is</p>
<p style="padding-left:15%;"><b>{S | S &isin; &sum;* and &delta;*(q<sub>0</sub>, S) &isin; F}</b></p>
<p>A string S′ is not accepted by a DFA/NDFA (Q, &sum;, &delta;, q<sub>0</sub>, F), iff</p>
<p style="padding-left:15%;"><b>&delta;*(q<sub>0</sub>, S′) &notin; F</b></p>
<p>The language L′ not accepted by DFA/NDFA (Complement of accepted language L) is</p>
<p style="padding-left:15%;"><b>{S | S &isin; &sum;* and &delta;*(q<sub>0</sub>, S) &notin; F}</b></p>
<p><b>Example</b></p>
<p>Let us consider the DFA shown in Figure 1.3. From the DFA, the acceptable strings can be derived.</p>
<img src="/automata_theory/images/acceptability_of_strings_by_dfa.jpg" alt="Acceptability of String by DFA" />
<p>Strings accepted by the above DFA: {0, 00, 11, 010, 101, ...........}</p>
<p>Strings not accepted by the above DFA: {1, 011, 111, ........}</p>
<h1>NDFA to DFA Conversion</h1>
<h2>Problem Statement</h2>
<p>Let <b>X = (Q<sub>x</sub>, &sum;, &delta;<sub>x</sub>, q<sub>0</sub>, F<sub>x</sub>)</b> be an NDFA which accepts the language L(X). We have to design an equivalent DFA <b>Y = (Q<sub>y</sub>, &sum;, &delta;<sub>y</sub>, q<sub>0</sub>, F<sub>y</sub>)</b> such that <b>L(Y) = L(X)</b>. The following procedure converts the NDFA to its equivalent DFA &minus;</p>
<h2>Algorithm</h2>
<p><b>Input</b> &minus; An NDFA</p>
<p><b>Output</b> &minus; An equivalent DFA</p>
<p><b>Step 1</b> &minus; Create state table from the given NDFA.</p>
<p><b>Step 2</b> &minus; Create a blank state table under possible input alphabets for the equivalent DFA.</p>
<p><b>Step 3</b> &minus; Mark the start state of the DFA by q0 (Same as the NDFA).</p>
<p><b>Step 4</b> &minus; Find out the combination of States {Q<sub>0</sub>, Q<sub>1</sub>,... , Q<sub>n</sub>} for each possible input alphabet.</p>
<p><b>Step 5</b> &minus; Each time we generate a new DFA state under the input alphabet columns, we have to apply step 4 again, otherwise go to step 6.</p>
<p><b>Step 6</b> &minus; The states which contain any of the final states of the NDFA are the final states of the equivalent DFA.</p>
<h2>Example</h2>
<p>Let us consider the NDFA shown in the figure below.</p>
<img src="/automata_theory/images/ndfa.jpg" alt="NDFA" />
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">q</th>
<th style="text-align:center;">δ(q,0)</th>
<th style="text-align:center;">δ(q,1)</th>
</tr>
<tr>
<td>a</td>
<td>{a,b,c,d,e}</td>
<td>{d,e}</td>
</tr>
<tr>
<td>b</td>
<td>{c}</td>
<td>{e}</td>
</tr>
<tr>
<td>c</td>
<td>&empty;</td>
<td>{b}</td>
</tr>
<tr>
<td>d</td>
<td>{e}</td>
<td>&empty;</td>
</tr>
<tr>
<td>e</td>
<td>&empty;</td>
<td>&empty;</td>
</tr>
</table>
<p>Using the above algorithm, we find its equivalent DFA. The state table of the DFA is shown in below.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">q</th>
<th style="text-align:center;">&delta;(q,0)</th>
<th style="text-align:center;">&delta;(q,1)</th>
</tr>
<tr>
<td>[a]</td>
<td>[a,b,c,d,e]</td>
<td>[d,e]</td>
</tr>
<tr>
<td>[a,b,c,d,e]</td>
<td>[a,b,c,d,e]</td>
<td>[b,d,e]</td>
</tr>
<tr>
<td>[d,e]</td>
<td>[e]</td>
<td>&empty;</td>
</tr>
<tr>
<td>[b,d,e]</td>
<td>[c,e]</td>
<td>[e]</td>
</tr>
<tr>
<td>[e]</td>
<td>&empty;</td>
<td>&empty;</td>
</tr>
<tr>
<td>[c, e]</td>
<td>&empty;</td>
<td>[b]</td>
</tr>
<tr>
<td>[b]</td>
<td>[c]</td>
<td>[e]</td>
</tr>
<tr>
<td>[c]</td>
<td>&empty;</td>
<td>[b]</td>
</tr>
</table>
<p>The state diagram of the DFA is as follows &minus;</p>
<img src="/automata_theory/images/dfa_state_diagram.jpg" alt="State Diagram of DFA" />
<h1>DFA Minimization</h1>
<h2>DFA Minimization using Myphill-Nerode Theorem</h2>
<h3>Algorithm</h3>
<p><b>Input</b> &minus; DFA</p>
<p><b>Output</b> &minus; Minimized DFA</p>
<p><b>Step 1</b> &minus; Draw a table for all pairs of states (Q<sub>i</sub>, Q<sub>j</sub>) not necessarily connected directly [All are unmarked initially]</p>
<p><b>Step 2</b> &minus; Consider every state pair (Q<sub>i</sub>, Q<sub>j</sub>) in the DFA where Q<sub>i</sub> &isin; F and Q<sub>j</sub> &notin; F or vice versa and mark them. [Here F is the set of final states]</p>
<p><b>Step 3</b> &minus; Repeat this step until we cannot mark anymore states &minus;</p>
<p>If there is an unmarked pair (Q<sub>i</sub>, Q<sub>j</sub>), mark it if the pair {&delta; (Q<sub>i</sub>, A), &delta; (Q<sub>i</sub>, A)} is marked for some input alphabet.</p>
<p><b>Step 4</b> &minus; Combine all the unmarked pair (Q<sub>i</sub>, Q<sub>j</sub>) and make them a single state in the reduced DFA.</p>
<h3>Example</h3>
<p>Let us use Algorithm 2 to minimize the DFA shown below.</p>
<img src="/automata_theory/images/dfa_minimizing_using_myphill_nerode_theorem.jpg" alt="DFA Minimizing using Myphill-Nerode Theorem" />
<p><b>Step 1</b> &minus; We draw a table for all pair of states.</p>
<table class="table table-bordered">
<tr style="font-weight:bold;text-align:center;">
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">a</td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">b</td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">c</td>
<td></td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">d</td>
<td></td>
<td></td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">e</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">f</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
</table>
<p><b>Step 2</b> &minus; We mark the state pairs.</p>
<table class="table table-bordered">
<tr style="font-weight:bold;text-align:center;">
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">a</td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">b</td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">c</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">d</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">e</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td></td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">f</td>
<td></td>
<td></td>
<td>&#10004;</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
</table>
<p><b>Step 3</b> &minus; We will try to mark the state pairs, with green colored check mark, transitively. If we input 1 to state ‘a’ and ‘f’, it will go to state ‘c’ and ‘f’ respectively. (c, f) is already marked, hence we will mark pair (a, f). Now, we input 1 to state ‘b’ and ‘f’; it will go to state ‘d’ and ‘f’ respectively. (d, f) is already marked, hence we will mark pair (b, f).</p>
<table class="table table-bordered">
<tr style="font-weight:bold;text-align:center;">
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>f</td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">a</td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">b</td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">c</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">d</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">e</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td></td>
<td></td>
<td style="background-color:rgb(81, 173, 85);"></td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
<tr>
<td style="font-weight:bold;text-align:center;">f</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td>&#10004;</td>
<td style="background-color:rgb(81, 173, 85);"></td>
</tr>
</table>
<p>After step 3, we have got state combinations {a, b} {c, d} {c, e} {d, e} that are unmarked.</p>
<p>We can recombine {c, d} {c, e} {d, e} into {c, d, e}</p>
<p>Hence we got two combined states as &minus; {a, b} and {c, d, e}</p>
<p>So the final minimized DFA will contain three states {f}, {a, b} and {c, d, e}</p>
<img src="/automata_theory/images/state_diagram_of_reduced_dfa.jpg" alt="State Diagram of Reduced DFA" />
<h2>DFA Minimization using Equivalence Theorem</h2>
<p>If X and Y are two states in a DFA, we can combine these two states into {X, Y} if they are not distinguishable. Two states are distinguishable, if there is at least one string S, such that one of &delta; (X, S) and &delta; (Y, S) is accepting and another is not accepting. Hence, a DFA is minimal if and only if all the states are distinguishable.</p>
<h3>Algorithm 3</h3>
<p><b>Step 1</b> &minus; All the states <b>Q</b> are divided in two partitions &minus; <b>final states</b> and <b>non-final states</b> and are denoted by <b>P<sub>0</sub></b>. All the states in a partition are 0<sup>th</sup> equivalent. Take a counter <b>k</b> and initialize it with 0.</p>
<p><b>Step 2</b> &minus; Increment k by 1. For each partition in P<sub>k</sub>, divide the states in P<sub>k</sub> into two partitions if they are k-distinguishable. Two states within this partition X and Y are k-distinguishable if there is an input <b>S</b> such that <b>&delta;(X, S)</b> and <b>&delta;(Y, S)</b> are (k-1)-distinguishable.</p>
<p><b>Step 3</b> &minus; If P<sub>k</sub> &ne; P<sub>k-1</sub>, repeat Step 2, otherwise go to Step 4.</p>
<p><b>Step 4</b> &minus; Combine k<sup>th</sup> equivalent sets and make them the new states of the reduced DFA.</p>
<h3>Example</h3>
<p>Let us consider the following DFA &minus;</p>
<img src="/automata_theory/images/dfa.jpg" alt="DFA" />
<table class="table table-bordered">
<tr>
<th style="text-align:center;">q</th>
<th style="text-align:center;">&delta;(q,0)</th>
<th style="text-align:center;">&delta;(q,1)</th>
</tr>
<tr style="text-align:center;">
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr style="text-align:center;">
<td>b</td>
<td>a</td>
<td>d</td>
</tr>
<tr style="text-align:center;">
<td>c</td>
<td>e</td>
<td>f</td>
</tr>
<tr style="text-align:center;">
<td>d</td>
<td>e</td>
<td>f</td>
</tr>
<tr style="text-align:center;">
<td>e</td>
<td>e</td>
<td>f</td>
</tr>
<tr style="text-align:center;">
<td>f</td>
<td>f</td>
<td>f</td>
</tr>
</table>
<p>Let us apply the above algorithm to the above DFA &minus;</p>
<ul class="list">
<li>P<sub>0</sub> = {(c,d,e), (a,b,f)}</li>
<li>P<sub>1</sub> = {(c,d,e), (a,b),(f)}</li>
<li>P<sub>2</sub> = {(c,d,e), (a,b),(f)}</li>
</ul>
<p>Hence, P<sub>1</sub> = P<sub>2</sub>.</p>
<p>There are three states in the reduced DFA. The reduced DFA is as follows &minus;</p>
<img src="/automata_theory/images/reduced_dfa.jpg" alt="Reduced DFA" />
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Q</th>
<th style="text-align:center;">&delta;(q,0)</th>
<th style="text-align:center;">&delta;(q,1)</th>
</tr>
<tr style="text-align:center;">
<td>(a, b)</td>
<td>(a, b)</td>
<td>(c,d,e)</td>
</tr>
<tr style="text-align:center;">
<td>(c,d,e)</td>
<td>(c,d,e)</td>
<td>(f)</td>
</tr>
<tr style="text-align:center;">
<td>(f)</td>
<td>(f)</td>
<td>(f)</td>
</tr>
</table>
<h1>Moore and Mealy Machines</h1>
<p>Finite automata may have outputs corresponding to each transition. There are two types of finite state machines that generate output &minus;</p>
<ul class="list">
<li>Mealy Machine</li>
<li>Moore machine</li>
</ul>
<h3>Mealy Machine</h3>
<p>A Mealy Machine is an FSM whose output depends on the present state as well as the present input.</p>
<p>It can be described by a 6 tuple (Q, &sum;, O, &delta;, X, q<sub>0</sub>) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states.</p></li>
<li><p><b>&sum;</b> is a finite set of symbols called the input alphabet.</p></li>
<li><p><b>O</b> is a finite set of symbols called the output alphabet.</p></li>
<li><p><b>&delta;</b> is the input transition function where &delta;: Q &times; &sum; &rarr; Q</p></li>
<li><p><b>X</b> is the output transition function where X: Q &times; &sum; &rarr; O</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p></li>
</ul>
<p>The state table of a Mealy Machine is shown below &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th rowspan="3"style="text-align:center; vertical-align:middle;">Present state</th>
<th colspan="4" style="text-align:center;">Next state</th>
</tr>
<tr>
<th colspan="2" style="text-align:center;">input = 0</th>
<th colspan="2" style="text-align:center;">input = 1</th>
</tr>
<tr>
<th style="text-align:center;">State</th>
<th style="text-align:center;">Output</th>
<th style="text-align:center;">State</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td>&rarr; a</td>
<td>b</td>
<td>x<sub>1</sub></td>
<td>c</td>
<td>x<sub>1</sub></td>
</tr>
<tr>
<td>b</td>
<td>b</td>
<td>x<sub>2</sub></td>
<td>d</td>
<td>x<sub>3</sub></td>
</tr>
<tr>
<td>c</td>
<td>d</td>
<td>x<sub>3</sub></td>
<td>c</td>
<td>x<sub>1</sub></td>
</tr>
<tr>
<td>d</td>
<td>d</td>
<td>x<sub>3</sub></td>
<td>d</td>
<td>x<sub>2</sub></td>
</tr>
</table>
<p>The state diagram of the above Mealy Machine is &minus;</p>
<img src="/automata_theory/images/state_diagram_of_mealy_machine.jpg" alt="State Diagram of Mealy Machine" />
<h3>Moore Machine</h3>
<p>Moore machine is an FSM whose outputs depend on only the present state.</p>
<p>A Moore machine can be described by a 6 tuple (Q, &sum;, O, &delta;, X, q<sub>0</sub>) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states.</p></li>
<li><p><b>&sum;</b> is a finite set of symbols called the input alphabet.</p></li>
<li><p><b>O</b> is a finite set of symbols called the output alphabet.</p></li>
<li><p><b>&delta;</b> is the input transition function where &delta;: Q &times; &sum; &rarr; Q</p></li>
<li><p><b>X</b> is the output transition function where X: Q &rarr; O</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p></li>
</ul>
<p>The state table of a Moore Machine is shown below &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th rowspan="2" style="text-align:center; vertical-align:middle;">Present state</th>
<th colspan="2" style="text-align:center;">Next State</th>
<th rowspan="2" style="text-align:center; vertical-align:middle">Output</th>
</tr>
<tr>
<th style="text-align:center;">Input = 0</th>
<th style="text-align:center;">Input = 1</th>
</tr>
<tr>
<td>&rarr; a</td>
<td>b</td>
<td>c</td>
<td>x<sub>2</sub></td>
</tr>
<tr>
<td>b</td>
<td>b</td>
<td>d</td>
<td>x<sub>1</sub></td>
</tr>
<tr>
<td>c</td>
<td>c</td>
<td>d</td>
<td>x<sub>2</sub></td>
</tr>
<tr>
<td>d</td>
<td>d</td>
<td>d</td>
<td>x<sub>3</sub></td>
</tr>
</table>
<p>The state diagram of the above Moore Machine is &minus;</p>
<img src="/automata_theory/images/moore_machine_state_diagram.jpg" alt="Moore Machine State Diagram" />
<h3>Mealy Machine vs. Moore Machine</h3>
<p>The following table highlights the points that differentiate a Mealy Machine from a Moore Machine.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center">Mealy Machine</th>
<th style="text-align:center">Moore Machine</th>
</tr>
<tr>
<td>Output depends both upon the present state and the present input</td>
<td>Output depends only upon the present state.</td>
</tr>
<tr>
<td>Generally, it has fewer states than Moore Machine.</td>
<td>Generally, it has more states than Mealy Machine.</td>
</tr>
<tr>
<td>The value of the output function is a function of the transitions and the changes, when the input logic on the present state is done.</td>
<td>The value of the output function is a function of the current state and the changes at the clock edges, whenever state changes occur.</td>
</tr>
<tr>
<td>Mealy machines react faster to inputs. They generally react in the same clock cycle.</td>
<td>In Moore machines, more logic is required to decode the outputs resulting in more circuit delays. They generally react one clock cycle later.</td>
</tr>
</table>
<h2>Moore Machine to Mealy Machine</h2>
<h3>Algorithm 4</h3>
<p><b>Input</b> &minus; Moore Machine</p>
<p><b>Output</b> &minus; Mealy Machine</p>
<p><b>Step 1</b> &minus; Take a blank Mealy Machine transition table format.</p>
<p><b>Step 2</b> &minus; Copy all the Moore Machine transition states into this table format.</p>
<p><b>Step 3</b> &minus; Check the present states and their corresponding outputs in the Moore Machine state table; if for a state Q<sub>i</sub> output is m, copy it into the output columns of the Mealy Machine state table wherever Q<sub>i</sub> appears in the next state.</p>
<h3>Example</h3>
<p>Let us consider the following Moore machine &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th rowspan="2" style="vertical-align:middle;text-align:center;">Present State</th>
<th colspan="2" style="text-align:center;">Next State</th>
<th rowspan="2" style="vertical-align:middle;text-align:center;">Output</th>
</tr>
<tr>
<th style="text-align:center;">a = 0</th>
<th style="text-align:center;">a = 1</th>
</tr>
<tr>
<td>&rarr; a</td>
<td>d</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>a</td>
<td>d</td>
<td>0</td>
</tr>
<tr>
<td>c</td>
<td>c</td>
<td>c</td>
<td>0</td>
</tr>
<tr>
<td>d</td>
<td>b</td>
<td>a</td>
<td>1</td>
</tr>
</table>
<p>Now we apply Algorithm 4 to convert it to Mealy Machine.</p>
<p><b>Step 1 &amp; 2</b> &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th rowspan="3" style="vertical-align:middle;text-align:center;">Present State</th>
<th colspan="4" style="text-align:center;">Next State</th>
</tr>
<tr>
<th colspan="2" style="text-align:center;">a = 0</th>
<th colspan="2" style="text-align:center;">a = 1</th>
</tr>
<tr>
<th style="text-align:center;">State</th>
<th style="text-align:center;">Output</th>
<th style="text-align:center;">State</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td>&rarr; a</td>
<td>d</td>
<td></td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>b</td>
<td>a</td>
<td></td>
<td>d</td>
<td></td>
</tr>
<tr>
<td>c</td>
<td>c</td>
<td></td>
<td>c</td>
<td></td>
</tr>
<tr>
<td>d</td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
</tr>
</table>
<p><b>Step 3</b> &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th rowspan="3" style="vertical-align:middle;text-align:center;">Present State</th>
<th colspan="4" style="text-align:center;">Next State</th>
</tr>
<tr>
<th colspan="2" style="text-align:center;">a = 0</th>
<th colspan="2" style="text-align:center;">a = 1</th>
</tr>
<tr>
<th style="text-align:center;">State</th>
<th style="text-align:center;">Output</th>
<th style="text-align:center;">State</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td>=&gt; a</td>
<td>d</td>
<td>1</td>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>b</td>
<td>a</td>
<td>1</td>
<td>d</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>c</td>
<td>0</td>
<td>c</td>
<td>0</td>
</tr>
<tr>
<td>d</td>
<td>b</td>
<td>0</td>
<td>a</td>
<td>1</td>
</tr>
</table>
<h2>Mealy Machine to Moore Machine</h2>
<h3>Algorithm 5</h3>
<p><b>Input</b> &minus; Mealy Machine</p>
<p><b>Output</b> &minus; Moore Machine</p>
<p><b>Step 1</b> &minus; Calculate the number of different outputs for each state (Q<sub>i</sub>) that are available in the state table of the Mealy machine.</p>
<p><b>Step 2</b> &minus; If all the outputs of Qi are same, copy state Q<sub>i</sub>. If it has n distinct outputs, break Q<sub>i</sub> into n states as Q<sub>in</sub> where <b>n</b> = 0, 1, 2.......</p>
<p><b>Step 3</b> &minus; If the output of the initial state is 1, insert a new initial state at the beginning which gives 0 output.</p>
<h3>Example</h3>
<p>Let us consider the following Mealy Machine &minus;</p>
<table class="table table-bordered">
<tr>
<th rowspan="3" style="vertical-align:middle;text-align:center;">Present State</th>
<th colspan="4" style="text-align:center;">Next State</th>
</tr>
<tr>
<th colspan="2" style="text-align:center;">a = 0</th>
<th colspan="2" style="text-align:center;">a = 1</th>
</tr>
<tr>
<th style="text-align:center;">Next State</th>
<th style="text-align:center;">Output</th>
<th style="text-align:center;">Next State</th>
<th style="text-align:center;">Output</th>
</tr>
<tr style="text-align:center;">
<td>&rarr; a</td>
<td>d</td>
<td>0</td>
<td>b</td>
<td>1</td>
</tr>
<tr style="text-align:center;">
<td>b</td>
<td>a</td>
<td>1</td>
<td>d</td>
<td>0</td>
</tr>
<tr style="text-align:center;">
<td>c</td>
<td>c</td>
<td>1</td>
<td>c</td>
<td>0</td>
</tr>
<tr style="text-align:center;">
<td>d</td>
<td>b</td>
<td>0</td>
<td>a</td>
<td>1</td>
</tr>
</table>
<p>Here, states ‘a’ and ‘d’ give only 1 and 0 outputs respectively, so we retain states ‘a’ and ‘d’. But states ‘b’ and ‘c’ produce different outputs (1 and 0). So, we divide <b>b</b> into <b>b<sub>0</sub>, b<sub>1</sub></b> and <b>c</b> into <b>c<sub>0</sub>, c<sub>1</sub></b>.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th rowspan="2" style="vertical-align:middle;text-align:center;">Present State</th>
<th colspan="2" style="text-align:center;">Next State</th>
<th rowspan="2" style="vertical-align:middle;text-align:center;">Output</th>
</tr>
<tr>
<th style="text-align:center;">a = 0</th>
<th style="text-align:center;">a = 1</th>
</tr>
<tr>
<td>&rarr; a</td>
<td>d</td>
<td>b<sub>1</sub></td>
<td>1</td>
</tr>
<tr>
<td>b<sub>0</sub></td>
<td>a</td>
<td>d</td>
<td>0</td>
</tr>
<tr>
<td>b<sub>1</sub></td>
<td>a</td>
<td>d</td>
<td>1</td>
</tr>
<tr>
<td>c<sub>0</sub></td>
<td>c<sub>1</sub></td>
<td>C<sub>0</sub></td>
<td>0</td>
</tr>
<tr>
<td>c<sub>1</sub></td>
<td>c<sub>1</sub></td>
<td>C<sub>0</sub></td>
<td>1</td>
</tr>
<tr>
<td>d</td>
<td>b<sub>0</sub></td>
<td>a</td>
<td>0</td>
</tr>
</table>
<h1>Introduction to Grammars</h1>
<p>n the literary sense of the term, grammars denote syntactical rules for conversation in natural languages. Linguistics have attempted to define grammars since the inception of natural languages like English, Sanskrit, Mandarin, etc.</p>
<p>The theory of formal languages finds its applicability extensively in the fields of Computer Science. <b>Noam Chomsky</b> gave a mathematical model of grammar in 1956 which is effective for writing computer languages.</p>
<h2>Grammar</h2>
<p>A grammar <b>G</b> can be formally written as a 4-tuple (N, T, S, P) where &minus;</p>
<ul class="list">
<li><p><b>N</b> or <b>V<sub><i><small>N</small></i></sub></b> is a set of variables or non-terminal symbols.</p></li>
<li><p><b>T</b> or <b>&sum;</b> is a set of Terminal symbols.</p></li>
<li><p><b>S</b> is a special variable called the Start symbol, S &isin; N</p></li>
<li><p><b>P</b> is Production rules for Terminals and Non-terminals. A production rule has the form &alpha; &rarr; &beta;, where &alpha; and &beta; are strings on V<sub><i><small>N</small></i></sub> &cup; &sum; and least one symbol of &alpha; belongs to V<sub>N</sub>.</p></li>
</ul>
<h3>Example</h3>
<p>Grammar G1 &minus;</p>
<p style="padding-left:10%;">({S, A, B}, {a, b}, S, {S &rarr; AB, A &rarr; a, B &rarr; b})</p>
<p>Here,</p>
<ul class="list">
<li><p><b>S, A,</b> and <b>B</b> are Non-terminal symbols;</p></li>
<li><p><b>a</b> and <b>b</b> are Terminal symbols</p></li>
<li><p><b>S</b> is the Start symbol, S &isin; N</p></li>
<li><p>Productions, <b>P : S &rarr; AB, A &rarr; a, B &rarr; b</b></p></li>
</ul>
<h3>Example</h3>
<p>Grammar G2 &minus;</p>
<p style="padding-left:10%;">(({S, A}, {a, b}, S,{S &rarr; aAb, aA &rarr; aaAb, A &rarr; &epsilon; } )</p> 
<p>Here,</p>
<ul class="list">
<li><p><b>S</b> and <b>A</b> are Non-terminal symbols.</p></li>
<li><p><b>a</b> and <b>b</b> are Terminal symbols.</p></li>
<li><p><b>&epsilon;</b> is an empty string.</p></li>
<li><p><b>S</b> is the Start symbol, S &isin; N</p></li>
<li><p>Production <b>P : S &rarr; aAb, aA &rarr; aaAb, A &rarr; &epsilon;</b></p></li>
</ul>
<h2>Derivations from a Grammar</h2>
<p>Strings may be derived from other strings using the productions in a grammar. If a grammar <b>G</b> has a production <b>&alpha; &rarr; &beta;</b>, we can say that <b>x &alpha; y</b> derives <b>x &beta; y</b> in <b>G</b>. This derivation is written as &minus;</p>
<p style="text-align:center;"><i><b>x &alpha; y <span class="sy-r">&rArr;<span class="oxbr">G</span></span> x &beta; y</b></i></p>
<h3>Example</h3>
<p>Let us consider the grammar &minus;</p>
<p style="padding-left:10%;">G2 = ({S, A}, {a, b}, S, {S &rarr; aAb, aA &rarr; aaAb, A &rarr; &epsilon; } )</p>
<p>Some of the strings that can be derived are &minus;</p>
<p style="padding-left:10%;">S &rArr; <u>aA</u>b <span style="padding-left:10%;">using production S &rarr; aAb</span></p>
<p style="padding-left:12%;">&rArr; a<u>aA</u>bb <span style="padding-left:7.5%;">using production aA &rarr; aAb</span></p>
<p style="padding-left:12%;">&rArr; aaa<u>A</u>bbb <span style="padding-left:4.5%;">using production aA &rarr; aAb</span></p>
<p style="padding-left:12%;">&rArr; aaabbb <span style="padding-left:6%;">using production A &rarr; &epsilon;</span></p>
<h1>Language Generated by a Grammar</h1>
<p>The set of all strings that can be derived from a grammar is said to be the language generated from that grammar. A language generated by a grammar <b>G</b> is a subset formally defined by</p>
<p style="text-align:center;">L(G)={W|W &isin; &sum;*, S <span class="sy-r">&rArr;<span class="oxbr">G</span></span> <b>W</b>}</p>
<p>If <b>L(G1) = L(G2)</b>, the Grammar <b>G1</b> is equivalent to the Grammar <b>G2</b>.</p>
<h3>Example</h3>
<p>If there is a grammar</p>
<p style="padding-left:10%;">G: N = {S, A, B} T = {a, b} P = {S &rarr; AB, A &rarr; a, B &rarr; b}</p>
<p>Here <b>S</b> produces <b>AB</b>, and we can replace <b>A</b> by <b>a</b>, and <b>B</b> by <b>b</b>. Here, the only accepted string is <b>ab</b>, i.e.,</p>
<p style="padding-left:10%;">L(G) = {ab}</p>
<h3>Example</h3>
<p>Suppose we have the following grammar &minus;</p>
<p style="padding-left:10%;">G: N = {S, A, B} T = {a, b} P = {S &rarr; AB, A &rarr; aA|a, B &rarr; bB|b}</p>
<p>The language generated by this grammar &minus;</p>
<p style="padding-left:10%;">L(G) = {ab, a<sup>2</sup>b, ab<sup>2</sup>, a<sup>2</sup>b<sup>2</sup>, ………}</p>
<p style="padding-left:16%">= {a<sup>m</sup> b<sup>n</sup> | m &ge; 1 and n &ge; 1}</p>
<h2>Construction of a Grammar Generating a Language</h2>
<p>We’ll consider some languages and convert it into a grammar G which produces those languages.</p>
<h3>Example</h3>
<p><b><i>Problem</i></b> &minus; Suppose, L (G) = {a<sup>m</sup> b<sup>n</sup> | m &ge; 0 and n &gt; 0}. We have to find out the grammar <b>G</b> which produces <b>L(G)</b>.</p>
<p><b><i>Solution</i></b></p>
<p>Since L(G) = {a<sup>m</sup> b<sup>n</sup> | m &ge; 0 and n &gt; 0}</p>
<p>the set of strings accepted can be rewritten as &minus;</p>
<p style="padding-left:10%;">L(G) = {b, ab,bb, aab, abb,  …….}</p>
<p>Here, the start symbol has to take at least one ‘b’ preceded by any number of ‘a’ including null.</p>
<p>To accept the string set {b, ab, bb, aab, abb, …….}, we have taken the productions &minus;</p>
<p style="padding-left:10%;">S &rarr; aS , S &rarr; B, B &rarr; b and B &rarr; bB</p>
<p style="padding-left:10%;">S &rarr; B &rarr; b (Accepted)</p>
<p style="padding-left:10%;">S &rarr; B &rarr; bB &rarr; bb (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aS &rarr; aB &rarr; ab (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aS &rarr; aaS &rarr; aaB &rarr; aab(Accepted)</p>
<p style="padding-left:10%;">S &rarr; aS &rarr; aB &rarr; abB &rarr; abb (Accepted)</p>
<p>Thus, we can prove every single string in L(G) is accepted by the language generated by the production set.</p>
<p>Hence the grammar &minus;</p>
<p style="padding-left:10%;">G: ({S, A, B}, {a, b}, S, { S &rarr; aS | B , B &rarr; b | bB })</p>
<h3>Example</h3>
<p><b><i>Problem</i></b> &minus; Suppose, L (G) = {a<sup>m</sup> b<sup>n</sup> | m &gt; 0 and n &ge; 0}. We have to find out the grammar G which produces L(G).</p>
<p><b><i>Solution</i></b> &minus;</p>
<p>Since L(G) = {a<sup>m</sup> b<sup>n</sup> | m &gt; 0 and n &ge; 0}, the set of strings accepted can be rewritten as &minus;</p>
<p style="padding-left:10%;">L(G) = {a, aa, ab, aaa, aab ,abb, …….}</p>
<p>Here, the start symbol has to take at least one ‘a’ followed by any number of ‘b’ including null.</p>
<p>To accept the string set {a, aa, ab, aaa, aab, abb, …….}, we have taken the productions &minus;</p>
<p style="padding-left:10%;">S &rarr; aA, A &rarr; aA , A &rarr; B, B &rarr; bB ,B &rarr; &lambda;</p>
<p style="padding-left:10%;">S &rarr; aA &rarr; aB &rarr; a&lambda; &rarr; a (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aA &rarr; aaA &rarr; aaB &rarr; aa&lambda; &rarr; aa (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aA &rarr; aB &rarr; abB &rarr; ab&lambda; &rarr; ab (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aA &rarr; aaA &rarr; aaaA &rarr; aaaB &rarr; aaa&lambda; &rarr; aaa (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aA &rarr; aaA &rarr; aaB &rarr; aabB &rarr; aab&lambda; &rarr; aab (Accepted)</p>
<p style="padding-left:10%;">S &rarr; aA &rarr; aB &rarr; abB &rarr; abbB &rarr; abb&lambda; &rarr; abb (Accepted)</p>
<p>Thus, we can prove every single string in L(G) is accepted by the language generated by the production set.</p>
<p>Hence the grammar &minus;</p>
<p style="padding-left:10%;">G: ({S, A, B}, {a, b}, S, {S &rarr; aA, A &rarr; aA | B,  B &rarr; &lambda; | bB })</p>
<h1>Chomsky Classification of Grammars</h1>
<p>According to Noam Chomosky, there are four types of grammars &minus; Type 0, Type 1, Type 2, and Type 3. The following table shows how they differ from each other &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Grammar Type</th>
<th style="text-align:center;">Grammar Accepted</th>
<th style="text-align:center;">Language Accepted</th>
<th style="text-align:center;">Automaton</p>
</tr>
<tr>
<td>Type 0</td>
<td>Unrestricted grammar</td>
<td>Recursively enumerable language</td>
<td>Turing Machine</td>
</tr>
<tr>
<td>Type 1</td>
<td>Context-sensitive grammar</td>
<td>Context-sensitive language</td>
<td>Linear-bounded automaton</td>
</tr>
<tr>
<td>Type 2</td>
<td>Context-free grammar</td>
<td>Context-free language</td>
<td>Pushdown automaton</td>
</tr>
<tr>
<td>Type 3</td>
<td>Regular grammar</td>
<td>Regular language</td>
<td>Finite state automaton</td>
</tr>
</table>
<p>Take a look at the following illustration. It shows the scope of each type of grammar &minus;</p>
<img src="/automata_theory/images/containment_of_type3_type2_type1_type0.jpg" alt="Containment of Type3, Type2, Type1, Type0" />
<h2>Type - 3 Grammar</h2>
<p><b>Type-3 grammars</b> generate regular languages. Type-3 grammars must have a single non-terminal on the left-hand side and a right-hand side consisting of a single terminal or single terminal followed by a single non-terminal.</p>
<p>The productions must be in the form <b>X &rarr; a or X &rarr; aY</b></p>
<p>where <span style="padding-left:2%;"><b>X, Y &isin; N</b> (Non terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>a &isin; T</b> (Terminal)</span></p>
<p>The rule <b>S &rarr; &epsilon;</b> is allowed if <b>S</b> does not appear on the right side of any rule.</p>
<h3>Example</h3>
<pre class="result notranslate">
X &rarr; &epsilon; 
X &rarr; a | aY
Y &rarr; b 
</pre>
<h2>Type - 2 Grammar</h2>
<p><b>Type-2 grammars</b> generate context-free languages.</p>
<p>The productions must be in the form <b>A &rarr; γ</b></p>
<p>where <span style="padding-left:2%;"><b> A &isin; N</b> (Non terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>γ &isin; (T &cup; N)*</b> (String of terminals and non-terminals).</span></p>
<p>These languages generated by these grammars are be recognized by a non-deterministic pushdown automaton.</p>
<h3>Example</h3>
<pre class="result notranslate">
S &rarr; X a 
X &rarr; a 
X &rarr; aX 
X &rarr; abc 
X &rarr; &epsilon;
</pre>
<h2>Type - 1 Grammar</h2>
<p><b>Type-1 grammars</b> generate context-sensitive languages. The productions must be in the form</p>
<p style="padding-left:12%;"><b>&alpha; A &beta; &rarr; &alpha; γ &beta;</b></p>
<p>where <span style="padding-left:2%;"><b>A &isin; N</b> (Non-terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>&alpha;, &beta;, γ &isin; (T &cup; N)*</b> (Strings of terminals and non-terminals)</span></p>
<p>The strings <b>&alpha;</b> and <b>&beta;</b> may be empty, but <b>γ</b> must be non-empty.</p>
<p>The rule <b>S &rarr; &epsilon;</b> is allowed if S does not appear on the right side of any rule. The languages generated by these grammars are recognized by a linear bounded automaton.</p>
<h3>Example</h3>
<pre class="result notranslate">
AB &rarr; AbBc 
A &rarr; bcA 
B &rarr; b 
</pre>
<h2>Type - 0 Grammar</h2>
<p><b>Type-0 grammars</b> generate recursively enumerable languages. The productions have no restrictions. They are any phase structure grammar including all formal grammars.</p>
<p>They generate the languages that are recognized by a Turing machine.</p>
<p>The productions can be in the form of <b>&alpha; &rarr; &beta;</b> where <b>&alpha;</b> is a string of terminals and nonterminals with at least one non-terminal and <b>&alpha;</b> cannot be null. <b>&beta;</b> is a string of terminals and non-terminals.</p>
<h3>Example</h3>
<pre class="result notranslate">
S &rarr; ACaB 
Bc &rarr; acB 
CB &rarr; DB 
aD &rarr; Db 
</pre>
<h1>Regular Expressions</h1>
<p>A <b>Regular Expression</b> can be recursively defined as follows &minus;</p>
<ul class="list">
<li><p><b>&epsilon;</b> is a Regular Expression indicates the language containing an empty string. <b>(L (&epsilon;) = {&epsilon;})</b></p></li>
<li><p><b>&phi;</b> is a Regular Expression denoting an empty language. <b>(L (&phi;) = { })</b></p></li>
<li><p><b>x</b> is a Regular Expression where <b>L = {x}</b></p></li>
<li><p>If <b>X</b> is a Regular Expression denoting the language <b>L(X)</b> and <b>Y</b> is a Regular Expression denoting the language <b>L(Y)</b>, then</p>
<ul class="list">
<li><p><b>X + Y</b> is a Regular Expression corresponding to the language <b>L(X) &cup; L(Y)</b> where <b>L(X+Y) = L(X) &cup; L(Y)</b>.</p></li>
<li><p><b>X . Y</b> is a Regular Expression corresponding to the language <b>L(X) . L(Y)</b> where <b>L(X.Y) = L(X) . L(Y)</b></p></li>
<li><p><b>R*</b> is a Regular Expression corresponding to the language <b>L(R*)</b>where <b>L(R*) = (L(R))*</b></p></li>
</ul>
</li>
<li><p>If we apply any of the rules several times from 1 to 5, they are Regular Expressions.</p></li>
</ul>
<h2>Some RE Examples</h2>
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:25%">Regular Expressions</th>
<th style="text-align:center;">Regular Set</th>
</tr>
<tr>
<td style="text-align:center">(0 + 10*)</td>
<td>L = { 0, 1, 10, 100, 1000, 10000, … }</td>
</tr>
<tr>
<td style="text-align:center">(0*10*)</td>
<td>L = {1, 01, 10, 010, 0010, …}</td>
</tr>
<tr>
<td style="text-align:center">(0 + &epsilon;)(1 + &epsilon;)</td>
<td>L = {&epsilon;, 0, 1, 01}</td>
</tr>
<tr>
<td style="text-align:center">(a+b)*</td>
<td>Set of strings of a’s and b’s of any length including the null string.  So L = { &epsilon;, a, b, aa , ab , bb , ba, aaa…….}</td>
</tr>
<tr>
<td style="text-align:center">(a+b)*abb</td>
<td>Set of strings of a’s and b’s ending with the string abb. So L = {abb, aabb, babb, aaabb, ababb, …………..}</td>
</tr>
<tr>
<td style="text-align:center">(11)*</td>
<td>Set consisting of even number of 1’s including empty string, So L= {&epsilon;, 11, 1111, 111111, ……….}</td>
</tr>
<tr>
<td style="text-align:center">(aa)*(bb)*b</td>
<td>Set of strings consisting of even number of a’s followed by odd number of b’s , so L = {b, aab, aabbb, aabbbbb, aaaab, aaaabbb, …………..}</td>
</tr>
<tr>
<td style="text-align:center">(aa + ab + ba + bb)*</td>
<td>String of a’s and b’s of even length can be obtained by concatenating any combination of the strings aa, ab, ba and bb  including null, so L = {aa, ab, ba, bb, aaab, aaba, …………..}</td>
</tr>
</table>
<h1>Regular Sets</h1>
<p>Any set that represents the value of the Regular Expression is called a <b>Regular Set.</b></p>
<h3>Properties of Regular Sets</h3>
<p><b>Property 1</b>. <i>The union of two regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take two regular expressions</p>
<p style="padding-left:10%;">RE<sub>1</sub> = a(aa)*  and RE<sub>2</sub> = (aa)*</p>
<p>So, <span style="padding-left:2%">L<sub>1</sub> = {a, aaa, aaaaa,.....} (Strings of odd length excluding Null)</span></p>
<p>and  <span style="padding-left:2%">L<sub>2</sub> ={ &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</span></p>
<p style="padding-left:7%;">L<sub>1</sub> &cup; L<sub>2</sub> = { &epsilon;, a, aa, aaa, aaaa, aaaaa, aaaaaa,.......}</p>
<p style="padding-left:7%;">(Strings of all possible lengths including Null)</p>
<p style="padding-left:7%;">RE (L<sub>1</sub> &cup; L<sub>2</sub>) = a* <span style="padding-left:2%;">(which is a regular expression itself)</span></p>
<p><b>Hence, proved.</b></p>
<p><b>Property 2.</b> <i>The intersection of two regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take two regular expressions</p>
<p style="padding-left:10%;">RE<sub>1</sub> = a(a*)   and RE<sub>2</sub> = (aa)*</p>
<p>So, <span style="padding-left:2%">L<sub>1</sub> = { a,aa, aaa, aaaa, ....}  (Strings of all possible lengths excluding Null)</span></p>
<p style="padding-left:6%;">L<sub>2</sub> = { &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</p>
<p style="padding-left:6%;">L<sub>1</sub> &cap; L<sub>2</sub> = { aa, aaaa, aaaaaa,.......} (Strings of even length excluding Null)</p>
<p style="padding-left:6%;">RE (L<sub>1</sub> &cap; L<sub>2</sub>) = aa(aa)* which is a regular expression itself.</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 3.</b> <i>The complement of a regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take a regular expression &minus;</p>
<p style="padding-left:10%;">RE = (aa)*</p>
<p>So, <span style="padding-left:2%;">L = {&epsilon;, aa, aaaa, aaaaaa, .......} (Strings of even length including Null)</span></p>
<p>Complement of <b>L</b> is all the strings that is not in <b>L</b>.</p>
<p>So, <span style="padding-left:2%;">L’ = {a, aaa, aaaaa, .....} (Strings of odd length excluding Null)</span></p>
<p style="padding-left:6%;">RE (L’) = a(aa)* which is a regular expression itself.</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 4.</b> <i>The difference of two regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take two regular expressions &minus;</p>
<p style="padding-left:10%;">RE<sub>1</sub> = a (a*) and RE<sub>2</sub> = (aa)*</p>
<p>So, <span style="padding-left:2%;">L<sub>1</sub> = {a, aa, aaa, aaaa, ....} (Strings of all possible lengths excluding Null)</span></p>
<p style="padding-left:6%;">L<sub>2</sub> = { &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</p>
<p style="padding-left:6%;">L<sub>1</sub> – L<sub>2</sub> = {a, aaa, aaaaa, aaaaaaa, ....}</p>
<p style="padding-left:6%;">(Strings of all odd lengths excluding Null)</p>
<p style="padding-left:6%;">RE (L<sub>1</sub> – L<sub>2</sub>) = a (aa)* which is a regular expression.</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 5.</b> <i>The reversal of a regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>We have to prove <b>L<sup>R</sup></b> is also regular if <b>L</b> is a regular set.</p>
<p>Let, <span style="padding-left:2%">L = {01, 10, 11, 10}</span></p>
<p style="padding-left:7%;">RE (L) = 01 + 10 + 11 + 10</p>
<p style="padding-left:7%;">L<sup>R</sup> = {10, 01, 11, 01}</p>
<p style="padding-left:7%;">RE (L<sup>R</sup>) = 01 + 10 + 11 + 10 which is regular</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 6.</b> <i>The closure of a regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p style="padding-left:7%;">If L = {a, aaa, aaaaa, .......} <span style="padding-left:6%;">(Strings of odd length excluding Null)</span></p>
<p>i.e.,<span style="padding-left:2%;"> RE (L) = a (aa)*</span></p>
<p style="padding-left:7%;">L* = {a, aa, aaa, aaaa , aaaaa,……………} <span style="padding-left:3%;">(Strings of all lengths excluding Null)</span></p>
<p>RE (L*) = a (a)*</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 7.</b> <i>The concatenation of two regular sets is regular.</i></p>
<p><b>Proof &minus;</b></p>
<p>Let <span style="padding-left:4%">RE<sub>1</sub> = (0+1)*0 and RE<sub>2</sub> = 01(0+1)*</span></p>
<p>Here,<span style="padding-left:2%"> L<sub>1</sub> = {0, 00, 10, 000, 010, ......} <span style="padding-left:5%;">(Set of strings ending in 0)</span></span></p>
<p>and <span style="padding-left:4%">L<sub>2</sub> = {01, 010,011,.....} <span style="padding-left:15%;">(Set of strings beginning with 01)</span></span></p>
<p>Then,<span style="padding-left:2%"> L<sub>1</sub> L<sub>2</sub> = {001,0010,0011,0001,00010,00011,1001,10010,.............}</span></p>
<p>Set of strings containing 001 as a substring which can be represented by an RE &minus; (0 + 1)*001(0 + 1)*</p>
<p>Hence, proved.</p>
<h2>Identities Related to Regular Expressions</h2>
<p>Given R, P, L, Q as regular expressions, the following identities hold &minus;</p>
<ul class="list">
<li>&empty;* = &epsilon;</li>
<li>&epsilon;* = &epsilon;</li>
<li>RR* = R*R</li>
<li>R*R* = R*</li>
<li>(R*)* = R*</li>
<li>RR* = R*R</li>
<li>(PQ)*P =P(QP)*</li>
<li>(a+b)* = (a*b*)* = (a*+b*)* = (a+b*)* = a*(ba*)*</li>
<li>R + &empty; = &empty; + R = R <span style="padding-left:8%;">(The identity for union)</span></li>
<li>R &epsilon; = &epsilon; R = R <span style="padding-left:14%;">(The identity for concatenation)</span></li>
<li>&empty; L = L &empty; = &empty; <span style="padding-left:14%;">(The annihilator for concatenation)</span></li>
<li>R + R = R <span style="padding-left:18%;">(Idempotent law)</span></li>
<li>L (M + N) = LM + LN <span style="padding-left:5%;">(Left distributive law)</span></li>
<li>(M + N) L = ML + NL <span style="padding-left:5%;">(Right distributive law)</span></li>
<li>&epsilon; + RR* = &epsilon; + R*R = R*</li>
</ul>
<h1>Arden's Theorem</h1>
<p>In order to find out a regular expression of a Finite Automaton, we use Arden’s Theorem along with the properties of regular expressions.</p>
<p><b><i>Statement</i></b> &minus;</p>
<p style="padding-left:6%;">Let <b>P</b> and <b>Q</b> be two regular expressions.</p>
<p style="padding-left:6%;">If <b>P</b> does not contain null string, then <b>R = Q + RP</b> has a unique solution that is <b>R = QP*</b></p>
<p><b>Proof</b> &minus;</p>
<p style="padding-left:6%;">R = Q + (Q + RP)P <span style="padding-left:3%">[After putting the value R = Q + RP]</span></p>
<p style="padding-left:8%;">= Q + QP + RPP</p>
<p>When we put the value of <b>R</b> recursively again and again, we get the following equation &minus;</p>
<p style="padding-left:6%;">R = Q + QP + QP<sup>2</sup> + QP<sup>3</sup>…..</p>
<p style="padding-left:6%;">R = Q (&epsilon; + P + P<sup>2</sup> + P<sup>3</sup> + …. )</p>
<p style="padding-left:6%;">R = QP* <span style="padding-left:3%">[As P* represents (&epsilon; + P + P2 + P3 + ….) ]</span></p>
<p>Hence, proved.</p>
<h2>Assumptions for Applying Arden’s Theorem</h2>
<ul class="list">
<li>The transition diagram must not have NULL transitions</li>
<li>It must have only one initial state</li>
</ul>
<h3>Method</h3>
<p><b>Step 1</b> &minus; Create equations as the following form for all the states of the DFA having n states with initial state q<sub>1</sub>.</p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>R<sub>11</sub> + q<sub>2</sub>R<sub>21</sub> + … + q<sub>n</sub>R<sub>n1</sub> + &epsilon;</p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>R<sub>12</sub> + q<sub>2</sub>R<sub>22</sub> + … + q<sub>n</sub>R<sub>n2</sub></p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">q<sub>n</sub> = q<sub>1</sub>R<sub>1n</sub> + q<sub>2</sub>R<sub>2n</sub> + … + q<sub>n</sub>R<sub>nn</sub></p>
<p><b>R<sub>ij</sub></b> represents the set of labels of edges from <b>q<sub>i</sub></b> to <b>q<sub>j</sub></b>, if no such edge exists, then <b>R<sub>ij</sub> = &empty;</b></p>
<p><b>Step 2</b> &minus; Solve these equations to get the equation for the final state in terms of <b>R<sub>ij</sub></b></p>
<p><b>Problem</b></p>
<p>Construct a regular expression corresponding to the automata given below &minus;</p>
<img src="/automata_theory/images/finite_automata.jpg" alt="Finite Automata" />
<p><b>Solution</b> &minus;</p>
<p>Here the initial state and final state is <b>q<sub>1</sub></b>.</p>
<p>The equations for the three states q1, q2, and q3 are as follows &minus;</p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>a + q<sub>3</sub>a + &epsilon; <span style="padding-left:3%">(&epsilon; move is because q1 is the initial state0</span></p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>b + q<sub>2</sub>b + q<sub>3</sub>b</p>
<p style="padding-left:8%;">q<sub>3</sub> = q<sub>2</sub>a</p>
<p>Now, we will solve these three equations &minus;</p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>b + q<sub>2</sub>b + q<sub>3</sub>b</p>
<p style="padding-left:11%;"> = q<sub>1</sub>b + q<sub>2</sub>b + (q<sub>2</sub>a)b <span style="padding-left:12%">(Substituting value of q<sub>3</sub>)</span></p>
<p style="padding-left:11%;">= q<sub>1</sub>b + q<sub>2</sub>(b + ab)</p>
<p style="padding-left:11%;">= q<sub>1</sub>b (b + ab)* <span style="padding-left:19%">(Applying Arden’s Theorem)</span></p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>a + q<sub>3</sub>a + &epsilon;</p>
<p style="padding-left:11%;">= q<sub>1</sub>a + q<sub>2</sub>aa + &epsilon; <span style="padding-left:17%">(Substituting value of q<sub>3</sub>)</span></p>
<p style="padding-left:11%;">= q<sub>1</sub>a + q<sub>1</sub>b(b + ab*)aa + &epsilon; <span style="padding-left:3%">(Substituting value of q<sub>2</sub>)</span></p>
<p style="padding-left:11%;">= q<sub>1</sub>(a + b(b + ab)*aa) + &epsilon;</p>
<p style="padding-left:11%;">= &epsilon; (a+ b(b + ab)*aa)*</p>
<p style="padding-left:11%;">= (a + b(b + ab)*aa)*</p>
<p>Hence, the regular expression is (a + b(b + ab)*aa)*.</p>
<p><b>Problem</b></p>
<p>Construct a regular expression corresponding to the automata given below &minus;</p>
<img src="/automata_theory/images/finite_automata1.jpg" alt="Finite Automata1" />
<p><b>Solution</b> &minus;</p>
<p>Here the initial state is q<sub>1</sub> and the final state is q<sub>2</sub></p>
<p>Now we write down the equations &minus;</p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>0 + &epsilon;</p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>1 + q<sub>2</sub>0</p>
<p style="padding-left:8%;">q<sub>3</sub> = q<sub>2</sub>1 + q<sub>3</sub>0 + q<sub>3</sub>1</p>
<p>Now, we will solve these three equations &minus;</p>
<p style="padding-left:8%;">q<sub>1</sub> = &epsilon;0* [As, εR = R]</p>
<p>So, <span style="padding-left:4%;">q<sub>1</sub> = 0*</span></p>
<p style="padding-left:8%;">q<sub>2</sub> = 0*1 + q<sub>2</sub>0</p>
<p>So, <span style="padding-left:4%;">q<sub>2</sub> = 0*1(0)* [By Arden’s theorem]</span></p>
<p>Hence, the regular expression is 0*10*.</p>
<h1>Construction of an FA from an RE</h1>
<p>We can use Thompson's Construction to find out a Finite Automaton from a Regular Expression. We will reduce the regular expression into smallest regular expressions and converting these to NFA and finally to DFA.</p>
<p>Some basic RA expressions are the following &minus;</p>
<p><b><i>Case 1</i></b> &minus; For a regular expression ‘a’, we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re.jpg" alt="Finite Automata for RE" />
<p><b><i>Case 2</i></b> &minus; For a regular expression ‘ab’, we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re1.jpg" alt="Finite Automata for RE1" />
<p><b><i>Case 3</i></b> &minus; For a regular expression (a+b), we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re2.jpg" alt="Finite Automata for RE2" />
<p><b><i>Case 4</i></b> &minus; For a regular expression (a+b)*, we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re3.jpg" alt="Finite Automata for RE3" />
<h3>Method</h3>
<p><b>Step 1</b> <span style="padding-left:3%;">Construct an NFA with Null moves from the given regular expression.</span></p>
<p><b>Step 2</b> <span style="padding-left:3%;">Remove Null transition from the NFA and convert it into its equivalent DFA.</span></p>
<p><b>Problem</b></p>
<p>Convert the following RA into its equivalent DFA &minus; 1 (0 + 1)* 0</p>
<p><b><i>Solution</i></b></p>
<p>We will concatenate three expressions "1", "(0 + 1)*" and "0"</p>
<img src="/automata_theory/images/ndfa_with_null_transition_for_ra.jpg" alt="NDFA with Null Transition for RA" />
<p>Now we will remove the <b>&epsilon;</b> transitions. After we remove the <b>&epsilon;</b> transitions from the NDFA, we get the following &minus;</p>
<img src="/automata_theory/images/ndfa_with_null_transition_for_ra1.jpg" alt="NDFA with Null Transition for RA1" />
<p>It is an NDFA corresponding to the RE &minus; 1 (0 + 1)* 0. If you want to convert it into a DFA, simply apply the method of converting NDFA to DFA discussed in Chapter 1.</p>
<h2>Finite Automata with Null Moves (NFA-&epsilon;)</h2>
<p>A Finite Automaton with null moves (FA-&epsilon;) does transit not only after giving input from the alphabet set but also without any input symbol. This transition without input is called a <b>null move</b>.</p>
<p>An NFA-&epsilon; is represented formally by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), consisting of</p>
<ul class="list">
<li><p><b>Q</b> &minus; a finite set of states</p></li>
<li><p><b>&sum;</b> &minus; a finite set of input symbols</p></li>
<li><p><b>&delta;</b> &minus; a transition function δ : Q &times; (&sum; &cup; {&epsilon;}) &rarr; 2<sup>Q</sup></p></li>
<li><p><b>q<sub>0</sub></b> &minus; an initial state q<sub>0</sub> &isin; Q</p></li>
<li><p><b>F</b> &minus; a set of final state/states of Q (F&sube;Q).</p></li>
</ul>
<img src="/automata_theory/images/finite_automata_with_null_moves.jpg" alt="Finite Automata with Null Moves" />
<p>The above <b>(FA-&epsilon;)</b> accepts a string set &minus; {0, 1, 01}</p>
<h2>Removal of Null Moves from Finite Automata</h2>
<p>If in an NDFA, there is  ϵ-move between vertex X to vertex Y, we can remove it using the following steps &minus;</p>
<ul class="list">
<li>Find all the outgoing edges from Y.</li>
<li>Copy all these edges starting from X without changing the edge labels.</li>
<li>If X is an initial state, make Y also an initial state.</li>
<li>If Y is a final state, make X also a final state.</li>
</ul>
<p><b>Problem</b></p>
<p>Convert the following NFA-&epsilon; to NFA without Null move.</p>
<img src="/automata_theory/images/finite_automata_with_null_moves1.jpg" alt="Finite Automata with Null Moves1" />
<p><b><i>Solution</i></b></p>
<p><b>Step 1</b> &minus;</p>
<p style="padding-left:8%;">Here the &epsilon; transition is between <b>q<sub>1</sub></b> and <b>q<sub>2</sub></b>, so let <b>q<sub>1</sub></b> is <b>X</b> and <b>q<sub>f</sub></b> is <b>Y</b>.</p>
<p style="padding-left:8%;">Here the outgoing edges from q<sub>f</sub> is to q<sub>f</sub> for inputs 0 and 1.</p>
<p><b>Step 2</b> &minus;</p>
<p style="padding-left:8%;">Now we will Copy all these edges from q<sub>1</sub> without changing the edges from q<sub>f</sub> and get the following FA &minus;</p>
<img src="/automata_theory/images/ndfa_after_step2.jpg" alt="NDFA After Step 2" />
<p><b>Step 3</b> &minus;</p>
<p style="padding-left:8%;">Here q<sub>1</sub> is an initial state, so we make q<sub>f</sub> also an initial state.</p>
<p style="padding-left:8%;">So the FA becomes &minus;</p>
<img src="/automata_theory/images/ndfa_after_step3.jpg" alt="NDFA After Step 3" />
<p><b>Step 4</b> &minus;</p>
<p style="padding-left:8%;">Here q<sub>f</sub> is a final state, so we make q<sub>1</sub> also a final state.</p>
<p style="padding-left:8%;">So the FA becomes &minus;</p>
<img src="/automata_theory/images/final_ndfa_without_null_moves.jpg" alt="Final NDFA Without Null Moves" />
<h1>Pumping Lemma For Regular Grammars</h1>
<h3>Theorem</h3>
<p>Let L be a regular language. Then there exists a constant <b>‘c’</b> such that for every string <b>w</b> in <b>L</b> &minus;</p>
<p style="padding-left:8%;"><b>|w| &ge; c</b></p>
<p>We can break <b>w</b> into three strings, <b>w = xyz</b>, such that &minus;</p>
<ul class="list">
<li>|y| &gt; 0</li>
<li>|xy| &le; c</li>
<li>For all k &ge; 0, the string xy<sup>k</sup>z is also in L.</li>
</ul>
<h2>Applications of Pumping Lemma</h2>
<p>Pumping Lemma is to be applied to show that certain languages are not regular. It should never be used to show a language is regular.</p>
<ul class="list">
<li><p>If <b>L</b> is regular, it satisfies Pumping Lemma.</p></li>
<li><p>If <b>L</b> does not satisfy Pumping Lemma, it is non-regular.</p></li>
</ul>
<h2>Method to prove that a language L is not regular</h2>
<ul class="list">
<li><p>At first, we have to assume that <b>L</b> is regular.</p></li>
<li><p>So, the pumping lemma should hold for <b>L</b>.</p></li>
<li><p>Use the pumping lemma to obtain a contradiction &minus;</p>
<ul class="list">
<li><p>Select <b>w</b> such that <b>|w| &ge; c</b></p></li>
<li><p>Select <b>y</b> such that <b>|y| &ge; 1</b></p></li>
<li><p>Select <b>x</b> such that <b>|xy| &le; c</b></p></li>
<li><p>Assign the remaining string to <b>z.</b></p></li>
<li><p>Select <b>k</b> such that the resulting string is not in <b>L.</b></p></li>
</ul>
</li>
</ul>
<p><b>Hence L is not regular.</b></p>
<p><b>Problem</b></p>
<p>Prove that <b>L = {a<sup>i</sup>b<sup>i</sup> | i &ge; 0}</b> is not regular.</p>
<p><b><i>Solution</i></b> &minus;</p>
<ul class="list">
<li><p>At first, we assume that <b>L</b> is regular and n is the number of states.</p></li>
<li><p>Let w = <i>a<sup>n</sup>b<sup>n</sup></i>. Thus |w| = 2n &ge; n.</p></li>
<li><p>By pumping lemma, let w = xyz, where |xy| &le; n.</p></li>
<li><p>Let x = a<sup>p</sup>, y = a<sup>q</sup>, and z = a<sup>r</sup>b<sup>n</sup>, where p + q + r = n, p &ne; 0, q &ne; 0, r &ne; 0. Thus |y| &ne; 0.</p></li>
<li><p>Let k = 2. Then xy<sup>2</sup>z = a<sup>p</sup>a<sup>2q</sup>a<sup>r</sup>b<sup>n</sup>.</p></li>
<li><p>Number of as = (p + 2q + r) = (p + q + r) + q = n + q</p></li>
<li><p>Hence, xy<sup>2</sup>z = a<sup>n+q</sup> b<sup>n</sup>. Since q &ne; 0, xy<sup>2</sup>z is not of the form a<sup>n</sup>b<sup>n</sup>.</p></li>
<li><p>Thus, xy<sup>2</sup>z is not in L. Hence L is not regular.</p></li>
</ul>
<h1>DFA Complement</h1>
<p>If (Q, &sum;, &delta;, q<sub>0</sub>, F) be a DFA that accepts a language L, then the complement of the DFA can be obtained by swapping its accepting states with its non-accepting states and vice versa.</p>
<p>We will take an example and elaborate this below &minus;</p>
<img src="/automata_theory/images/dfa_accepting_language_l.jpg" alt="DFA Accepting Language L" />
<p>This DFA accepts the language</p>
<p style="padding-left:8%;">L = {a, aa, aaa , ............. }</p>
<p>over the alphabet</p>
<p style="padding-left:8%;">&sum; = {a, b}</p>
<p>So, RE = a<sup>+</sup>.</p>
<p>Now we will swap its accepting states with its non-accepting states and vice versa and will get the following &minus;</p>
<img src="/automata_theory/images/dfa_accepting_complement_language_l.jpg" alt="DFA Accepting Complement Language L" />
<p>This DFA accepts the language</p>
<p style="padding-left:8%;">Ľ = {&epsilon;, b, ab ,bb,ba, ............... }</p>
<p>over the alphabet</p>
<p style="padding-left:8%;">&sum; = {a, b}</p>
<p><b>Note</b> &minus; If we want to complement an NFA, we have to first convert it to DFA and then have to swap states as in the previous method.</p>
<h1>Context-Free Grammar Introduction</h1>
<p><b><i>Definition</i></b> &minus; A context-free grammar (CFG) consisting of a finite set of grammar rules is a quadruple <b>(N, T, P, S)</b> where</p>
<ul class="list">
<li><p><b>N</b> is a set of non-terminal symbols.</p></li>
<li><p><b>T</b> is a set of terminals where <b>N &cap; T = NULL.</b></p></li>
<li><p><b>P</b> is a set of rules, <b>P: N &rarr; (N &cup; T)*</b>, i.e., the left-hand side of the production rule <b>P</b> does have any right context or left context.</p></li>
<li><p><b>S</b> is the start symbol.</p></li>
</ul>
<p><b>Example</b></p>
<ul class="list">
<li>The grammar ({A}, {a, b, c}, P, A), P : A &rarr; aA, A &rarr; abc.</li>
<li>The grammar ({S, a, b}, {a, b}, P, S), P: S &rarr; aSa, S &rarr; bSb, S &rarr; &epsilon;</li>
<li>The grammar ({S, F}, {0, 1}, P, S), P: S &rarr; 00S | 11F, F &rarr; 00F | &epsilon;</li>
</ul>
<h2>Generation of Derivation Tree</h2>
<p>A derivation tree or parse tree is an ordered rooted tree that graphically represents the semantic information a string derived from a context-free grammar.</p>
<h3>Representation Technique</h3>
<ul class="list">
<li><p><b>Root vertex</b> &minus; Must be labeled by the start symbol.</p></li>
<li><p><b>Vertex</b> &minus; Labeled by a non-terminal symbol.</p></li>
<li><p><b>Leaves</b> &minus; Labeled by a terminal symbol or &epsilon;.</p></li>
</ul>
<p>If S &rarr; x<sub>1</sub>x<sub>2</sub> …… x<sub>n</sub> is a production rule in a CFG, then the parse tree / derivation tree will be as follows &minus;</p>
<img src="/automata_theory/images/derivation_tree.jpg" alt="Derivation Tree" />
<p>There are two different approaches to draw a derivation tree &minus;</p>
<p><b>Top-down Approach &minus;</b></p>
<ul class="list">
<li><p>Starts with the starting symbol <b>S</b></p></li>
<li><p>Goes down to tree leaves using productions</p></li>
</ul>
<p><b>Bottom-up Approach &minus;</b></p>
<ul class="list">
<li><p>Starts from tree leaves</p></li>
<li><p>Proceeds upward to the root which is the starting symbol <b>S</b></p></li>
</ul>
<h3>Derivation or Yield of a Tree</h3>
<p>The derivation or the yield of a parse tree is the final string obtained by concatenating the labels of the leaves of the tree from left to right, ignoring the Nulls. However, if all the leaves are Null, derivation is Null.</p>
<p><b>Example</b></p>
<p>Let a CFG {N,T,P,S} be</p>
<p style="padding-left:10%;">N = {S}, T = {a, b}, Starting symbol = S, P = S &rarr; SS | aSb | &epsilon;</p>
<p>One derivation from the above CFG is “abaabb”</p>
<p style="padding-left:10%;">S &rarr; SS &rarr; aSbS &rarr; abS &rarr; abaSb &rarr; abaaSbb &rarr; abaabb</p>
<img src="/automata_theory/images/yield_of_a_tree.jpg" alt="Yield of a Tree" />
<h3>Sentential Form and Partial Derivation Tree</h3>
<p>A partial derivation tree is a sub-tree of a derivation tree/parse tree such that either all of its children are in the sub-tree or none of them are in the sub-tree.</p>
<p><b>Example</b></p>
<p>If in any CFG the productions are &minus;</p>
<p style="padding-left:10%;">S &rarr; AB,  A &rarr; aaA | &epsilon;,  B &rarr; Bb| &epsilon;</p>
<p>the partial derivation tree can be the following &minus;</p>
<img src="/automata_theory/images/sentential_form_and_partial_derivation_tree.jpg" alt="Sentential Form and Partial Derivation Tree" />
<p>If a partial derivation tree contains the root S, it is called a <b>sentential form</b>. The above sub-tree is also in sentential form.</p>
<h3>Leftmost and Rightmost Derivation of a String</h3>
<ul class="list">
<li><p><b>Leftmost derivation</b> &minus; A leftmost derivation is obtained by applying production to the leftmost variable in each step.</p></li>
<li><p><b>Rightmost derivation</b> &minus; A rightmost derivation is obtained by applying production to the rightmost variable in each step.</p></li>
</ul>
<p><b>Example</b></p>
<p>Let any set of production rules in a CFG be</p>
<p style="padding-left:10%;">X &rarr; X+X | X*X |X| a</p>
<p>over an alphabet {a}.</p>
<p>The leftmost derivation for the string <b>"a+a*a"</b> may be &minus;</p>
<p style="padding-left:10%;">X &rarr; X+X &rarr; a+X &rarr; a + X*X &rarr; a+a*X &rarr; a+a*a</p>
<p>The stepwise derivation of the above string is shown as below &minus;</p>
<img src="/automata_theory/images/leftmost.jpg" alt="Leftmost" />
<p>The rightmost derivation for the above string <b>"a+a*a"</b> may be &minus;</p>
<p style="padding-left:10%;">X &rarr; X*X &rarr; X*a &rarr; X+X*a &rarr; X+a*a &rarr; a+a*a</p>
<p>The stepwise derivation of the above string is shown as below &minus;</p>
<img src="/automata_theory/images/rightmost.jpg" alt="Rightmost" />
<h2>Left and Right Recursive Grammars</h2>
<p>In a context-free grammar <b>G</b>, if there is a production in the form <b>X &rarr; Xa</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>left recursive production</b>. The grammar having a left recursive production is called a <b>left recursive grammar</b>.</p>
<p>And if in a context-free grammar <b>G</b>, if there is a production is in the form <b>X &rarr; aX</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>right recursive production</b>. The grammar having a right recursive production is called a <b>right recursive grammar</b>.</p>
<h1>Ambiguity in Context-Free Grammars</h1>
<p>If a context free grammar <b>G</b> has more than one derivation tree for some string <b>w &isin; L(G)</b>, it is called an <b>ambiguous grammar</b>. There exist multiple right-most or left-most derivations for some string generated from that grammar.</p>
<h2>Problem</h2>
<p>Check whether the grammar G with production rules &minus;</p>
<p style="padding-left:10%;">X &rarr; X+X | X*X |X| a</p>
<p>is ambiguous or not.</p>
<h2>Solution</h2>
<p>Let’s find out the derivation tree for the string "a+a*a". It has two leftmost derivations.</p>
<p><b>Derivation 1</b> &minus; <span style="padding-left:3%;">X &rarr; X+X &rarr; a +X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>
<p><b>Parse tree 1</b> &minus;</p>
<img src="/automata_theory/images/parse_tree1.jpg" alt="Parse Tree 1" />
<p><b>Derivation 2</b> &minus; <span style="padding-left:3%;">X &rarr; X*X &rarr; X+X*X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>
<p><b>Parse tree 2</b> &minus;</p>
<img src="/automata_theory/images/parse_tree2.jpg" alt="Parse Tree 2" />
<p>Since there are two parse trees for a single string "a+a*a", the grammar <b>G</b> is ambiguous.</p>
<h1>CFL Closure Property</h1>
<p>Context-free languages are <b>closed</b> under &minus;</p>
<ul class="list">
<li>Union</li>
<li>Concatenation</li>
<li>Kleene Star operation</li>
</ul>
<h2>Union</h2>
<p>Let L<sub>1</sub> and L<sub>2</sub> be two context free languages. Then L<sub>1</sub> &cup; L<sub>2</sub> is also context free.</p>
<h3>Example</h3>
<p>Let L<sub>1</sub> = { a<sup>n</sup>b<sup>n</sup> , n &gt; 0}. Corresponding grammar G<sub>1</sub> will have P: S1 &rarr; aAb|ab</p>
<p>Let L<sub>2</sub> = { c<sup>m</sup>d<sup>m</sup> , m &ge; 0}. Corresponding grammar G<sub>2</sub> will have P: S2 &rarr; cBb| &epsilon;</p>
<p>Union of L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub> &cup; L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup> } &cup; { c<sup>m</sup>d<sup>m</sup> }</p>
<p>The corresponding grammar G will have the additional production S &rarr; S1 | S2</p>
<h2>Concatenation</h2>
<p>If L<sub>1</sub> and L<sub>2</sub> are context free languages, then L<sub>1</sub>L<sub>2</sub> is also context free.</p>
<h3>Example</h3>
<p>Union of the languages L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub>L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup> }</p>
<p>The corresponding grammar G will have the additional production S &rarr; S1 S2</p>
<h2>Kleene Star</h2>
<p>If L is a context free language, then L* is also context free.</p>
<h3>Example</h3>
<p>Let L = { a<sup>n</sup>b<sup>n</sup> , n &ge; 0}. Corresponding grammar G will have P: S &rarr; aAb| &epsilon;</p>
<p>Kleene Star L<sub>1</sub> = { a<sup>n</sup>b<sup>n </sup>}*</p>
<p>The corresponding grammar G<sub>1</sub> will have additional productions S1 &rarr; SS<sub>1</sub> | &epsilon;</p>
<p>Context-free languages are <b>not closed</b> under &minus;</p>
<ul class="list">
<li><p><b>Intersection</b> &minus; If L1 and L2 are context free languages, then L1 &cap; L2 is not necessarily context free.</p></li>
<li><p><b>Intersection with Regular Language</b> &minus; If L1 is a regular language and L2 is a context free language, then L1 &cap; L2 is a context free language.</p></li>
<li><p><b>Complement</b> &minus; If L1 is a context free language, then L1’ may not be context free.</p></li>
</ul>
<h1>CFG Simplification</h1>
<p>In a CFG, it may happen that all the production rules and symbols are not needed for the derivation of strings. Besides, there may be some null productions and unit productions. Elimination of these productions and symbols is called <b>simplification of CFGs</b>. Simplification essentially comprises of the following steps &minus;</p>
<ul class="list">
<li>Reduction of CFG</li>
<li>Removal of Unit Productions</li>
<li>Removal of Null Productions</li>
</ul>
<h2>Reduction of CFG</h2>
<p>CFGs are reduced in two phases &minus;</p>
<p><b>Phase 1</b> &minus; Derivation of an equivalent grammar, <b>G’</b>, from the CFG, <b>G</b>, such that each variable derives some terminal string.</p>
<p style="padding-left:8%"><b>Derivation Procedure</b> &minus;</p>
<p style="padding-left:8%">Step 1 &minus; Include all symbols, <b>W<sub>1</sub></b>, that derive some terminal and initialize <b>i=1</b>.</p>
<p style="padding-left:8%">Step 2 &minus; Include all symbols, <b>W<sub>i+1</sub></b>, that derive <b>W<sub>i</sub></b>.</p>
<p style="padding-left:8%">Step 3 &minus; Increment <b>i</b> and repeat Step 2, until <b>W<sub>i+1</sub> = W<sub>i</sub></b>.</p>
<p style="padding-left:8%">Step 4 &minus; Include all production rules that have <b>W<sub>i</sub></b> in it.</p>
<p><b>Phase 2</b> &minus; Derivation of an equivalent grammar, <b>G”</b>, from the CFG, <b>G’</b>, such that each symbol appears in a sentential form.</p>
<p style="padding-left:8%"><b>Derivation Procedure</b> &minus;</p>
<p style="padding-left:8%">Step 1 &minus; Include the start symbol in <b>Y<sub>1</sub></b> and initialize <b>i = 1</b>.</p>
<p style="padding-left:8%">Step 2 &minus; Include all symbols, <b>Y<sub>i+1</sub></b>, that can be derived from <b>Y<sub>i</sub></b> and include all production rules that have been applied.</p>
<p style="padding-left:8%">Step 3 &minus; Increment <b>i</b> and repeat Step 2, until <b>Y<sub>i+1</sub> = Y<sub>i</sub></b>.</p>
<h3>Problem</h3>
<p>Find a reduced grammar equivalent to the grammar G, having production rules, P: S &rarr; AC | B, A &rarr; a, C &rarr; c | BC, E &rarr; aA | e</p>
<h3>Solution</h3>
<p><b>Phase 1</b> &minus;</p>
<p style="padding-left:10%;">T = { a, c, e }</p>
<p style="padding-left:10%;">W<sub>1</sub> = { A, C, E } from rules A &rarr; a, C &rarr; c and E &rarr; aA</p>
<p style="padding-left:10%;">W<sub>2</sub> = { A, C, E } U { S } from rule S &rarr; AC</p>
<p style="padding-left:10%;">W<sub>3</sub> = { A, C, E, S } U &empty;</p>
<p style="padding-left:10%;">Since W<sub>2</sub> = W<sub>3</sub>, we can derive G’ as &minus;</p>
<p style="padding-left:12%;">G’ = { { A, C, E, S }, { a, c, e }, P, {S}}</p>
<p style="padding-left:10%;">where P: S &rarr; AC, A &rarr; a, C &rarr; c , E &rarr; aA | e</p>
<p><b>Phase 2</b> &minus;</p>
<p style="padding-left:10%;">Y<sub>1</sub> = { S }</p>
<p style="padding-left:10%;">Y<sub>2</sub> = { S, A, C } from rule S &rarr; AC</p>
<p style="padding-left:10%;">Y<sub>3</sub> = { S, A, C, a, c } from rules A &rarr; a and C &rarr; c</p>
<p style="padding-left:10%;">Y<sub>4</sub> = { S, A, C, a, c }</p>
<p style="padding-left:10%;">Since Y<sub>3</sub> = Y<sub>4</sub>, we can derive G” as &minus;</p>
<p style="padding-left:13%;">G” = { { A, C, S }, { a, c }, P, {S}}</p>
<p style="padding-left:10%;">where P: S &rarr; AC, A &rarr; a, C &rarr; c</p>
<h2>Removal of Unit Productions</h2>
<p>Any production rule in the form A &rarr; B where A, B &isin; Non-terminal is called <b>unit production.</b>.</p>
<h3>Removal Procedure &minus;</h3>
<p><b>Step 1</b> &minus; To remove <b>A &rarr; B</b>, add production <b>A &rarr; x</b> to the grammar rule whenever <b>B &rarr; x</b> occurs in the grammar. [x &isin; Terminal, x can be Null]</p>
<p><b>Step 2</b> &minus; Delete <b>A &rarr; B</b> from the grammar.</p>
<p><b>Step 3</b> &minus; Repeat from step 1 until all unit productions are removed.</p>
<p><b>Problem</b></p>
<p>Remove unit production from the following &minus;</p>
<p style="padding-left:10%;">S &rarr; XY, X &rarr; a, Y &rarr; Z | b, Z &rarr; M, M &rarr; N, N &rarr; a</p>
<p><b>Solution</b> &minus;</p>
<p>There are 3 unit productions in the grammar &minus;</p>
<p style="padding-left:10%;">Y &rarr; Z, Z &rarr; M, and M &rarr; N</p>
<p><b>At first, we will remove M &rarr; N.</b></p>
<p>As N &rarr; a, we add M &rarr; a, and M &rarr; N is removed.</p>
<p>The production set becomes</p>
<p style="padding-left:10%;">S &rarr; XY, X &rarr; a, Y &rarr; Z | b, Z &rarr; M, M &rarr; a, N &rarr; a</p>
<p><b>Now we will remove Z &rarr; M.</b></p>
<p>As M &rarr; a, we add Z&rarr; a, and Z &rarr; M is removed.</p>
<p>The production set becomes</p>
<p style="padding-left:10%;">S &rarr; XY, X &rarr; a, Y &rarr; Z | b, Z &rarr; a, M &rarr; a, N &rarr; a</p>
<p><b>Now we will remove Y &rarr; Z.</b></p>
<p>As Z &rarr; a, we add Y&rarr; a, and Y &rarr; Z is removed.</p>
<p>The production set becomes</p>
<p style="padding-left:12%;">S &rarr; XY, X &rarr; a, Y &rarr; a | b, Z &rarr; a, M &rarr; a, N &rarr; a</p>
<p>Now Z, M, and N are unreachable, hence we can remove those.</p>
<p>The final CFG is unit production free &minus;</p>
<p style="padding-left:12%;">S &rarr; XY, X &rarr; a, Y &rarr; a | b</p>
<h2>Removal of Null Productions</h2>
<p>In a CFG, a non-terminal symbol <b>‘A’</b> is a nullable variable if there is a production <b>A &rarr; &epsilon;</b> or there is a derivation that starts at <b>A</b> and finally ends up with</p>
<p style="padding-left:10%">&epsilon;: A &rarr; .......… &rarr; &epsilon;</p>
<h3>Removal Procedure</h3>
<p><b>Step 1</b> &minus; Find out nullable non-terminal variables which derive &epsilon;.</p>
<p><b>Step 2</b> &minus; For each production <b>A &rarr; a</b>, construct all productions <b>A &rarr; x</b> where <b>x</b> is obtained from <b>‘a’</b> by removing one or multiple non-terminals from Step 1.</p>
<p><b>Step 3</b> &minus; Combine the original productions with the result of step 2 and remove <b>&epsilon; - productions</b>.</p>
<p><b>Problem</b></p>
<p>Remove null production from the following &minus;</p>
<p>S &rarr; ASA | aB | b, A &rarr; B, B &rarr; b | &isin;</p>
<p><b>Solution</b> &minus;</p>
<p>There are two nullable variables &minus; <b>A</b> and <b>B</b></p>
<p><b>At first, we will remove B &rarr; &epsilon;.</b></p>
<p>After removing <b>B &rarr; &epsilon;</b>, the production set becomes &minus;</p>
<p style="padding-left:10%;">S&rarr;ASA | aB | b | a, A &epsilon; B| b | &epsilon, B &rarr; b</p>
<p><b>Now we will remove A &rarr; &epsilon;.</b></p>
<p>After removing <b>A &rarr; &epsilon;</b>, the production set becomes &minus;</p>
<p style="padding-left:10%;">S&rarr;ASA | aB | b | a | SA | AS | S, A &rarr; B| b, B &rarr; b</p>
<p>This is the final production set without null transition.</p>
<h1>Chomsky Normal Form</h1>
<p>A CFG is in Chomsky Normal Form if the Productions are in the following forms &minus;</p>
<ul class="list">
<li>A &rarr; a</li>
<li>A &rarr; BC</li>
<li>S &rarr; &epsilon;</li>
</ul>
<p>where A, B, and C are non-terminals and <b>a</b> is terminal.</p>
<h2>Algorithm to Convert into Chomsky Normal Form &minus;</h2>
<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’&rarr; S</b>.</p>
<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>
<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>
<p><b>Step 4</b> &minus; Replace each production <b>A &rarr; B<sub>1</sub>…B<sub>n</sub></b> where <b>n &gt; 2</b> with <b>A &rarr; B<sub>1</sub>C</b> where <b>C &rarr; B<sub>2</sub> …B<sub>n</sub></b>. Repeat this step for all productions having two or more symbols in the right side.</p>
<p><b>Step 5</b> &minus; If the right side of any production is in the form <b>A &rarr; aB</b> where a is a terminal and <b>A, B</b> are non-terminal, then the production is replaced by <b>A &rarr; XB</b> and <b>X &rarr; a</b>. Repeat this step for every production which is in the form <b>A &rarr; aB</b>.</p>
<h3>Problem</h3>
<p>Convert the following CFG into CNF</p>
<p style="padding-left:10%;">S &rarr; ASA | aB,  A &rarr; B | S, B &rarr; b | &epsilon;</p>
<h3>Solution</h3>
<p><b>(1)</b> Since <b>S</b> appears in R.H.S, we add a new state <b>S<sub>0</sub></b> and <b>S<sub>0</sub>&rarr;S</b> is added to the production set and it becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB, A &rarr; B | S, B &rarr; b | &isin;</p>
<p><b>(2)</b> Now we will remove the null productions &minus;</p>
<p style="padding-left:10%;">B &rarr; &isin; and A &rarr; &isin;</p>
<p>After removing B &rarr; &epsilon;, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB | a, A &rarr; B | S | &isin;, B &rarr; b</p>
<p>After removing A &rarr; &isin;, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB | a | AS | SA | S, A &rarr; B | S, B &rarr; b</p>
<p><b>(3)</b> Now we will remove the unit productions.</p>
<p>After removing S &rarr; S, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB | a | AS | SA, A &rarr; B | S, B &rarr; b</p>
<p>After removing S<sub>0</sub>&rarr; S, the production set becomes &minus;</p> 
<p style="padding-left:10%;">S<sub>0</sub>&rarr; ASA | aB | a | AS | SA, S&rarr; ASA | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; B | S,  B &rarr; b</p>
<p>After removing A&rarr; B, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub> &rarr; ASA | aB | a | AS | SA, S&rarr; ASA | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; S | b</p>
<p style="padding-left:10%;">B &rarr; b</p>
<p>After removing A&rarr; S, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub> &rarr; ASA | aB | a | AS | SA,  S&rarr; ASA | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; b |ASA | aB | a | AS | SA, B &rarr; b</p>
<p><b>(4)</b> Now we will find out more than two variables in the R.H.S</p>
<p>Here, S<sub>0</sub>&rarr; ASA, S &rarr; ASA, A&rarr; ASA violates two Non-terminals in R.H.S.</p>
<p>Hence we will apply step 4 and step 5 to get the following final production set which is in CNF &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr; AX | aB | a | AS | SA</p>
<p style="padding-left:10%;">S&rarr; AX | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; b |AX | aB | a | AS | SA</p>
<p style="padding-left:10%;">B &rarr; b</p>
<p style="padding-left:10%;">X &rarr; SA</p>
<p><b>(5)</b> We have to change the productions S<sub>0</sub>&rarr; aB, S&rarr; aB, A&rarr; aB</p>
<p>And the final production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr; AX | YB | a | AS | SA</p>
<p style="padding-left:10%;">S&rarr; AX | YB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; b A &rarr; b |AX | YB | a | AS | SA</p>
<p style="padding-left:10%;">B &rarr; b</p>
<p style="padding-left:10%;">X &rarr; SA</p>
<p style="padding-left:10%;">Y &rarr; a</p>
<h1>Greibach Normal Form</h1>
<p>A CFG is in Greibach Normal Form if the Productions are in the following forms &minus;</p>
<p style="padding-left:7%;">A &rarr; b</p>
<p style="padding-left:7%;">A &rarr; bD<sub>1</sub>…D<sub>n</sub></p>
<p style="padding-left:7%;">S &rarr; &epsilon;</p>
<p>where A, D<sub>1</sub>,....,D<sub>n</sub> are non-terminals and b is a terminal.</p>
<h2>Algorithm to Convert a CFG into Greibach Normal Form</h2>
<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’ &rarr; S</b>.</p>
<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>
<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>
<p><b>Step 4</b> &minus; Remove all direct and indirect left-recursion.</p>
<p><b>Step 5</b> &minus; Do proper substitutions of productions to convert it into the proper form of GNF.</p>
<h3>Problem</h3>
<p>Convert the following CFG into CNF</p>
<p style="padding-left:7%;">S &rarr; XY | Xn | p</p>
<p style="padding-left:7%;">X &rarr; mX | m</p>
<p style="padding-left:7%;">Y &rarr; Xn | o</p>
<h3>Solution</h3>
<p>Here, <b>S</b> does not appear on the right side of any production and there are no unit or null productions in the production rule set. So, we can skip Step 1 to Step 3.</p>
<p><b>Step 4</b></p>
<p>Now after replacing</p>
<p style="padding-left:7%;">X in S &rarr; XY | Xo | p</p>
<p>with</p>
<p style="padding-left:7%;">mX | m</p>
<p>we obtain</p>
<p style="padding-left:7%;">S &rarr; mXY | mY | mXo | mo | p.</p>
<p>And after replacing</p>
<p style="padding-left:7%;">X in Y &rarr; X<sub>n</sub> | o</p>
<p>with the right side of</p>
<p style="padding-left:7%;">X &rarr; mX | m</p>
<p>we obtain</p>
<p style="padding-left:7%;">Y &rarr; mXn | mn | o.</p>
<p>Two new productions O &rarr; o and P &rarr; p are added to the production set and then we came to the final GNF as the following &minus;</p>
<p style="padding-left:7%;">S &rarr; mXY | mY | mXC | mC | p</p>
<p style="padding-left:7%;">X &rarr; mX | m</p>
<p style="padding-left:7%;">Y &rarr; mXD | mD | o</p>
<p style="padding-left:7%;">O &rarr; o</p>
<p style="padding-left:7%;">P &rarr; p</p>
<h1>Pumping Lemma for CFG</h1>
<h2>Lemma</h2>
<p>If <b>L</b> is a context-free language, there is a pumping length <b>p</b> such that any string <b>w &isin; L</b> of length <b>&ge; p</b> can be written as <b>w = uvxyz</b>, where <b>vy &ne; &epsilon;</b>, <b>|vxy| &le; p</b>, and for all <b>i &ge; 0, uv<sup>i</sup>xy<sup>i</sup>z &isin; L</b>.</p>
<h2>Applications of Pumping Lemma</h2>
<p>Pumping lemma is used to check whether a grammar is context free or not. Let us take an example and show how it is checked.</p>
<h3>Problem</h3>
<p>Find out whether the language <b>L = {x<sup>n</sup>y<sup>n</sup>z<sup>n</sup> | n &ge; 1}</b> is context free or not.</p>
<h3>Solution</h3>
<p>Let <b>L</b> is context free. Then, <b>L</b> must satisfy pumping lemma.</p>
<p>At first, choose a number <b>n</b> of the pumping lemma. Then, take z as 0<sup>n</sup>1<sup>n</sup>2<sup>n</sup>.</p>
<p>Break <b>z</b> into <b>uvwxy,</b> where</p>
<p style="padding-left:10%;"><b>|vwx| &le; n and vx &ne; &epsilon;.</b></p>
<p>Hence <b>vwx</b> cannot involve both 0s and 2s, since the last 0 and the first 2 are at least (n+1) positions apart. There are two cases &minus;</p>
<p><b>Case 1</b> &minus; <b>vwx</b> has no 2s. Then <b>vx</b> has only 0s and 1s. Then <b>uwy</b>, which would have to be in <b>L</b>, has <b>n</b> 2s, but fewer than <b>n</b> 0s or 1s.</p>
<p><b>Case 2</b> &minus; <b>vwx</b> has no 0s.</p>
<p>Here contradiction occurs.</p>
<p>Hence, <b>L</b> is not a context-free language.</p>
<h1>Pushdown Automata Introduction</h1>
<h2>Basic Structure of PDA</h2>
<p>A pushdown automaton is a way to implement a context-free grammar in a similar way we design DFA for a regular grammar. A DFA can remember a finite amount of information, but a PDA can remember an infinite amount of information.</p>
<p>Basically a pushdown automaton is &minus;</p>
<p style="padding-left:7%;"><b>"Finite state machine" + "a stack"</b></p>
<p>A pushdown automaton has three components &minus;</p>
<ul class="list">
<li>an input tape,</li>
<li>a control unit, and</li>
<li>a stack with infinite size.</li>
</ul>
<p>The stack head scans the top symbol of the stack.</p>
<p>A stack does two operations &minus;</p>
<ul class="list">
<li><p><b>Push</b> &minus; a new symbol is added at the top.</p></li>
<li><p><b>Pop</b> &minus; the top symbol is read and removed.</p></li>
</ul>
<p>A PDA may or may not read an input symbol, but it has to read the top of the stack in every transition.</p>
<img src="/automata_theory/images/pda.jpg" alt="PDA" />
<p>A PDA can be formally described as a 7-tuple (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) &minus;</p>
<ul class="list">
<li><p><b>Q</b> is the finite number of states</p></li>
<li><p><b>&sum;</b> is input alphabet</p></li>
<li><p><b>S</b> is stack symbols</p></li>
<li><p><b>δ</b> is the transition function: Q &times; (&sum; &cup; {&epsilon;}) &times; S &times; Q &times; S*</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state (q<sub>0</sub> &isin; Q)</p></li>
<li><p><b>I</b> is the initial stack top symbol (I &isin; S)</p></li>
<li><p><b>F</b> is a set of accepting states (F &isin; Q)</p></li>
</ul>
<p>The following diagram shows a transition in a PDA from a state q<sub>1</sub> to state q<sub>2</sub>, labeled as a,b &rarr; c &minus;</p>
<img src="/automata_theory/images/transition_in_a_pda.jpg" alt="Transition in a PDA" />
<p>This means at state <b>q<sub>1</sub></b>, if we encounter an input string <b>‘a’</b> and top symbol of the stack is <b>‘b’</b>, then we pop <b>‘b’</b>, push <b>‘c’</b> on top of the stack and move to state <b>q<sub>2</sub></b>.</p>
<h2>Terminologies Related to PDA</h2>
<h3>Instantaneous Description</h3>
<p>The instantaneous description (ID) of a PDA is represented by a triplet (q, w, s) where</p>
<ul class="list">
<li><p><b>q</b> is the state</p></li>
<li><p><b>w</b> is unconsumed input</p></li>
<li><p><b>s</b> is the stack contents</p></li>
</ul>
<h3>Turnstile Notation</h3>
<p>The "turnstile" notation is used for connecting pairs of ID's that represent one or many moves of a PDA. The process of transition is denoted by the turnstile symbol "&#8866;".</p>
<p>Consider a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F). A transition can be mathematically represented by the following turnstile notation &minus;</p>
<pre class="result notranslate">
(p, aw, T&beta;) &#8866; (q, w, &alpha;b)
</pre>
<p>This implies that while taking a transition from state <b>p</b> to state <b>q</b>, the input symbol <b>‘a’</b> is consumed, and the top of the stack <b>‘T’</b> is replaced by a new string <b>‘&alpha;’</b>.</p>
<p><b>Note</b> &minus; If we want zero or more moves of a PDA, we have to use the symbol (&#8866;*) for it.</p>
<h1>Pushdown Automata Acceptance</h1>
<p>There are two different ways to define PDA acceptability.</p>
<h2>Final State Acceptability</h2>
<p>In final state acceptability, a PDA accepts a string when, after reading the entire string, the PDA is in a final state. From the starting state, we can make moves that end up in a final state with any stack values. The stack values are irrelevant as long as we end up in a final state.</p>
<p>For a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), the language accepted by the set of final states F is &minus;</p>
<p style="padding-left:7%;">L(PDA) = {w | (q<sub>0</sub>, w, I) &#8866;* (q, &epsilon;, x), q &isin; F}</p>
<p>for any input stack string <b>x</b>.</p>
<h2>Empty Stack Acceptability</h2>
<p>Here a PDA accepts a string when, after reading the entire string, the PDA has emptied its stack.</p>
<p>For a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), the language accepted by the empty stack is &minus;</p>
<p style="padding-left:7%;">L(PDA) = {w | (q<sub>0</sub>, w, I) &#8866;* (q, &epsilon;, &epsilon;), q &isin; Q}</p>
<h3>Example</h3>
<p>Construct a PDA that accepts <b>L = {0<sup>n</sup> 1<sup>n</sup> | n &ge; 0}</b></p>
<h3>Solution</h3>
<img src="/automata_theory/images/pda_for_l.jpg" alt="PDA for L" />
<p>This language accepts L = {&epsilon;, 01, 0011, 000111, ............................. }</p>
<p>Here, in this example, the number of <b>‘a’</b> and <b>‘b’</b> have to be same.</p>
<ul class="list">
<li><p>Initially we put a special symbol <b>‘$’</b> into the empty stack.</p></li>
<li><p>Then at state <b>q<sub>2</sub></b>, if we encounter input 0 and top is Null, we push 0 into stack. This may iterate. And if we encounter input 1 and top is 0, we pop this 0.</p></li>
<li><p>Then at state <b>q<sub>3</sub></b>, if we encounter input 1 and top is 0, we pop this 0. This may also iterate. And if we encounter input 1 and top is 0, we pop the top element.</p></li>
<li><p>If the special symbol ‘$’ is encountered at top of the stack, it is popped out and it finally goes to the accepting state q<sub>4</sub>.</p></li>
</ul>
<h3>Example</h3>
<p>Construct a PDA that accepts L = { ww<sup>R</sup> | w = (a+b)* }</p>
<p><b>Solution</b></p>
<img src="/automata_theory/images/pda_for_l1.jpg" alt="PDA for L1" />
<p>Initially we put a special symbol ‘$’ into the empty stack. At state <b>q<sub>2</sub></b>, the <b>w</b> is being read. In state <b>q<sub>3</sub></b>, each 0 or 1 is popped when it matches the input. If any other input is given, the PDA will go to a dead state. When we reach that special symbol ‘$’, we go to the accepting state <b>q<sub>4</sub></b>.</p>
<h1>PDA &amp; Context-Free Grammar</h1>
<p>If a grammar <b>G</b> is context-free, we can build an equivalent nondeterministic PDA which accepts the language that is produced by the context-free grammar <b>G</b>. A parser can be built for the grammar <b>G</b>.</p>
<p>Also, if <b>P</b> is a pushdown automaton, an equivalent context-free grammar G can be constructed where</p>
<p style="padding-left:7%;"><b>L(G) = L(P)</b></p>
<p>In the next two topics, we will discuss how to convert from PDA to CFG and vice versa.</p>
<h2>Algorithm to find PDA corresponding to a given CFG</h2>
<p><b>Input</b> &minus; A CFG, G = (V, T, P, S)</p>
<p><b>Output</b> &minus; Equivalent PDA, P = (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F)</p>
<p><b>Step 1</b> &minus; Convert the productions of the CFG into GNF.</p>
<p><b>Step 2</b> &minus; The PDA will have only one state {q}.</p>
<p><b>Step 3</b> &minus; The start symbol of CFG will be the start symbol in the PDA.</p>
<p><b>Step 4</b> &minus; All non-terminals of the CFG will be the stack symbols of the PDA and all the terminals of the CFG will be the input symbols of the PDA.</p>
<p><b>Step 5</b> &minus; For each production in the form <b>A &rarr; aX</b> where a is terminal and <b>A, X</b> are combination of terminal and non-terminals, make a transition <b>&delta; (q, a, A)</b>.</p>
<h3>Problem</h3>
<p>Construct a PDA from the following CFG.</p>
<p style="padding-left:10%;"><b>G = ({S, X}, {a, b}, P, S)</b></p>
<p>where the productions are &minus;</p>
<p style="padding-left:10%;"><b>S &rarr; XS | &epsilon; , A &rarr; aXb | Ab | ab</b></p>
<h3>Solution</h3>
<p>Let the equivalent PDA,</p>
<p style="padding-left:10%;">P = ({q}, {a, b}, {a, b, X, S}, &delta;, q, S)</p>
<p>where &delta; &minus;</p>
<p style="padding-left:10%;">&delta;(q, &epsilon; , S) = {(q, XS), (q, &epsilon; )}</p>
<p style="padding-left:10%;">&delta;(q, &epsilon; , X) = {(q, aXb), (q, Xb), (q, ab)}</p>
<p style="padding-left:10%;">&delta;(q, a, a) = {(q, &epsilon; )}</p>
<p style="padding-left:10%;">&delta;(q, 1, 1) = {(q, &epsilon; )}</p>
<h2>Algorithm to find CFG corresponding to a given PDA</h2>
<p><b>Input</b> &minus; A CFG, G = (V, T, P, S)</p>
<p><b>Output</b> &minus; Equivalent PDA, P = (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) such that the non- terminals of the grammar G will be {X<sub>wx</sub> | w,x &isin; Q} and the start state will be A<sub>q0,F</sub>.</p>
<p><b>Step 1</b> &minus; For every w, x, y, z &isin; Q, m &isin; S and a, b &isin; &sum;, if &delta; (w, a, &epsilon;) contains (y, m) and (z, b, m) contains (x, &epsilon;), add the production rule X<sub>wx</sub> &rarr; a X<sub>yz</sub>b in grammar G.</p>
<p><b>Step 2</b> &minus; For every w, x, y, z &isin; Q, add the production rule X<sub>wx</sub> &rarr; X<sub>wy</sub>X<sub>yx</sub> in grammar G.</p>
<p><b>Step 3</b> &minus; For w &isin; Q, add the production rule X<sub>ww</sub> &rarr; &epsilon; in grammar G.</p>
<h1>Pushdown Automata &amp; Parsing</h1>
<p>Parsing is used to derive a string using the production rules of a grammar. It is used to check the acceptability of a string. Compiler is used to check whether or not a string is syntactically correct. A parser takes the inputs and builds a parse tree.</p>
<p>A parser can be of two types &minus;</p>
<ul class="list">
<li><p><b>Top-Down Parser</b> &minus; Top-down parsing starts from the top with the start-symbol and derives a string using a parse tree.</p></li>
<li><p><b>Bottom-Up Parser</b> &minus; Bottom-up parsing starts from the bottom with the string and comes to the start symbol using a parse tree.</p></li>
</ul>
<h2>Design of Top-Down Parser</h2>
<p>For top-down parsing, a PDA has the following four types of transitions &minus;</p>
<ul class="list">
<li><p>Pop the non-terminal on the left hand side of the production at the top of the stack and push its right-hand side string.</p></li>
<li><p>If the top symbol of the stack matches with the input symbol being read, pop it.</p></li>
<li><p>Push the start symbol ‘S’ into the stack.</p></li>
<li><p>If the input string is fully read and the stack is empty, go to the final state ‘F’.</p></li>
</ul>
<h3>Example</h3>
<p>Design a top-down parser for the expression "x+y*z" for the grammar G with the following production rules &minus;</p>
<p style="padding-left:10%;">P: S &rarr; S+X | X, <span style="padding-left:6%;"> X &rarr; X*Y | Y, <span style="padding-left:6%;">Y &rarr; (S) | id</span></span></p>
<p><b><i>Solution</i></b></p>
<p>If the PDA is (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), then the top-down parsing is &minus;</p>
<p style="padding-left:7%;">(x+y*z, I) &#8866;(x +y*z, SI) &#8866; (x+y*z, S+XI) &#8866;(x+y*z, X+XI)</p>
<p style="padding-left:7%;">&#8866;(x+y*z, Y+X I) &#8866;(x+y*z, x+XI) &#8866;(+y*z, +XI) &#8866; (y*z, XI) </p>
<p style="padding-left:7%;">&#8866;(y*z, X*YI) &#8866;(y*z, y*YI) &#8866;(*z,*YI) &#8866;(z, YI) &#8866;(z, zI) &#8866;(&epsilon;, I)</p>
<h2>Design of a Bottom-Up Parser</h2>
<p>For bottom-up parsing, a PDA has the following four types of transitions &minus;</p>
<ul class="list">
<li><p>Push the current input symbol into the stack.</p></li>
<li><p>Replace the right-hand side of a production at the top of the stack with its left-hand side.</p></li>
<li><p>If the top of the stack element matches with the current input symbol, pop it.</p></li>
<li><p>If the input string is fully read and only if the start symbol ‘S’ remains in the stack, pop it and go to the final state ‘F’.</p></li>
</ul>
<h3>Example</h3>
<p>Design a top-down parser for the expression "x+y*z" for the grammar G with the following production rules &minus;</p>
<p style="padding-left:10%;">P: S &rarr; S+X | X, <span style="padding-left:6%;">X &rarr; X*Y | Y, <span style="padding-left:6%;">Y &rarr; (S) | id</span></span></p>
<p><b><i>Solution</i></b></p>
<p>If the PDA is (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), then the bottom-up parsing is &minus;</p>
<p style="padding-left:7%;">(x+y*z, I) &#8866; (+y*z, xI) &#8866; (+y*z, YI) &#8866; (+y*z, XI) &#8866; (+y*z, SI)</p>
<p style="padding-left:7%;">&#8866;(y*z, +SI) &#8866; (*z, y+SI) &#8866; (*z, Y+SI) &#8866; (*z, X+SI) &#8866; (z, *X+SI)</p>
<p style="padding-left:7%;">&#8866; (&epsilon;, z*X+SI) &#8866; (&epsilon;, Y*X+SI) &#8866; (&epsilon;, X+SI) &#8866; (&epsilon;, SI)</p>
<h1>Turing Machine Introduction</h1>
<p>A Turing Machine is an accepting device which accepts the languages (recursively enumerable set) generated by type 0 grammars. It was invented in 1936 by Alan Turing.</p>
<h2>Definition</h2>
<p>A Turing Machine (TM) is a mathematical model which consists of an infinite length tape divided into cells on which input is given. It consists of a head which reads the input tape. A state register stores the state of the Turing machine. After reading an input symbol, it is replaced with another symbol, its internal state is changed, and it moves from one cell to the right or left. If the TM reaches the final state, the input string is accepted, otherwise rejected.</p>
<p>A TM can be formally described as a 7-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states</p></li>
<li><p><b>X</b> is the tape alphabet</p></li>
<li><p><b>&sum;</b> is the input alphabet</p></li>
<li><p><b>&delta;</b> is a transition function; &delta; : Q &times; X &rarr; Q &times; X &times; {Left_shift, Right_shift}.</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state</p></li>
<li><p><b>B</b> is the blank symbol</p></li>
<li><p><b>F</b> is the set of final states</p></li>
</ul>
<h3>Comparison with the previous automaton</h3>
<p>The following table shows a comparison of how a Turing machine differs from Finite Automaton and Pushdown Automaton.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Machine</th>
<th style="text-align:center;">Stack Data Structure</th>
<th style="text-align:center;">Deterministic?</th>
</tr>
<tr>
<td>Finite Automaton</td>
<td>N.A</td>
<td>Yes</td>
</tr>
<tr>
<td>Pushdown Automaton</td>
<td>Last In First Out(LIFO)</td>
<td>No</td>
</tr>
<tr>
<td>Turing Machine</td>
<td>Infinite tape</td>
<td>Yes</td>
</tr>
</table>
<h3>Example of Turing machine</h3>
<p>Turing machine M = (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) with</p>
<ul class="list">
<li>Q = {q<sub>0</sub>, q<sub>1</sub>, q<sub>2</sub>, q<sub>f</sub>}</li>
<li>X = {a, b}</li>
<li>&sum; = {1}</li>
<li>q<sub>0</sub> = {q<sub>0</sub>}</li>
<li>B = blank symbol</li>
<li>F = {q<sub>f</sub> }</li>
</ul>
<p>&delta; is given by &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Tape alphabet symbol</th>
<th style="text-align:center;">Present State ‘q<sub>0</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>1</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>2</sub>’</th>
</tr>
<tr>
<td>a</td>
<td>1Rq<sub>1</sub></td>
<td>1Lq<sub>0</sub></td>
<td>1Lq<sub>f</sub></td>
</tr>
<tr>
<td>b</td>
<td>1Lq<sub>2</sub></td>
<td>1Rq<sub>1</sub></td>
<td>1Rq<sub>f</sub></td>
</tr>
</table>
<p>Here the transition 1Rq<sub>1</sub> implies that the write symbol is 1, the tape moves right, and the next state is q<sub>1</sub>. Similarly, the transition 1Lq<sub>2</sub> implies that the write symbol is 1, the tape moves left, and the next state is q<sub>2</sub>.</p>
<h2>Time and Space Complexity of a Turing Machine</h2>
<p>For a Turing machine, the time complexity refers to the measure of the number of times the tape moves when the machine is initialized for some input symbols and the space complexity is the number of cells of the tape written.</p>
<p>Time complexity all reasonable functions &minus;</p>
<p style="padding-left:10%;"><b>T(n) = O(n log n)</b></p>
<p>TM's space complexity &minus;</p>
<p style="padding-left:10%;"><b>S(n) = O(n)</b></p>
<h1>Accepted Language &amp; Decided Language</h1>
<p>A TM accepts a language if it enters into a final state for any input string w. A language is recursively enumerable (generated by Type-0 grammar) if it is accepted by a Turing machine.</p>
<p>A TM decides a language if it accepts it and enters into a rejecting state for any input not in the language. A language is recursive if it is decided by a Turing machine.</p>
<p>There may be some cases where a TM does not stop. Such TM accepts the language, but it does not decide it.</p>
<h2>Designing a Turing Machine</h2>
<p>The basic guidelines of designing a Turing machine have been explained below with the help of a couple of examples.</p>
<h3>Example 1</h3>
<p>Design a TM to recognize all strings consisting of an odd number of &alpha;’s.</p>
<p><b><i>Solution</i></b></p>
<p>The Turing machine <b>M</b> can be constructed by the following moves &minus;</p>
<ul class="list">
<li><p>Let <b>q<sub>1</sub></b> be the initial state.</p></li>
<li><p>If <b>M</b> is in <b>q<sub>1</sub></b>; on scanning &alpha;, it enters the state <b>q<sub>2</sub></b> and writes <b>B</b> (blank).</p></li>
<li><p>If <b>M</b> is in <b>q<sub>2</sub></b>; on scanning &alpha;, it enters the state <b>q<sub>1</sub></b> and writes <b>B</b> (blank).</p></li>
<li><p>From the above moves, we can see that <b>M</b> enters the state <b>q<sub>1</sub></b> if it scans an even number of &alpha;’s, and it enters the state <b>q<sub>2</sub></b> if it scans an odd number of &alpha;’s. Hence <b>q<sub>2</sub></b> is the only accepting state.</p></li>
</ul>
<p>Hence,</p>
<p style="padding-left:10%;">M = {{q<sub>1</sub>, q<sub>2</sub>}, {1}, {1, B}, &delta;, q<sub>1</sub>, B, {q<sub>2</sub>}}</p>
<p>where &delta; is given by &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Tape alphabet symbol</th>
<th style="text-align:center;">Present State ‘q<sub>1</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>2</sub>’</th>
</tr>
<tr>
<td>&alpha;</td>
<td>BRq<sub>2</sub></td>
<td>BRq<sub>1</sub></td>
</tr>
</table>
<h3>Example 2</h3>
<p>Design a Turing Machine that reads a string representing a binary number and erases all leading 0’s in the string. However, if the string comprises of only 0’s, it keeps one 0.</p>
<p><b><i>Solution</i></b></p>
<p>Let us assume that the input string is terminated by a blank symbol, B, at each end of the string.</p>
<p>The Turing Machine, <b>M</b>, can be constructed by the following moves &minus;</p>
<ul class="list">
<li><p>Let <b>q<sub>0</sub></b> be the initial state.</p></li>
<li><p>If <b>M</b> is in <b>q<sub>0</sub></b>, on reading 0, it moves right, enters the state <b>q<sub>1</sub></b> and erases 0. On reading 1, it enters the state <b>q<sub>2</sub></b> and moves right.</p></li>
<li><p>If <b>M</b> is in <b>q<sub>1</sub></b>, on reading 0, it moves right and erases 0, i.e., it replaces 0’s by B’s. On reaching the leftmost 1, it enters <b>q<sub>2</sub></b> and moves right. If it reaches B, i.e., the string comprises of only 0’s, it moves left and enters the state <b>q<sub>3</sub></b>.</p></li>
<li><p>If <b>M</b> is in <b>q<sub>2</sub></b>, on reading either 0 or 1, it moves right. On reaching B, it moves left and enters the state <b>q<sub>4</sub></b>. This validates that the string comprises only of 0’s and 1’s.</p></li>
<li><p>If <b>M</b> is in <b>q<sub>3</sub></b>, it replaces B by 0, moves left and reaches the final state <b>q<sub>f</sub></b>.</p></li>
<li><p>If <b>M</b> is in <b>q<sub>4</sub></b>, on reading either 0 or 1, it moves left. On reaching the beginning of the string, i.e., when it reads B, it reaches the final state <b>q<sub>f</sub></b>.</p></li>
</ul>
<p>Hence,</p>
<p style="padding-left:10%;">M = {{q<sub>0</sub>, q<sub>1</sub>, q<sub>2</sub>, q<sub>3</sub>, q<sub>4</sub>, q<sub>f</sub>}, {0,1, B}, {1, B}, &delta;, q<sub>0</sub>, B, {q<sub>f</sub>}}</p>
<p>where &delta; is given by &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Tape alphabet symbol</th>
<th style="text-align:center;">Present State ‘q<sub>0</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>1</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>2</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>3</sub>’</th>
<th style="text-align:center;">Present State ‘q<sub>4</sub>’</th>
</tr>
<tr>
<td>0</td>
<td>BRq<sub>1</sub></td>
<td>BRq<sub>1</sub></td>
<td>ORq<sub>2</sub></td>
<td>-</td>
<td>OLq<sub>4</sub></td>
</tr>
<tr>
<td>1</td>
<td>1Rq<sub>2</sub></td>
<td>1Rq<sub>2</sub></td>
<td>1Rq<sub>2</sub></td>
<td>-</td>
<td>1Lq<sub>4</sub></td>
</tr>
<tr>
<td>B</td>
<td>BRq<sub>1</sub></td>
<td>BLq<sub>3</sub></td>
<td>BLq<sub>4</sub></td>
<td>OLq<sub>f</sub></td>
<td>BRq<sub>f</sub></td>
</tr>
</table>
<h1>Multi-tape Turing Machine</h1>
<p>Multi-tape Turing Machines have multiple tapes where each tape is accessed with a separate head. Each head can move independently of the other heads. Initially the input is on tape 1 and others are blank. At first, the first tape is occupied by the input and the other tapes are kept blank. Next, the machine reads consecutive symbols under its heads and the TM prints a symbol on each tape and moves its heads.</p>
<img src="/automata_theory/images/multi_tape_turing_machine.jpg" alt="Multi-tape Turing Machine" />
<p>A Multi-tape Turing machine can be formally described as a 6-tuple (Q, X, B, &delta;, q<sub>0</sub>, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states</p></li>
<li><p><b>X</b> is the tape alphabet</p></li>
<li><p><b>B</b> is the blank symbol</p></li>
<li><p><b>&delta;</b> is a relation on states and symbols where</p>
<p style="padding-left:10%;">&delta;: Q &times; X<sup>k</sup> &rarr; Q &times; (X &times; {Left_shift, Right_shift, No_shift })<sup>k</sup></p>
<p style="padding-left:10%;">where there is <b>k</b> number of tapes</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state</p></li>
<li><p><b>F</b> is the set of final states</p></li>
</ul>
<p><b>Note</b> &minus; Every Multi-tape Turing machine has an equivalent single-tape Turing machine.</p>
<h1>Multi-track Turing Machine</h1>
<p>Multi-track Turing machines, a specific type of Multi-tape Turing machine, contain multiple tracks but just one tape head reads and writes on all tracks. Here, a single tape head reads n symbols from <b>n</b> tracks at one step. It accepts recursively enumerable languages like a normal single-track single-tape Turing Machine accepts.</p>
<p>A Multi-track Turing machine can be formally described as a 6-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states</p></li>
<li><p><b>X</b> is the tape alphabet</p></li>
<li><p><b>&sum;</b> is the input alphabet</p></li>
<li><p><b>&delta;</b> is a relation on states and symbols where</p>
<p style="padding-left:10%;">&delta;(Q<sub>i</sub>, [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>,....]) = (Q<sub>j</sub>, [b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>,....], Left_shift or Right_shift)</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state</p></li>
<li><p><b>F</b> is the set of final states</p></li>
</ul>
<p><b>Note</b> &minus; For every single-track Turing Machine <b>S</b>, there is an equivalent multi-track Turing Machine <b>M</b> such that <b>L(S) = L(M)</b>.</p>
<h1>Non-Deterministic Turing Machine</h1>
<p>In a Non-Deterministic Turing Machine, for every state and symbol, there are a group of actions the TM can have. So, here the transitions are not deterministic. The computation of a non-deterministic Turing Machine is a tree of configurations that can be reached from the start configuration.</p>
<p>An input is accepted if there is at least one node of the tree which is an accept configuration, otherwise it is not accepted. If all branches of the computational tree halt on all inputs, the non-deterministic Turing Machine is called a <b>Decider</b> and if for some input, all branches are rejected, the input is also rejected.</p>
<p>A non-deterministic Turing machine can be formally defined as a 6-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states</p></li>
<li><p><b>X</b> is the tape alphabet</p></li>
<li><p><b>&sum;</b> is the input alphabet</p></li>
<li><p><b>&delta;</b> is a transition function;</p>
<p style="padding-left:10%;">&delta; : Q &times; X &rarr; P(Q &times; X &times; {Left_shift, Right_shift}).</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state</p></li>
<li><p><b>B</b> is the blank symbol</p></li>
<li><p><b>F</b> is the set of final states</p></li>
</ul>
<h1>Semi-Infinite Tape Turing Machine</h1>
<p>A Turing Machine with a semi-infinite tape has a left end but no right end. The left end is limited with an end marker.</p>
<img src="/automata_theory/images/semi_infinite_tape.jpg" alt="Semi-infinite Tape" />
<p>It is a two-track tape &minus;</p>
<ul class="list">
<li><p><b>Upper track</b> &minus; It represents the cells to the right of the initial head position.</p></li>
<li><p><b>Lower track</b> &minus; It represents the cells to the left of the initial head position in reverse order.</p></li>
</ul>
<p>The infinite length input string is initially written on the tape in contiguous tape cells.</p>
<p>The machine starts from the initial state <b>q<sub>0</sub></b> and the head scans from the left end marker ‘End’. In each step, it reads the symbol on the tape under its head. It writes a new symbol on that tape cell and then it moves the head either into left or right one tape cell. A transition function determines the actions to be taken.</p>
<p>It has two special states called <b>accept state</b> and <b>reject state</b>. If at any point of time it enters into the accepted state, the input is accepted and if it enters into the reject state, the input is rejected by the TM. In some cases, it continues to run infinitely without being accepted or rejected for some certain input symbols.</p>
<p><b>Note</b> &minus; Turing machines with semi-infinite tape are equivalent to standard Turing machines.</p>
<h1>Linear Bounded Automata</h1>
<p>A linear bounded automaton is a multi-track non-deterministic Turing machine with a tape of some bounded finite length.</p>
<p style="padding-left:10%;"><b>Length = function (Length of the initial input string, constant c)</b></p>
<p>Here,</p>
<p style="padding-left:10%;"><b>Memory information &le; c &times; Input information</b></p>
<p>The computation is restricted to the constant bounded area. The input alphabet contains two special symbols which serve as left end markers and right end markers which mean the transitions neither move to the left of the left end marker nor to the right of the right end marker of the tape.</p>
<p>A linear bounded automaton can be defined as an 8-tuple (Q, X, &sum;, q<sub>0</sub>, ML, MR, &delta;, F) where &minus;</p>
<ul class="list">
<li><p><b>Q</b> is a finite set of states</p></li>
<li><p><b>X</b> is the tape alphabet</p></li>
<li><p><b>&sum;</b> is the input alphabet</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state</p></li>
<li><p><b>M<sub>L</sub></b> is the left end marker</p></li>
<li><p><b>M<sub>R</sub></b> is the right end marker where M<sub>R</sub> &ne;  M<sub>L</sub></p></li>
<li><p><b>&delta;</b> is a transition function which maps each pair (state, tape symbol) to (state, tape symbol, Constant ‘c’) where c can be 0 or +1 or -1</p></li>
<li><p><b>F</b> is the set of final states</p></li>
</ul>
<img src="/automata_theory/images/linear_bounded_automata.jpg" alt="Linear Bounded Automata" />
<p>A deterministic linear bounded automaton is always <b>context-sensitive</b> and the linear bounded automaton with empty language is <b>undecidable.</b>.</p>
<h1>Language Decidability</h1>
<p>A language is called <b>Decidable</b> or <b>Recursive</b> if there is a Turing machine which accepts and halts on every input string <b>w</b>. Every decidable language is Turing-Acceptable.</p>
<img src="/automata_theory/images/decidability_and_decidable_languages.jpg" alt="Decidability and Decidable Languages" />
<p>A decision problem <b>P</b> is decidable if the language <b>L</b> of all yes instances to <b>P</b> is decidable.</p>
<p>For a decidable language, for each input string, the TM halts either at the accept or the reject state as depicted in the following diagram &minus;</p>
<img src="/automata_theory/images/decidable_language.jpg" alt="Decidable Language" />
<h2>Example 1</h2>
<p>Find out whether the following problem is decidable or not &minus;</p>
<p style="padding-left:10%;">Is a number ‘m’ prime?</p>
<h3>Solution</h3>
<p style="padding-left:10%;">Prime numbers = {2, 3, 5, 7, 11, 13, …………..}</p>
<p style="padding-left:10%;">Divide the number <b>‘m’</b> by all the numbers between ‘2’ and ‘&radic;m’ starting from ‘2’.</p>
<p style="padding-left:10%;">If any of these numbers produce a remainder zero, then it goes to the “Rejected state”, otherwise it goes to the “Accepted state”. So, here the answer could be made by ‘Yes’ or ‘No’.</p>
<p><b>Hence, it is a decidable problem.</b></p>
<h2>Example 2</h2>
<p>Given a regular language <b>L</b> and string <b>w</b>, how can we check if <b>w &isin; L</b>?</p>
<h3>Solution</h3>
<p>Take the DFA that accepts <b>L</b> and check if <b>w</b> is accepted</p>
<img src="/automata_theory/images/dfa1.jpg" alt="DFA 1" />
<p>Some more decidable problems are &minus;</p>
<ul class="list">
<li>Does DFA accept the empty language?</li>
<li>Is L<sub>1</sub> &cap; L<sub>2</sub> = &empty; for regular sets?</li>
</ul>
<p><b>Note</b> &minus;</p>
<ul class="list">
<li><p>If a language <b>L</b> is decidable, then its complement <b>L'</b> is also decidable</p></li>
<li><p>If a language is decidable, then there is an enumerator for it.</p></li>
</ul>
<h1>Undecidable Languages</h1>
<p>For an undecidable language, there is no Turing Machine which accepts the language and makes a decision for every input string <b>w</b> (TM can make decision for some input string though). A decision problem <b>P</b> is called “undecidable” if the language <b>L</b> of all yes instances to <b>P</b> is not decidable. Undecidable languages are not recursive languages, but sometimes, they may be recursively enumerable languages.</p>
<img src="/automata_theory/images/undecidable_languages.jpg" alt="Undecidable Languages" />
<h2>Example</h2>
<ul class="list">
<li>The halting problem of Turing machine</li>
<li>The mortality problem</li>
<li>The mortal matrix problem</li>
<li>The Post correspondence problem, etc.</li>
</ul>
<h1>Turing Machine Halting Problem</h1>
<p><b>Input</b> &minus; A Turing machine and an input string <b>w</b>.</p>
<p><b>Problem</b> &minus; Does the Turing machine finish computing of the string <b>w</b> in a finite number of steps? The answer must be either yes or no.</p>
<p><b>Proof</b> &minus; At first, we will assume that such a Turing machine exists to solve this problem and then we will show it is contradicting itself. We will call this Turing machine as a <b>Halting machine</b> that produces a ‘yes’ or ‘no’ in a finite amount of time. If the halting machine finishes in a finite amount of time, the output comes as ‘yes’, otherwise as ‘no’. The following is the block diagram of a Halting machine &minus;</p>
<img src="/automata_theory/images/halting_machine.jpg" alt="Halting Machine" />
<p>Now we will design an <b>inverted halting machine (HM)’</b> as &minus;</p>
<ul class="list">
<li><p>If <b>H</b> returns YES, then loop forever.</p></li>
<li><p>If <b>H</b> returns NO, then halt.</p></li>
</ul>
<p>The following is the block diagram of an ‘Inverted halting machine’ &minus;</p>
<img src="/automata_theory/images/inverted_halting_machine.jpg" alt="Inverted Halting Machine" />
<p>Further, a machine <b>(HM)<sub>2</sub></b> which input itself is constructed as follows &minus;</p>
<ul class="list">
<li>If (HM)<sub>2</sub> halts on input, loop forever.</li>
<li>Else, halt.</li>
</ul>
<p>Here, we have got a contradiction. Hence, the halting problem is <b>undecidable</b>.</p>
<h1>Rice Theorem</h1>
<p>Rice theorem states that any non-trivial semantic property of a language which is recognized by a Turing machine is undecidable. A property, P, is the language of all Turing machines that satisfy that property.</p>
<h2>Formal Definition</h2>
<p>If P is a non-trivial property, and the language holding the property, L<sub>p</sub> , is recognized by Turing machine M, then L<sub>p</sub> = {&lt;M&gt; | L(M) &isin; P} is undecidable.</p>
<h2>Description and Properties</h2>
<ul class="list">
<li><p>Property of languages, P, is simply a set of languages. If any language belongs to P (L &isin; P), it is said that L satisfies the property P.</p></li>
<li><p>A property is called to be trivial if either it is not satisfied by any recursively enumerable languages, or if it is satisfied by all recursively enumerable languages.</p></li>
<li><p>A non-trivial property is satisfied by some recursively enumerable languages and are not satisfied by others. Formally speaking, in a non-trivial property, where L &isin; P, both the following properties hold:</p>
<ul class="list">
<li><p><b>Property 1</b> &minus; There exists Turing Machines, M1 and M2 that recognize the same language, i.e. either ( &lt;M1&gt;, &lt;M2&gt; &isin; L ) or ( &lt;M1&gt;,&lt;M2&gt; &notin; L )</p></li>
<li><p><b>Property 2</b> &minus; There exists Turing Machines M1 and M2, where M1 recognizes the language while M2 does not, i.e. &lt;M1&gt; &isin; L and &lt;M2&gt; &notin; L</p></li>
</ul>
</li>
</ul>
<h2>Proof</h2>
<p>Suppose, a property P is non-trivial and φ &isin; P.</p>
<p>Since, P is non-trivial, at least one language satisfies P, i.e., L(M<sub>0</sub>) &isin; P , &ni; Turing Machine M<sub>0</sub>.</p>
<p>Let, w be an input in a particular instant and N is a Turing Machine which follows &minus;</p>
<p>On input x</p>
<ul class="list">
<li>Run M on w</li>
<li>If M does not accept (or doesn't halt), then do not accept x (or do not halt)</li>
<li>If M accepts w then run M<sub>0</sub> on x. If M<sub>0</sub> accepts x, then accept x.</li>
</ul>
<p>A function that maps an instance ATM = {&lt;M,w&gt;| M accepts input w} to a N such that</p>
<ul class="list">
<li>If M accepts w and N accepts the same language as M<sub>0</sub>, Then L(M) = L(M<sub>0</sub>) &isin; p</li>
<li>If M does not accept w and N accepts φ, Then L(N) = φ &notin; p</li>
</ul>
<p>Since A<sub>TM</sub> is undecidable and it can be reduced to Lp, Lp is also undecidable.</p>
<h1>Post Correspondence Problem</h1>
<p>The Post Correspondence Problem (PCP), introduced by Emil Post in 1946, is an undecidable decision problem. The PCP problem over an alphabet &sum; is stated as follows &minus;</p>
<p>Given the following two lists, <b>M</b> and <b>N</b> of non-empty strings over &sum; &minus;</p>
<p style="padding-left:7%;">M = (x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>,………, x<sub>n</sub>)</p>
<p style="padding-left:7%;">N = (y<sub>1</sub>, y<sub>2</sub>, y<sub>3</sub>,………, y<sub>n</sub>)</p>
<p>We can say that there is a Post Correspondence Solution, if for some i<sub>1</sub>,i<sub>2</sub>,………… i<sub>k</sub>, where 1 &le; i<sub>j</sub> &le; n, the condition x<sub>i1</sub> …….x<sub>ik</sub> = y<sub>i1</sub> …….y<sub>ik</sub> satisfies.</p>
<h2>Example 1</h2>
<p>Find whether the lists</p>
<p style="padding-left:7%;">M = (abb, aa, aaa) and N = (bba, aaa, aa)</p>
<p>have a Post Correspondence Solution?</p>
<h3>Solution</h3>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;"></th>
<th style="text-align:center;">x<sub>1</sub></th>
<th style="text-align:center;">x<sub>2</sub></th>
<th style="text-align:center;">x<sub>3</sub></th>
</tr>
<tr>
<th style="text-align:center">M</th>
<td>Abb</td>
<td>aa</td>
<td>aaa</td>
</tr>
<tr>
<th style="text-align:center;">N</th>
<td>Bba</td>
<td>aaa</td>
<td>aa</td>
</tr>
</table>
<p>Here,</p>
<p style="padding-left:8%;"><b>x<sub>2</sub>x<sub>1</sub>x<sub>3</sub> = ‘aaabbaaa’</b></p>
<p>and <span style="padding-left:3%;"><b>y<sub>2</sub>y<sub>1</sub>y<sub>3</sub> = ‘aaabbaaa’</b></span></p>
<p>We can see that</p>
<p style="padding-left:7%;"><b>x<sub>2</sub>x<sub>1</sub>x<sub>3</sub> = y<sub>2</sub>y<sub>1</sub>y<sub>3</sub></b></p>
<p>Hence, the solution is <b>i = 2, j = 1, and k = 3.</b></p>
<h2>Example 2</h2>
<p>Find whether the lists <b>M = (ab, bab, bbaaa)</b> and <b>N = (a, ba, bab)</b> have a Post Correspondence Solution?</p>
<h3>Solution</h3>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;"></th>
<th style="text-align:center;">x<sub>1</sub></th>
<th style="text-align:center;">x<sub>2</sub></th>
<th style="text-align:center;">x<sub>3</sub></th>
</tr>
<tr>
<th style="text-align:center;">M</th>
<td>ab</td>
<td>bab</td>
<td>bbaaa</td>
</tr>
<tr>
<th style="text-align:center;">N</th>
<td>a</td>
<td>ba</td>
<td>bab</td>
</tr>
</table>
<p>In this case, there is no solution because &minus;</p>
<p style="padding-left:7%;"><b>| x<sub>2</sub>x<sub>1</sub>x<sub>3</sub> | &ne; | y<sub>2</sub>y<sub>1</sub>y<sub>3</sub> |</b> <span style="padding-left:5%">(Lengths are not same)</span></p>
<p>Hence, it can be said that this Post Correspondence Problem is <b>undecidable</b>.</p>
<div class="mui-container-fluid button-borders show">
<div class="pre-btn">
<a href="/automata_theory/post_correspondence_problem.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/automata_theory/automata_theory_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="google-bottom-ads">
<div>Advertisements</div>
<script><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class="space-bottom"></div>
</div>
</div>
<!-- Tutorial Content Ends Here -->
<!-- Right Column Starts Here -->
<div class="mui-col-md-2 google-right-ads">
<div class="space-top"></div>
<div class="google-right-ad" style="margin: 0px auto !important;margin-top:5px;">
<script><!--
google_ad_client = "pub-2537027957187252";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9012177"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9012177")})</script>
</div>
<div class="space-bottom"></div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9013289"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9013289")})</script>
</div>
<div class="space-bottom" style="margin-bottom:15px;"></div>
</div>
<!-- Right Column Ends Here -->
</div>
</div>
<div class="clear"></div>
<footer id="footer">
<div class="mui--text-center">
<div class="mui--text-caption mui--text-light">
<a href="/index.htm" class="logo"><img class="img-responsive" src="/images/logo-black.png" alt="Tutorials Point" title="Tutorials Point"></a>
</div>
<ul class="mui-list--inline mui--text-body2 mui--text-light">
<li><a href="/about/index.htm"><i class="fal fa-globe"></i> About us</a></li>
<li><a href="/about/about_terms_of_use.htm"><i class="fal fa-asterisk"></i> Terms of use</a></li>
<li><a href="/about/about_privacy.htm#cookies"> <i class="fal fa-shield-check"></i> Cookies Policy</a></li>
<li><a href="/about/faq.htm"><i class="fal fa-question-circle"></i> FAQ's</a></li>
<li><a href="/about/about_helping.htm"><i class="fal fa-hands-helping"></i> Helping</a></li>
<li><a href="/about/contact_us.htm"><i class="fal fa-map-marker-alt"></i> Contact</a></li>
</ul>
<div class="mui--text-caption mui--text-light bottom-copyright-text">&copy; Copyright 2019. All Rights Reserved.</div>
</div>
<div id="privacy-banner">
  <div>
    <p>
      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.
      <a id="banner-accept" href="#">Accept</a>
      <a id="banner-learn" href="/about/about_cookies.htm" target="_blank">Learn more</a>
    </p>
  </div>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-232293-17"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-232293-6');
</script>
</footer>
</body>
</html>
