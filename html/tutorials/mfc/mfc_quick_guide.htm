<!DOCTYPE html>
<html lang="en-US">
<head>
<title>MFC - Quick Guide</title>
<meta charset="utf-8">
<meta name="description" content="MFC - Quick Guide - The Microsoft Foundation Class (MFC) library provides a set of functions, constants, data types, and classes to simplify creating applications for the Microsoft"/>
<meta name="keywords" content="C, C++, Python, Java, HTML, CSS, JavaScript, SQL, PHP, jQuery, XML, DOM, Bootstrap, Tutorials, Articles, Programming, training, learning, quiz, preferences, examples, code"/>
<link rel="canonical" href="https://www.tutorialspoint.com/mfc/mfc_quick_guide.htm" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<script src="/theme/js/script-min-v2.js?v=3"></script>
<link rel="stylesheet" href="/theme/css/style-min-v2.css?v=6">
<script src="//services.bilsyndication.com/adv1/?d=901" defer="" async=""></script>
<script> var vitag = vitag || {};</script>
<script> vitag.outStreamConfig = { enablePC: false, enableMobile: false };</script>  
<style>
.right-menu .mui-btn {
    background-color:#e94701;
}
a.demo {
    background:#e94701;
}
li.heading {
    background:#e94701;
}
.course-box{background:#e94701}
.home-intro-sub p{color:#e94701}
</style>
</head>
<body>
<header id="header">
<!-- Top sub-menu Starts Here -->
<div class="mui-appbar mui-container-fulid top-menu">
<div class="mui-container">
<div class="top-menu-item home">
<a href="https://www.tutorialspoint.com/index.htm" target="_blank" title="TutorialsPoint - Home"><i class="fal fa-home"></i> <span>Home</span></a>
</div>
<div class="top-menu-item qa">
<a href="https://www.tutorialspoint.com/about/about_careers.htm" target="_blank" title="Job @ Tutorials Point"><i class="fa fa-suitcase"></i> <span>Jobs</span></a>
</div>
<div class="top-menu-item tools">
<a href="https://www.tutorialspoint.com/online_dev_tools.htm" target="_blank" title="Tools - Online Development and Testing Tools"><i class="fal fa-cogs"></i> <span>Tools</span></a>
</div>
<div class="top-menu-item coding-ground">
<a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" title="Coding Ground - Free Online IDE and Terminal"><i class="fal fa-code"></i> <span>Coding Ground </span></a> 
</div>
<div class="top-menu-item current-affairs">
<a href="https://www.tutorialspoint.com/current_affairs.htm" target="_blank" title="Daily Current Affairs"><i class="fal fa-layer-plus"></i> <span>Current Affairs</span></a>
</div>
<div class="top-menu-item upsc-notes">
<a href="https://www.tutorialspoint.com/upsc_ias_exams.htm" target="_blank" title="UPSC IAS Exams Notes - TutorialsPoint"><i class="fal fa-user-tie"></i> <span>UPSC Notes</span></a>
</div>      
<div class="top-menu-item online-tutoris">
<a href="https://www.tutorialspoint.com/tutor_connect/index.php" target="_blank" title="Top Online Tutors - Tutor Connect"><i class="fal fa-user"></i> <span>Online Tutors</span></a>
</div>
<div class="top-menu-item whiteboard">
<a href="https://www.tutorialspoint.com/whiteboard.htm" target="_blank" title="Free Online Whiteboard"><i class="fal fa-chalkboard"></i> <span>Whiteboard</span></a>
</div>
<div class="top-menu-item net-meeting">
<a href="https://www.tutorialspoint.com/netmeeting.php" target="_blank" title="A free tool for online video conferencing"><i class="fal fa-chalkboard-teacher"></i> <span>Net Meeting</span></a> 
</div>
<div class="top-menu-item articles">
<a href="https://www.tutorix.com" target="_blank" title="Tutorx - The Best Learning App" rel="nofollow"><i class="fal fa-video"></i> <span>Tutorix</span></a> 
</div>        
<div class="social-menu-item">
<a href="https://www.facebook.com/tutorialspointindia" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Facebook"><i class="fab fa-facebook-f"></i></a> 
<a href="https://www.twitter.com/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Twitter"><i class="fab fa-twitter"></i></a>
<a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Linkedin"><i class="fab fa-linkedin-in"></i></a>
<a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint YouTube"><i class="fab fa-youtube"></i></a>
</div>        
</div>
</div>
<!-- Top sub-menu Ends Here -->
<!-- Top main-menu Starts Here -->
<div class="mui-appbar mui-container-fulid mui--appbar-line-height mui--z1" id="logo-menu">
<div class="mui-container">
<div class="left-menu">
<a href="https://www.tutorialspoint.com/index.htm" title="Tutorialspoint">
<img class="tp-logo" alt="tutorialspoint" src="/mfc/images/logo.png">
</a>
<div class="mui-dropdown">
<a class="mui-btn mui-btn--primary categories" data-mui-toggle="dropdown"><i class="fa fa-th-large"></i> 
<span>Categories <span class="mui-caret"></span></span></a>            
<ul class="mui-dropdown__menu cat-menu">
<li>
<ul>
<li><a href="/academic_tutorials.htm"><i class="fa fa-caret-right"></i> Academic Tutorials</a></li>
<li><a href="/big_data_tutorials.htm"><i class="fa fa-caret-right"></i> Big Data &amp; Analytics </a></li>
<li><a href="/computer_programming_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Programming </a></li>
<li><a href="/computer_science_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Science </a></li>
<li><a href="/database_tutorials.htm"><i class="fa fa-caret-right"></i> Databases </a></li>
<li><a href="/devops_tutorials.htm"><i class="fa fa-caret-right"></i> DevOps </a></li>
<li><a href="/digital_marketing_tutorials.htm"><i class="fa fa-caret-right"></i> Digital Marketing </a></li>
<li><a href="/engineering_tutorials.htm"><i class="fa fa-caret-right"></i> Engineering Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> Exams Syllabus </a></li>
<li><a href="/famous_monuments.htm"><i class="fa fa-caret-right"></i> Famous Monuments </a></li>
<li><a href="/gate_exams_tutorials.htm"><i class="fa fa-caret-right"></i> GATE Exams Tutorials</a></li>
<li><a href="/latest_technologies.htm"><i class="fa fa-caret-right"></i> Latest Technologies </a></li>
<li><a href="/machine_learning_tutorials.htm"><i class="fa fa-caret-right"></i> Machine Learning </a></li>
<li><a href="/mainframe_tutorials.htm"><i class="fa fa-caret-right"></i> Mainframe Development </a></li>
<li><a href="/management_tutorials.htm"><i class="fa fa-caret-right"></i> Management Tutorials </a></li>
<li><a href="/maths_tutorials.htm"><i class="fa fa-caret-right"></i> Mathematics Tutorials</a></li>
<li><a href="/microsoft_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Microsoft Technologies </a></li>
<li><a href="/misc_tutorials.htm"><i class="fa fa-caret-right"></i> Misc tutorials </a></li>
<li><a href="/mobile_development_tutorials.htm"><i class="fa fa-caret-right"></i> Mobile Development </a></li>
<li><a href="/java_technology_tutorials.htm"><i class="fa fa-caret-right"></i> Java Technologies </a></li>
<li><a href="/python_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Python Technologies </a></li>
<li><a href="/sap_tutorials.htm"><i class="fa fa-caret-right"></i> SAP Tutorials </a></li>
<li><a href="/scripting_lnaguage_tutorials.htm"><i class="fa fa-caret-right"></i>Programming Scripts </a></li>
<li><a href="/selected_reading.htm"><i class="fa fa-caret-right"></i> Selected Reading </a></li>
<li><a href="/software_quality_tutorials.htm"><i class="fa fa-caret-right"></i> Software Quality </a></li>
<li><a href="/soft_skill_tutorials.htm"><i class="fa fa-caret-right"></i> Soft Skills </a></li>
<li><a href="/telecom_tutorials.htm"><i class="fa fa-caret-right"></i> Telecom Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> UPSC IAS Exams </a></li>
<li><a href="/web_development_tutorials.htm"><i class="fa fa-caret-right"></i> Web Development </a></li>
<li><a href="/sports_tutorials.htm"><i class="fa fa-caret-right"></i> Sports Tutorials </a></li>
<li><a href="/xml_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> XML Technologies </a></li>
<li><a href="/multi_language_tutorials.htm"><i class="fa fa-caret-right"></i> Multi-Language Tutorials</a></li>
<li><a href="/questions_and_answers.htm"><i class="fa fa-caret-right"></i> Interview Questions</a></li>
</ul>
</li>
</ul>
<div class="clear"></div>
</div> 
</div>
<div class="right-menu">
<div class="toc-toggle">
<a href="javascript:void(0);"><i class="fa fa-bars"></i></a>
</div>
<div class="mobile-search-btn">
<a href="https://www.tutorialspoint.com/search.htm"><i class="fal fa-search"></i></a>
</div>
<div class="search-box">
<form method="get" class="" name="searchform" action="https://www.google.com/search" target="_blank" novalidate="">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com" class="user-valid valid">
<input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
<button><i class="fal fa-search"></i></button>
</form>
</div>
<div class="menu-btn library-btn">
<a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a>
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a> 
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/questions/index.php"><i class="fa fa-location-arrow"></i> <span>Q/A</span></a>
</div>
<div class="menu-btn ebooks-btn">
<a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a>
</div>
<div class="mui-dropdown">
<button class="mui-btn mui-btn--primary" data-mui-toggle="dropdown">
<span class="mui-caret"></span>
</button>
<ul class="mui-dropdown__menu">
<li><a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a></li>
<li><a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a></li>
<li><a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a></li>
</ul>
</div>
</div>
</div>
</div>
<!-- Top main-menu Ends Here -->
</header>
<div class="mui-container-fluid content">
<div class="mui-container">
<!-- Tutorial ToC Starts Here -->
<div class="mui-col-md-3 tutorial-toc">
<div class="mini-logo">
<img src="/mfc/images/mfc-mini-logo.jpg" alt="MFC Tutorial" />
</div>
<ul class="toc chapters">
<li class="heading">MFC Tutorial</li>
<li><a href="/mfc/index.htm">MFC - Home</a></li>
<li><a href="/mfc/mfc_overview.htm">MFC - Overview</a></li>
<li><a href="/mfc/mfc_environment_setup.htm">MFC - Environment Setup</a></li>
<li><a href="/mfc/mfc_vcplusplus_projects.htm">MFC - VC++ Projects</a></li>
<li><a href="/mfc/mfc_getting_started.htm">MFC - Getting Started</a></li>
<li><a href="/mfc/mfc_windows_fundamentals.htm">MFC - Windows Fundamentals</a></li>
<li><a href="/mfc/mfc_dialog_boxes.htm">MFC - Dialog Boxes</a></li>
<li><a href="/mfc/mfc_windows_resources.htm">MFC - Windows Resources</a></li>
<li><a href="/mfc/mfc_property_sheets.htm">MFC - Property Sheets</a></li>
<li><a href="/mfc/mfc_windows_layout.htm">MFC - Windows Layout</a></li>
<li><a href="/mfc/mfc_controls_management.htm">MFC - Controls Management</a></li>
<li><a href="/mfc/mfc_windows_controls.htm">MFC - Windows Controls</a></li>
<li><a href="/mfc/mfc_messages_events.htm">MFC - Messages &amp; Events</a></li>
<li><a href="/mfc/mfc_activex_control.htm">MFC - Activex Controls</a></li>
<li><a href="/mfc/mfc_file_system.htm">MFC - File System</a></li>
<li><a href="/mfc/mfc_standard_io.htm">MFC - Standard I/O</a></li>
<li><a href="/mfc/mfc_document_view.htm">MFC - Document View</a></li>
<li><a href="/mfc/mfc_strings.htm">MFC - Strings</a></li>
<li><a href="/mfc/mfc_carray.htm">MFC - Carray</a></li>
<li><a href="/mfc/mfc_linked_lists.htm">MFC - Linked Lists</a></li>
<li><a href="/mfc/mfc_database_classes.htm">MFC - Database Classes</a></li>
<li><a href="/mfc/mfc_serialization.htm">MFC - Serialization</a></li>
<li><a href="/mfc/mfc_multithreading.htm">MFC - Multithreading</a></li>
<li><a href="/mfc/mfc_internet_programming.htm">MFC - Internet Programming</a></li>
<li><a href="/mfc/mfc_gdi.htm">MFC - GDI</a></li>
<li><a href="/mfc/mfc_libraries.htm">MFC - Libraries</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">MFC Useful Resources</li>
<li><a href="/mfc/mfc_quick_guide.htm">MFC - Quick Guide</a></li>
<li><a href="/mfc/mfc_useful_resources.htm">MFC - Useful Resources</a></li>
<li><a href="/mfc/mfc_discussion.htm">MFC - Discussion</a></li>
</ul>
<ul class="toc reading">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="/upsc_ias_exams.htm">UPSC IAS Exams Notes</a></li>
<li><a target="_top" href="/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</div>
<!-- Tutorial ToC Ends Here -->
<!-- Tutorial Content Starts Here -->
<div class="mui-col-md-6 tutorial-content">
<h1>MFC - Quick Guide</h1>
<hr />
<div class="top-ad-heading">Advertisements</div>
<div style="text-align: center;">
<script><!--
google_ad_client = "pub-7133395778201029";
var width = document.getElementsByClassName("tutorial-content")[0].clientWidth - 40;
google_ad_width = width;
google_ad_height = 150;
google_ad_format = width + "x150_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="mui-container-fluid button-borders">
<div class="pre-btn">
<a href="/mfc/mfc_libraries.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/mfc/mfc_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="clearer"></div>
<h1>MFC - Overview</h1>
<p>The Microsoft Foundation Class (MFC) library provides a set of functions, constants, data types, and classes to simplify creating applications for the Microsoft Windows operating systems. In this tutorial, you will learn all about how to start and create windows based applications using MFC.</p>
<h2>Prerequisites</h2>
<p>We have assumed that you know the following &minus;</p>
<ul class="list">
<li>A little about programming for Windows.</li>
<li>The basics of programming in C++.</li>
<li>Understand the fundamentals of object-oriented programming.</li>
</ul>
<h2>What is MFC?</h2>
<p>The Microsoft Foundation Class Library (MFC) is an "application framework" for programming in Microsoft Windows. MFC provides much of the code, which are required for the following &minus;</p>
<ul class="list">
<li>Managing Windows.</li>
<li>Menus and dialog boxes.</li>
<li>Performing basic input/output.</li>
<li>Storing collections of data objects, etc.</li>
</ul>
<p>You can easily extend or override the basic functionality the MFC framework in you C++ applications by adding your application-specific code into MFC framework.</p>
<h2>MFC Framework</h2>
<ul class="list">
<li><p>The MFC framework provides a set of reusable classes designed to simplify Windows programming.</p></li>
<li><p>MFC provides classes for many basic objects, such as strings, files, and collections that are used in everyday programming.</p></li>
<li><p>It also provides classes for common Windows APIs and data structures, such as windows, controls, and device contexts.</p></li>
<li><p>The framework also provides a solid foundation for more advanced features, such as ActiveX and document view processing.</p></li>
<li><p>In addition, MFC provides an application framework, including the classes that make up the application architecture hierarchy.</p></li>
</ul>
<h2>Why MFC?</h2>
<p>The MFC framework is a powerful approach that lets you build upon the work of expert programmers for Windows. MFC framework has the following advantages.</p>
<ul class="list">
<li><p>It shortens development time.</p></li>
<li><p>It makes code more portable.</p></li>
<li><p>It also provides tremendous support without reducing programming freedom and flexibility.</p></li>
<li><p>It gives easy access to "hard to program" user-interface elements and technologies.</p></li>
<li><p>MFC simplifies database programming through Data Access Objects (DAO) and Open Database Connectivity (ODBC), and network programming through Windows Sockets.</p></li>
</ul>
<h1>MFC - Environment Setup</h1>
<p>Microsoft Visual C++ is a programming environment used to create applications for the Microsoft Windows operating systems. To use MFC framework in your C++ application, you must have installed either Microsoft Visual C++ or Microsoft Visual Studio. Microsoft Visual Studio also contains the Microsoft Visual C++ environment.</p>
<p>Microsoft provides a free version of visual studio which also contains SQL Server and it can be downloaded from <a href="https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx" rel="nofollow" target="_blank">https://www.visualstudio.com/en-us/downloads/downloadvisual- studio-vs.aspx</a>.</p>
<p>Following are the installation steps.</p>
<p><b>Step 1</b> &minus; Once Visual Studio is downloaded, run the installer. The following dialog box will be displayed.</p>
<img src="/mfc/images/visual_studio_dialog_box.jpg" alt="Visual Studio" />
<p><b>Step 2</b> &minus; Click Install to start the installation process.</p>
<img src="/mfc/images/visual_studio_start_installation.jpg" alt="Visual Studio Installation" />
<p><b>Step 3</b> &minus; Once Visual Studio is installed successfully, you will see the following dialog box.</p>
<img src="/mfc/images/visual_studio_installed.jpg" alt="Visual Studio Installed" />
<p><b>Step 4</b> &minus; Close this dialog box and restart your computer if required.</p>
<p><b>Step 5</b> &minus; Open Visual studio from the Start menu, which will open the following dialog box. It will take some time for preparation, while starting for the first time.</p>
<img src="/mfc/images/visual_studio_preparing.jpg" alt="Visual Studio Preparing" />
<p><b>Step 6</b> &minus; Next, you will see the main window of Visual Studio.</p>
<img src="/mfc/images/visual_studio_main_window.jpg" alt="Visual Studio Main Window" />
<p><b>Step 7</b> &minus; You are now ready to start your application.</p>
<h1>MFC - VC++ Projects</h1>
<p>In this chapter, we will be covering the different types of VC++ projects. Visual Studio includes several kinds of Visual C++ project templates. These templates help to create the basic program structure, menus, toolbars, icons, references, and include statements that are appropriate for the kind of project you want to create. Following are some of the salient features of the templates.</p>
<ul class="list">
<li><p>It provides wizards for many of these project templates and helps you customize your projects as you create them.</p></li>
<li><p>Once the project is created, you can build and run the application.</p></li>
<li><p>You don't have to use a template to create a project, but in most cases it's more efficient to use project templates.</p></li>
<li><p>It's easier to modify the provided project files and structure than it is to create them from scratch.</p></li>
</ul>
<p>In MFC, you can use the following project templates.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Project Template &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>MFC Application</b></p>
<p>An MFC application is an executable application for Windows that is based on the Microsoft Foundation Class (MFC) Library. The easiest way to create an MFC application is to use the MFC Application Wizard.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>MFC ActiveX Control</b></p>
<p>ActiveX control programs are modular programs designed to give a specific type of functionality to a parent application. For example, you can create a control such as a button for use in a dialog, or toolbar or on a Web page.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>MFC DLL</b></p>
<p>An MFC DLL is a binary file that acts as a shared library of functions that can be used simultaneously by multiple applications. The easiest way to create an MFC DLL project is to use the MFC DLL Wizard.</p></td>
</tr>
</table>
<p>Following are some General templates which can also be used to create MFC application &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Project Template &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Empty Project</b></p>
<p>Projects are the logical containers for everything that's needed to build your application. You can then add more new or existing projects to the solution if necessary.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>Custom Wizard</b></p>
<p>The Visual C++ Custom Wizard is the tool to use when you need to create a new custom wizard. The easiest way to create a custom wizard is to use the Custom Wizard.</p></td>
</tr>
</table>
<h1>MFC - Getting Started</h1>
<p>In this chapter, we will look at a working MFC example. To create an MFC application, you can use wizards to customize your projects. You can also create an application from scratch.</p>
<h2>Create Project Using Project Templates </h2>
<p>Following are the steps to create a project using project templates available in Visual Studio.</p>
<p><b>Step 1</b> &minus;  Open the Visual studio and click on the File &rarr; New &rarr; Project menu option.</p>
<p><b>Step 2</b> &minus;  You can now see that the New Project dialog box is open.</p>
<img src="/mfc/images/project.jpg" alt="Project" />
<p><b>Step 3</b> &minus; From the left pane, select Templates &rarr; Visual C++ &rarr; MFC </p>
<p><b>Step 4</b> &minus;  In the middle pane, select MFC Application.</p>
<p><b>Step 5</b> &minus; Enter the project name ‘MFCDemo’ in the Name field and click OK to continue. You will see the following dialog.</p>
<img src="/mfc/images/mfcdemo_application.jpg" alt="Application MFCDemo" />
<p><b>Step 6</b> &minus; Click Next.</p>
<img src="/mfc/images/mfc_application_type.jpg" alt="MFC Application Type" />
<p><b>Step 7</b> &minus; Select the options which are shown in the dialog box given above and click Next.</p>
<img src="/mfc/images/mfc_application_options.jpg" alt="MFC Application Options" />
<p><b>Step 8</b> &minus; Uncheck all options and click Finish button.</p>
<p>You can now see that the MFC wizard creates this Dialog Box and the project files by default.</p>
<img src="/mfc/images/mfc_wizard.jpg" alt="MFC Wizard" />
<p><b>Step 9</b> &minus; Run this application, you will see the following output.</p>
<img src="/mfc/images/mfc_application_result.jpg" alt="MFC Application Result" />
<h2>Create Project from Scratch</h2>
<p>You can also create an MFC application from scratch. To create an MFC application, you need to follow the following Steps.</p>
<p><b>Step 1</b> &minus; Open the Visual studio and click on the File &rarr; New &rarr; Project menu option.</p>
<p><b>Step 2</b> &minus; You can now see the New Project dialog box.</p>
<img src="/mfc/images/create_mfc_application_scratch.jpg" alt="Create Scratch" />
<p><b>Step 3</b> &minus; From the left pane, select Templates &rarr; Visual C++ &rarr; General.</p>
<p><b>Step 4</b> &minus; In the middle pane, select Empty</p>
<p><b>Step 5</b> &minus; Enter project name ‘MFCDemoFromScratch’ in the Name field and click OK to continue. You will see that an empty project is created.</p>
<img src="/mfc/images/mfc_demo_from_scratch.jpg" alt="MFCDemoFromScratch" />
<p><b>Step 6</b> &minus; To make it an MFC project, right-click on the project and select Properties.</p>
<img src="/mfc/images/select_mfc_project.jpg" alt="Select MFC Project &amp; Properties" />
<p><b>Step 7</b> &minus; In the left section, click Configuration Properties &rarr; General.</p>
<p><b>Step 8</b> &minus; Select the Use MFC in Shared DLL option in Project Defaults section and click OK.</p>
<p><b>Step 9</b> &minus; As it is an empty project now; we need to add a C++ file. So, right-click on the project and select Add &rarr; New Item…</p>
<img src="/mfc/images/add_new_item.jpg" alt="Add New Item" />
<p><b>Step 10</b> &minus; Select <b>C++ File (.cpp)</b> in the middle pane and enter file name in the Name field and click Add button.</p>
<img src="/mfc/images/enter_file_name.jpg" alt="Enter File Name" />
<p><b>Step 11</b> &minus; You can now see the <b>main.cpp</b> file added under the Source Files folder.</p>
<p><b>Step 12</b> &minus; Let us add the following code in this file.</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt; 
using namespace std;  

void main() { 
   cout &lt;&lt; "***************************************\n"; 
   cout &lt;&lt; "MFC Application Tutorial"; 
   cout &lt;&lt; "\n***************************************"; 
   getchar(); 
}
</pre>
<p><b>Step 13</b> &minus; When you run this application, you will see the following output on console.</p>
<pre class="result notranslate">
*************************************** 
MFC Application Tutorial 
***************************************
</pre>
<h1>MFC - Windows Fundamentals</h1>
<p>In this chapter, we will be covering the fundamentals of Windows. To create a program, also called an application, you derive a class from the MFC's CWinApp. <b>CWinApp</b> stands for <b>Class for a Windows Application.</b></p>
<p>Let us look into a simple example by creating a new Win32 project.</p>
<p><b>Step 1</b> &minus; Open the Visual studio and click on the File &rarr; New &rarr; Project menu option.</p>
<p><b>Step 2</b> &minus; You can now see the New Project dialog box.</p>
<img src="/mfc/images/windows_application.jpg" alt="Windows Application" />
<p><b>Step 3</b> &minus; From the left pane, select Templates &rarr; Visual C++ &rarr; Win32.</p>
<p><b>Step 4</b> &minus; In the middle pane, select Win32 Project.</p>
<p><b>Step 5</b> &minus; Enter the project name ‘MFCWindowDemo’ in the Name field and click OK to continue. You will see the following dialog box.</p>
<img src="/mfc/images/select_win32_Project.jpg" alt="Select Win32 Project" />
<p><b>Step 6</b> &minus; Click Next.</p>
<img src="/mfc/images/win32_application_setting.jpg" alt="Win32 Application Setting" />
<p><b>Step 7</b> &minus; Select the options as shown in the dialog box given above and click Finish.</p>
<img src="/mfc/images/mfc_window_demo.jpg" alt="MFCWindowsDemo" />
<p><b>Step 8</b> &minus; An empty project is created.</p>
<p><b>Step 9</b> &minus; To make it an MFC project, right-click on the project and select Properties.</p>
<img src="/mfc/images/mfswindow_demo_property_page.jpg" alt="MFCWindowDemo Property Page" />
<p><b>Step 10</b> &minus; In the left section, click Configuration Properties &rarr; General.</p>
<p><b>Step 11</b> &minus; Select the Use MFC in Shared DLL option in Project Defaults section and click OK.</p>
<p><b>Step 12</b> &minus; Add a new source file.</p>
<p><b>Step 13</b> &minus; Right-click on your Project and select Add &rarr;  New Item...</p>
<p><b>Step 14</b> &minus; In the Templates section, click C++ File (.cpp).</p>
<img src="/mfc/images/mfcwindowdemo_add_item.jpg" alt="MFCWindowDemo Add New Item" />
<p><b>Step 15</b> &minus; Set the Name as Example and click Add.</p>
<h2>Window Creation</h2>
<p>Any application has two main sections &minus;</p>
<ul class="list">
<li>Class</li>
<li>Frame or Window</li>
</ul>
<p>Let us create a window using the following steps &minus;</p>
<p><b>Step 1</b> &minus; To create an application, we need to derive a class from the MFC's CWinApp.</p>
<pre class="prettyprint notranslate">
#include
class CExample : public CWinApp {
   BOOL InitInstance() {
      return TRUE;
   }
};
</pre>
<p><b>Step 2</b> &minus; We also need a frame/window to show the content of our application.</p>
<p><b>Step 3</b> &minus; For this, we need to add another class and derive it from the MFC's <b>CFrameWnd</b> class and implement its constructor and a call the Create() method, which will create a frame/window as shown in the following code.</p>
<pre class="prettyprint notranslate">
class CMyFrame : public CFrameWnd {
   public:
      CMyFrame() {
         Create(NULL, _T("MFC Application Tutorial"));
      }
};
</pre>
<p><b>Step 4</b> &minus; As you can see that Create() method needs two parameters, the name of the class, which should be passed as NULL, and the name of the window, which is the string that will be shown on the title bar.</p>
<h2>Main Window</h2>
<p>After creating a window, to let the application use it, you can use a pointer to show the class used to create the window. In this case, the pointer would be CFrameWnd. To use the frame window, assign its pointer to the CWinThread::m_pMainWnd member variable. This is done in the InitInstance() implementation of your application.</p>
<p><b>Step 1</b> &minus; Here is the implementation of InitInstance() in CExample class.</p>
<pre class="prettyprint notranslate">
class CExample : public CWinApp {
   BOOL InitInstance() {
      CMyFrame *Frame = new CMyFrame();  m_pMainWnd = Frame;
      
      Frame-&gt;ShowWindow(SW_NORMAL);
      Frame-&gt;UpdateWindow();
      
      return TRUE;
   }
};
</pre>
<p><b>Step 2</b> &minus; Following is the complete implementation of Example.cpp file.</p>
<pre class="prettyprint notranslate">
#include &lt;afxwin.h&gt;

class CMyFrame : public CFrameWnd {
   public:
      CMyFrame() {
         Create(NULL, _T("MFC Application Tutorial"));
      }
};

class CExample : public CWinApp {
   BOOL InitInstance() {
      CMyFrame *Frame = new CMyFrame();
      m_pMainWnd = Frame;
      
      Frame-&gt;ShowWindow(SW_NORMAL);
      Frame-&gt;UpdateWindow();
      
      return TRUE;
   }
};

CExample theApp;
</pre>
<p><b>Step 3</b> &minus; When we run the above application, the following window is created.</p>
<img src="/mfc/images/created_window.jpg" alt="Created Window" />
<h2>Windows Styles</h2>
<p>Windows styles are characteristics that control features such as window appearance, borders, minimized or maximized state, or other resizing states, etc. </p>
<section class="toggle">
<label>Following is a list of styles which you can use while creating a Window.</label>
<div class="toggle-content">
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Style &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>WS_BORDER</b></p>
<p>Creates a window that has a border.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>WS_CAPTION</b></p>
<p>Creates a window that has a title bar (implies the WS_BORDER style). Cannot be used with the WS_DLGFRAME style.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>WS_CHILD</b></p>
<p>Creates a child window. Cannot be used with the WS_POPUP style.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>WS_CHILDWINDOW</b></p>
<p>Same as the WS_CHILD style.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>WS_CLIPCHILDREN</b></p>
<p>Excludes the area occupied by child windows when you draw within the parent window. Used when you create the parent window.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>WS_CLIPSIBLINGS</b></p>
<p>Clips child windows relative to each other; that is, when a particular child window receives a paint message, the WS_CLIPSIBLINGS style clips all other overlapped child windows out of the region of the child window to be updated. (If WS_CLIPSIBLINGS is not given and child windows overlap, when you draw within the client area of a child window, it is possible to draw within the client area of a neighboring child window.) For use with the WS_CHILD style only.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>WS_DISABLED</b></p>
<p>Creates a window that is initially disabled.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>WS_DLGFRAME</b></p>
<p>Creates a window with a double border but no title.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>WS_GROUP</b></p>
<p>Specifies the first control of a group of controls in which the user can move from one control to the next with the arrow keys. All controls defined with the WS_GROUP style FALSE after the first control belong to the same group. The next control with the WS_GROUP style starts the next group (that is, one group ends where the next begins).</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>WS_HSCROLL</b></p>
<p>Creates a window that has a horizontal scroll bar.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>WS_ICONIC</b></p>
<p>Creates a window that is initially minimized. Same as the WS_MINIMIZE style.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>WS_MAXIMIZE</b></p>
<p>Creates a window of maximum size.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>WS_MAXIMIZEBOX</b></p>
<p>Creates a window that has a Maximize button.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>WS_MINIMIZE</b></p>
<p>Creates a window that is initially minimized. For use with the WS_OVERLAPPED style only.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>WS_MINIMIZEBOX</b></p>
<p>Creates a window that has a Minimize button.</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>WS_OVERLAPPED</b></p>
<p>Creates an overlapped window. An overlapped window usually has a caption and a border.</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>WS_OVERLAPPED WINDOW</b></p>
<p>Creates an overlapped window with the WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX, and WS_MAXIMIZEBOX styles.</p></td>
</tr>
<tr>
<td class="ts">18</td>
<td><p><b>WS_POPUP</b></p>
<p>Creates a pop-up window. Cannot be used with the WS_CHILD style.</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><p><b>WS_POPUPWINDOW</b></p>
<p>Creates a pop-up window with the WS_BORDER, WS_POPUP, and WS_SYSMENU styles. The WS_CAPTION style must be combined with the WS_POPUPWINDOW style to make the Control menu visible.</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><p><b>WS_SIZEBOX</b></p>
<p>Creates a window that has a sizing border. Same as the WS_THICKFRAME style.</p></td>
</tr>
<tr>
<td class="ts">21</td>
<td><p><b>WS_SYSMENU</b></p>
<p>Creates a window that has a Control-menu box in its title bar. Used only for windows with title bars.</p></td>
</tr>
<tr>
<td class="ts">22</td>
<td><p><b>WS_TABSTOP</b></p>
<p>Specifies one of any number of controls through which the user can move by using the TAB key. The TAB key moves the user to the next control specified by the WS_TABSTOP style.</p></td>
</tr>
<tr>
<td class="ts">23</td>
<td><p><b>WS_THICKFRAME</b></p>
<p>Creates a window with a thick frame that can be used to size the window.</p></td>
</tr>
<tr>
<td class="ts">24</td>
<td><p><b>WS_TILED</b></p>
<p>Creates an overlapped window. An overlapped window has a title bar and a border. Same as the WS_OVERLAPPED style.</p></td>
</tr>
<tr>
<td class="ts">25</td>
<td><p><b>WS_TILEDWINDOW</b></p>
<p>Creates an overlapped window with the WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX, and WS_MAXIMIZEBOX styles. Same as the WS_OVERLAPPEDWINDOW style.</p></td>
</tr>
<tr>
<td class="ts">26</td>
<td><p><b>WS_VISIBLE</b></p>
<p>Creates a window that is initially visible.</p></td>
</tr>
<tr>
<td class="ts">27</td>
<td><p><b>WS_VSCROLL</b></p>
<p>Creates a window that has a vertical scroll bar.</p></td>
</tr>
</table>
</div>
</section>
<p><b>Step 1</b> &minus; Let us look into a simple example in which we will add some styling. After creating a window, to display it to the user, we can apply the WS_VISIBLE style to it and additionally, we will also add WS_OVERLAPPED style. Here is an implementation &minus;</p>
<pre class="prettyprint notranslate">
class CMyFrame : public CFrameWnd {
   public:
      CMyFrame() {
         Create(NULL, _T("MFC Application Tutorial"), WS_VISIBLE | WS_OVERLAPPED);
      }
};
</pre>
<p><b>Step 2</b> &minus; When you run this application, the following window is created.</p>
<img src="/mfc/images/created_window.jpg" alt="Created Window" />
<p>You can now see that the minimize, maximize, and close options do not appear anymore.</p>
<h2>Windows Location</h2>
<p>To locate things displayed on the monitor, the computer uses a coordinate system similar to the Cartesian's, but the origin is located on the top left corner of the screen. Using this coordinate system, any point can be located by its distance from the top left corner of the screen of the horizontal and the vertical axes.</p>
<p>The <b>Win32 library</b> provides a structure called POINT defined as follows &minus;</p>
<pre class="prettyprint notranslate">
typedef struct tagPOINT {
   LONG x;
   LONG y;
} POINT;
</pre>
<ul class="list">
<li><p>The ‘x’ member variable is the distance from the left border of the screen to the point.</p></li>
<li><p>The ‘y’ variable represents the distance from the top border of the screen to the point.</p></li>
<li><p>Besides the Win32's POINT structure, the Microsoft Foundation Class (MFC) library provides the CPoint class.</p></li>
<li><p>This provides the same functionality as the POINT structure. As a C++ class, it adds more functionality needed to locate a point. It provides two constructors.</p></li>
</ul>
<pre class="prettyprint notranslate">
CPoint();
CPoint(int X, int Y);
</pre>
<h2>Windows Size</h2>
<p>While a point is used to locate an object on the screen, each window has a size. The size provides two measures related to an object.</p>
<ul class="list">
<li>The width of an object.</li>
<li>The height of an object.</li>
</ul>
<p>The Win32 library uses the SIZE structure defined as follows &minus;</p>
<pre class="prettyprint notranslate">
typedef struct tagSIZE {
   int cx;
   int cy;
} SIZE;
</pre>
<p>Besides the Win32's SIZE structure, the MFC provides the CSize class. This class has the same functionality as SIZE but adds features of a C++ class. It provides five constructors that allow you to create a size variable in any way of your choice.</p>
<pre class="prettyprint notranslate">
CSize();
CSize(int initCX, int initCY);
CSize(SIZE initSize);
CSize(POINT initPt);
CSize(DWORD dwSize);
</pre>
<h2>Windows Dimensions</h2>
<p>When a Window displays, it can be identified on the screen by its location with regards to the borders of the monitor. A Window can also be identified by its width and height. These characteristics are specified or controlled by the <i>rect</i> argument of the <b>Create()</b> method. This argument is a rectangle that can be created through the Win32 RECT structure.</p>
<pre class="prettyprint notranslate">
typedef struct _RECT {
   LONG left;
   LONG top;
   LONG right;
   LONG bottom;
} RECT, *PRECT;
</pre>
<p>Besides the Win32's <b>RECT</b> structure, the MFC provides the CRect class which has the following constructors &minus; </p>
<pre class="prettyprint notranslate">
CRect();
CRect(int l, int t, int r, int b);
CRect(const RECT&amp; srcRect);
CRect(LPCRECT lpSrcRect);
CRect(POINT point, SIZE size);
CRect(POINT topLeft, POINT bottomRight);
</pre>
<p>Let us look into a simple example in which we will specify the location and the size of the window</p>
<pre class="prettyprint notranslate">
class CMyFrame : public CFrameWnd {
   public:
      CMyFrame() {
         Create(NULL, _T("MFC Application Tutorial"), WS_SYSMENU, CRect(90, 120, 
            550, 480));
      }
};
</pre>
<p>When you run this application, the following window is created on the top left corner of your screen as specified in CRect constructor in the first two parameters. The last two parameters are the size of the Window.</p>
<img src="/mfc/images/app_window.jpg" alt="Created Application Window" />
<h2>Windows Parents</h2>
<p>In the real world, many applications are made of different Windows. When an application uses various Windows, most of the objects depend on a particular one. It could be the first Window that was created or another window that you designated. Such a Window is referred to as the <b>Parent Window</b>. All the other windows depend on it directly or indirectly.</p>
<ul class="list">
<li><p>If the Window you are creating is dependent of another, you can specify that it has a parent.</p></li>
<li><p>This is done with the pParentWnd argument of the CFrameWnd::Create() method.</p></li>
<li><p>If the Window does not have a parent, pass the argument with a NULL value.</p></li>
</ul>
<p>Let us look into an example which has only one Window, and there is no parent Window available, so we will pass the argument with NULL value as shown in the following code &minus;</p>
<pre class="prettyprint notranslate">
class CMyFrame : public CFrameWnd {
   public:
      CMyFrame() {
         Create(NULL, _T("MFC Application Tutorial"), WS_SYSMENU, 
            CRect(90, 120, 550, 480), NULL);
      }
};
</pre>
<p>When you run the above application, you see the same output.</p>
<img src="/mfc/images/app_window.jpg" alt="Created Application Window" />
<h1>MFC - Dialog Boxes</h1>
<p>In this chapter, we will be covering the Dialog boxes. Applications for Windows frequently communicate with the user through dialog boxes. <b>CDialog class</b> provides an interface for managing dialog boxes. The Visual C++ dialog editor makes it easy to design dialog boxes and create their dialog-template resources.</p>
<ul class="list">
<li><p>Creating a dialog object is a two-phase operation &minus;</p>
<ul class="list">
<li><p>Construct the dialog object.</p></li>
<li><p>Create the dialog window.</p></li>
</ul></li>
</ul>
<p>Let us look into a simple example by creating a new Win32 project.</p>
<p><b>Step 1</b> &minus; Open the Visual studio and click on the File &rarr; New &rarr; Project menu option.</p>
<p><b>Step 2</b> &minus; You can now see the New Project dialog box.</p>
<img src="/mfc/images/windows_application.jpg" alt="New Project Dialog Box" />
<p><b>Step 3</b> &minus; From the left pane, select Templates &rarr; Visual C++ &rarr; Win32.</p>
<p><b>Step 4</b> &minus; In the middle pane, select Win32 Project.</p>
<p><b>Step 5</b> &minus; Enter project name ‘MFCDialogDemo’ in the Name field and click OK to continue. You will see the following dialog.</p>
<img src="/mfc/images/select_win32_Project.jpg" alt="MFCDialogDemo Project" />
<p><b>Step 6</b> &minus; Click Next.</p>
<img src="/mfc/images/win32_application_setting.jpg" alt="MFCDialogDemo Setting" />
<p><b>Step 7</b> &minus; Select the options shown in the dialog box given above and click Finish.</p>
<img src="/mfc/images/mfc_window_demo.jpg" alt="MFCDialogDemo Options" />
<p><b>Step 8</b> &minus; An empty project is created.</p>
<p><b>Step 9</b> &minus; To make it a MFC project, right-click on the project and select Properties.</p>
<img src="/mfc/images/mfswindow_demo_property_page.jpg" alt="MFCDialogDemo Property" />
<p><b>Step 10</b> &minus; In the left section, click Configuration Properties &rarr; General.</p>
<p><b>Step 11</b> &minus; Select the Use MFC in Shared DLL option in Project Defaults section and click OK.</p>
<p><b>Step 12</b> &minus; Add a new source file.</p>
<p><b>Step 13</b> &minus; Right-click on your Project and select Add &rarr; New Item.</p>
<p><b>Step 14</b> &minus; In the Templates section, click C++ File (.cpp)</p>
<img src="/mfc/images/mfcwindowdemo_add_item.jpg" alt="MFCDialogDemo Add Item" />
<p><b>Step 15</b> &minus; Set the Name as Example and click Add.</p>
<p><b>Step 16</b> &minus; To create an application, we need to add a class and derive it from the MFC's CWinApp.</p>
<pre class="prettyprint notranslate">
#include &lt;afxwin.h&gt;

class CExample : public CWinApp {
   public:
      BOOL InitInstance();
};
</pre>
<h2>Dialog Box Creation</h2>
<p><b>Step 1</b> &minus; To create a dialog box, right-click on the Resource Files folder in solution explorer and select Add &rarr; Resource.</p>
<img src="/mfc/images/add_resource.jpg" alt="Add Resource" />
<p><b>Step 2</b> &minus; In the Add Resource dialog box, select Dialog and click New.</p>
<p><b>Step 3</b> &minus; A dialog box requires some preparation before actually programmatically creating it.</p>
<p><b>Step 4</b> &minus; A dialog box can first be manually created as a text file (in a resource file).</p>
<p><b>Step 5</b> &minus; You can now see the MFCDialogDemo.rc file created under Resource Files.</p>
<img src="/mfc/images/under_resource_file.jpg" alt="MFCDialogDemo FIle" />
<p><b>Step 6</b> &minus; The resource file is open in designer. The same can be opened as a text file. Rightclick on the resource file and select Open With.</p>
<img src="/mfc/images/open_with_mfcdialog_file.jpg" alt="Open With MFCDialogDemo File" />
<p><b>Step 7</b> &minus; Select the Source Code (Text) editor and click Add button.</p>
<img src="/mfc/images/source_code_editor.jpg" alt="Source Code Editor" />
<p><b>Step 8</b> &minus; Go back to the designer and right-click on the dialog and select Properties.</p>
<img src="/mfc/images/mfcdialog_select_properties.jpg" alt="DialogBox Select Properties" />
<p><b>Step 9</b> &minus; You need to choose out of the many options.</p>
<p><b>Step 10</b> &minus; Like most other controls, a dialog box must be identified. The identifier (ID) of a dialog box usually starts with IDD_, Let us change the ID to IDD_EXAMPLE_DLG.</p>
<h2>Dialog Location</h2>
<p>A dialog box must be “physically” located on an application. Because a dialog box is usually created as a parent to other controls, its location depends on its relationship to its parent window or to the desktop.</p>
<p>If you look and the Properties window, you see two fields, X Pos and Y Pos.</p>
<img src="/mfc/images/dialog_location.jpg" alt="Dialog Location" />
<ul class="list">
<li><p>X is the distance from the left border of the monitor to the left border of the dialog box.</p></li>
<li><p>Y is the distance from the top border of the monitor to the top border of the dialog box.</p></li>
</ul>
<p>By default, these fields are set to zero. You can also change as shown above.</p>
<p>If you specify these two dimensions as 0, the left and top borders of the dialog box would be set so the object appears in the center-middle of the screen.</p>
<h2>Dialog Box Dimensions</h2>
<p>The dimensions of a dialog box refer to its width and its height. You can resize the width and height with the help of mouse in designer window.</p>
<img src="/mfc/images/dialog_box_dimension.jpg" alt="Dialog Box Dimension" />
<p>You can see the changes in width and height on the Status Bar.</p>
<h2>Dialog Box Methods</h2>
<p>The base class used for displaying dialog boxes on the screen is CDialog class. To create a dialog box, we need to derive a class from CDialog. The CDialog class itself provides three constructors which are as follows &minus;</p>
<pre class="prettyprint notranslate">
CDialog();
CDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
CDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
</pre>
<p>Let us create another class CExampleDlg and derive it from CDialog. We will implement its default constructor destructor as shown in the following code.</p>
<pre class="prettyprint notranslate">
class CExampleDlg : public CDialog {
   public:
      enum { IDD = IDD_EXAMPLE_DLG };
   
      CExampleDlg();
      ~CExampleDlg();
};

CExampleDlg::CExampleDlg():CDialog(CExampleDlg::IDD) {

}

CExampleDlg::~CExampleDlg() {

}
</pre>
<p>We need to instantiate this dialog on CExample::InitInstance() method as shown in the following code.</p>
<pre class="prettyprint notranslate">
BOOL CExample::InitInstance() {
   CExampleDlg myDlg;
   m_pMainWnd = &amp;myDlg;
   
   return TRUE;
}
</pre>
<h2>Modal Dialog Boxes</h2>
<p>There are two types of dialog boxes &minus; <b>modeless</b> and <b>modal</b>. Modal and modeless dialog boxes differ by the process used to create and display them.</p>
<h3>Modeless Dialog Box</h3>
<ul class="list">
<li><p>For a modeless dialog box, you must provide your own public constructor in your dialog class.</p></li>
<li><p>To create a modeless dialog box, call your public constructor and then call the dialog object's Create member function to load the dialog resource.</p></li>
<li><p>You can call Create either during or after the constructor call. If the dialog resource has the property WS_VISIBLE, the dialog box appears immediately.</p></li>
<li><p>If not, you must call its ShowWindow member function.</p></li>
</ul>
<h3>Modal Dialog</h3>
<ul class="list">
<li><p>To create a modal dialog box, call either of the two public constructors declared in CDialog.</p></li>
<li><p>Next, call the dialog object's <b>DoModal</b> member function to display the dialog box and manage interaction with it until the user chooses OK or Cancel.</p></li>
<li><p>This management by DoModal is what makes the dialog box modal. For modal dialog boxes, DoModal loads the dialog resource.</p></li>
</ul>
<p><b>Step 1</b> &minus; To display the dialog box as modal, in the CExample::InitInstance() event call the DoModal() method using your dialog variable &minus; </p>
<pre class="prettyprint notranslate">
BOOL CExample::InitInstance() {
   CExampleDlg myDlg;
   m_pMainWnd = &amp;myDlg;
   myDlg.DoModal();
   return TRUE;
}
</pre>
<p><b>Step 2</b> &minus; Here is the complete implementation of Example.cpp file.</p>
<pre class="prettyprint notranslate">
#include &lt;afxwin.h&gt;
#include "resource.h"

class CExample : public CWinApp {
   public:
      BOOL InitInstance();
};
   
class CExampleDlg : public CDialog {
   public:
      enum { IDD = IDD_EXAMPLE_DLG };
   
      CExampleDlg();
     ~CExampleDlg();
};

CExampleDlg::CExampleDlg():CDialog(CExampleDlg::IDD) {

}

CExampleDlg::~CExampleDlg() {

}

BOOL CExample::InitInstance() {
   CExampleDlg myDlg;
   m_pMainWnd = &amp;myDlg;
   myDlg.DoModal();
   return TRUE;
}
CExample MyApp;
</pre>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following dialog box.</p>
<img src="/mfc/images/dialog_box.jpg" alt="Dialog Box" />
<h2>Dialog-Based Applications</h2>
<p>Microsoft Visual Studio provides an easier way to create an application that is mainly based on a dialog box. Here are the steps to create a dialog base project using project templates available in Visual Studio &minus; </p>
<p><b>Step 1</b> &minus; Open the Visual studio and click on the File &rarr; New &rarr; Project menu option. You can see the New Project dialog box.</p>
<img src="/mfc/images/dialog_based_project_template.jpg" alt="Dialog Based Project Template" />
<p><b>Step 2</b> &minus; From the left pane, select Templates &rarr; Visual C++ &rarr; MFC.</p>
<p><b>Step 3</b> &minus; In the middle pane, select MFC Application.</p>
<p><b>Step 4</b> &minus; Enter project name ‘MFCModalDemo’ in the Name field and click OK to continue. You will see the following dialog box.</p>
<img src="/mfc/images/mfcmodaldemo_application.jpg" alt="MFCModalDemo Application2" />
<p><b>Step 5</b> &minus; Click Next.</p>
<img src="/mfc/images/mfcmodaldemo_application_type.jpg" alt="MFCModalDemo Type" />
<p><b>Step 6</b> &minus; Select the options shown in the above dialog box and click Next.</p>
<img src="/mfc/images/mfcmodaldemo_application_options.jpg" alt="MFCModalDemo Application Options" />
<p><b>Step 7</b> &minus; Check all the options that you choose to have on your dialog box like Maximize and Minimize Boxes and click Next.</p>
<img src="/mfc/images/mfcmodaldemo_advanced_features.jpg" alt="MFCModalDemo Advanced Features" />
<p><b>Step 8</b> &minus; Click Next.</p>
<img src="/mfc/images/mfcmodaldemo_generated_classes.jpg" alt="MFCModalDemo Generated Classes" />
<p><b>Step 9</b> &minus; It will generate these two classes. You can change the name of the classes and click Finish.</p>
<p><b>Step 10</b> &minus; You can now see that the MFC wizard creates this Dialog Box and the project files by default.</p>
<img src="/mfc/images/mfcmodaldemo_wizard.jpg" alt="DialogBox Application" />
<p><b>Step 11</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/mfcmodaldemo_application_result.jpg" alt="MFCModalDemo Result" />
<h1>MFC - Windows Resources</h1>
<p>A <b>resource</b> is a text file that allows the compiler to manage objects such as pictures, sounds, mouse cursors, dialog boxes, etc. Microsoft Visual Studio makes creating a resource file particularly easy by providing the necessary tools in the same environment used to program. This means, you usually do not have to use an   external application to create or configure a resource file. Following are some important features related to resources.</p>
<ul class="list">
<li><p>Resources are interface elements that provide information to the user.</p></li>
<li><p>Bitmaps, icons, toolbars, and cursors are all resources.</p></li>
<li><p>Some resources can be manipulated to perform an action such as selecting from a menu or entering data in dialog box.</p></li>
<li><p>An application can use various resources that behave independently of each other, these resources are grouped into a text file that has the *.rc extension.</p></li>
<li><p>Most resources are created by selecting the desired one from the Add Resource dialog box.</p></li>
</ul>
<img src="/mfc/images/add_resource.jpg" alt="Add Resource" />
<ul class="list">
<li><p>The Add Resource dialog box provides an extensive list of resources which can be used as per requirements, but if you need something which is not available then you can add it manually to the *.rc file before executing the program.</p></li>
</ul>
<h2>Identifiers</h2>
<p>An <b>identifier</b> is a symbol which is a constant integer whose name usually starts with ID. It consists of two parts &minus; a text string (symbol name) mapped to an integer value (symbol value).</p>
<ul class="list">
<li><p>Symbols provide a descriptive way of referring to resources and user-interface objects, both in your source code and while you're working with them in the resource editors.</p></li>
<li><p>When you create a new resource or resource object, the <b>resource editors</b> provide a default name for the resource, for example, IDC_DIALOG1, and assign a value to it.</p></li>
<li><p>The name-plus-value definition is stored in the Resource.h file.</p></li>
</ul>
<p><b>Step 1</b> &minus; Let us look into our <b>CMFCDialogDemo</b> example from the last chapter in which we have created a dialog box and its ID is <b>IDD_EXAMPLE_DLG</b>.</p>
<img src="/mfc/images/cmfcdialog_demo.jpg" alt="CMFCDialogDemo" />
<p><b>Step 2</b> &minus; Go to the Solution Explorer, you will see the resource.h file under Header Files. Continue by opening this file in editor and you will see the dialog box identifier and its integer value as well.</p>
<img src="/mfc/images/identifier_integer_value.jpg" alt="Identifiers2" />
<h2>Icons</h2>
<p>An <b>icon</b> is a small picture used on a window which represents an application. It is used in two main scenarios.</p>
<ul class="list">
<li><p>On a Window's frame, it is displayed on the left side of the Window name on the title bar.</p></li>
<li><p>In Windows Explorer, on the Desktop, in My Computer, or in the Control Panel window.</p></li>
</ul>
<p>If you look at our MFCModalDemo example, you will see that Visual studio was using a default icon for the title bar as shown in the following snapshot.</p>
<img src="/mfc/images/icons.jpg" alt="Icons" />
<p>You can create your own icon by following the steps given below &minus;</p>
<p><b>Step 1</b> &minus; Right-click on your project and select Add &rarr; Resources, you will see the Add Resources dialog box.</p>
<img src="/mfc/images/select_add_resources.jpg" alt="Select Add Resources" />
<p><b>Step 2</b> &minus; Select Icon and click New button and you will see the following icon.</p>
<img src="/mfc/images/icon.jpg" alt="Icon" />
<p><b>Step 3</b> &minus; In Solution Explorer, go to Resource View and expand MFCModalDemo &gt; Icon. You will see two icons. The IDR_MAINFRAME is the default one and IDI_ICON1 is the newly created icon.</p>
<p><b>Step 4</b> &minus; Right-click on the newly Created icon and select Properties.</p>
<p><b>Step 5</b> &minus; IDI_ICON1 is the ID of this icon, now Let us change this ID to IDR_MYICON.</p>
<p><b>Step 6</b> &minus; You can now change this icon in the designer as per your requirements. We will use the same icon.</p>
<p><b>Step 7</b> &minus; Save this icon.</p>
<p><b>Step 8</b> &minus; Go to the CMFCModalDemoDlg constructor in CMFCModalDemoDlg.cpp file which will look like the following code.</p>
<pre class="prettyprint notranslate">
CMFCModalDemoDlg::CMFCModalDemoDlg(CWnd* pParent /* = NULL*/)
   : CDialogEx(IDD_MFCMODALDEMO_DIALOG, pParent) {
   m_hIcon = AfxGetApp() -&gt; LoadIcon(IDR_MAINFRAME);
}
</pre>
<p><b>Step 9</b> &minus; You can now see that the default icon is loaded in the constructor. Let us change it to IDR_ MYICON as shown in the following code.</p>
<pre class="prettyprint notranslate">
CMFCModalDemoDlg::CMFCModalDemoDlg(CWnd* pParent /* = NULL*/)
   : CDialogEx(IDD_MFCMODALDEMO_DIALOG, pParent) {
   m_hIcon = AfxGetApp() -&gt; LoadIcon(IDR_ MYICON);
}
</pre>
<p><b>Step 10</b> &minus; When the above code is compiled and executed, you will see the new icon is displayed on the dialog box.</p>
<img src="/mfc/images/modal_demo.jpg" alt="Modal Demo" />
<h2>Menus</h2>
<p><b>Menus</b> allow you to arrange commands in a logical and easy-to-find fashion. With the Menu editor, you can create and edit menus by working directly with a menu bar that closely resembles the one in your finished application. To create a menu, follow the steps given below &minus;</p>
<p><b>Step 1</b> &minus; Right-click on your project and select Add &rarr; Resources. You will see the Add Resources dialog box.</p>
<img src="/mfc/images/add_resource_menu.jpg" alt="Add Resources Menu" />
<p><b>Step 2</b> &minus; Select Menu and click New. You will see the rectangle that contains "Type Here" on the menu bar.</p>
<img src="/mfc/images/type_here_menu_bar.jpg" alt="Type Here on Menu Bar" />
<p><b>Step 3</b> &minus; Write some menu options like File, Edit, etc. as shown in the following snapshot.</p>
<img src="/mfc/images/menu_options.jpg" alt="Menu Options" />
<p><b>Step 4</b> &minus; If you expand the Menu folder in Resource View, you will see the Menu identifier IDR_MENU1. Right-click on this identifier and change it to IDM_MAINMENU.</p>
<img src="/mfc/images/menu_identifier.jpg" alt="Menu Identifier" />
<p><b>Step 5</b> &minus; Save all the changes.</p>
<p><b>Step 6</b> &minus; We need to attach this menu to our dialog box. Expand your Dialog folder in Solution Explorer and double click on the dialog box identifier.</p>
<img src="/mfc/images/dialog_folder.jpg" alt="Dialog Folder" />
<p><b>Step 7</b> &minus; You will see the menu field in the Properties. Select the Menu identifier from the dropdown as shown above.</p>
<p><b>Step 8</b> &minus; Run this application and you will see the following dialog box which also contains menu options.</p>
<img src="/mfc/images/menu_option.jpg" alt="Menu Option" />
<h2>Toolbars</h2>
<p>A <b>toolbar</b> is a Windows control that allows the user to perform some actions on a form by clicking a button instead of using a menu.</p>
<ul class="list">
<li><p>A toolbar provides a convenient group of buttons that simplifies the user's job by bringing the most accessible actions as buttons.</p></li>
<li><p>A toolbar can bring such common actions closer to the user.</p></li>
<li><p>Toolbars usually display under the main menu.</p></li>
<li><p>They can be equipped with buttons but sometimes their buttons or some of their buttons have a caption.</p></li>
<li><p>Toolbars can also be equipped with other types of controls.</p></li>
</ul>
<p>To create a toolbar, following are the steps.</p>
<p><b>Step 1</b> &minus; Right-click on your project and select Add &rarr; Resources. You will see the Add Resources dialog box.</p>
<img src="/mfc/images/toolbar.jpg" alt="Toolbar" />
<p><b>Step 2</b> &minus; Select Toolbar and click New. You will see the following screen.</p>
<img src="/mfc/images/select_toolbar.jpg" alt="Select Toolbar" />
<p><b>Step 3</b> &minus; Design your toolbar in the designer as shown in the following screenshot and specify the IDs as well.</p>
<img src="/mfc/images/design_toolbar.jpg" alt="Design Toolbar" />
<p><b>Step 4</b> &minus; Add these two variables in CMFCModalDemoDlg class.</p>
<pre class="prettyprint notranslate">
   CToolBar m_wndToolBar;
   BOOL butD;
</pre>
<p><b>Step 5</b> &minus; Following is the complete implementation of CMFCModalDemoDlg in CMFCModalDemoDlg.h file &minus;</p>
<pre class="prettyprint notranslate">
class CMFCModalDemoDlg : public CDialogEx {
   // Construction
   public:
      CMFCModalDemoDlg(CWnd* pParent = NULL); // standard constructor
   // Dialog Data
   #ifdef AFX_DESIGN_TIME
      enum { IDD = IDD_MFCMODALDEMO_DIALOG };
   #endif

   protected:
      virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
   
   // Implementation
   protected:
      HICON m_hIcon;
      CToolBar m_wndToolBar;
      BOOL butD;
   
      // Generated message map functions
      virtual BOOL OnInitDialog();
      afx_msg void OnPaint();
      afx_msg HCURSOR OnQueryDragIcon();
      DECLARE_MESSAGE_MAP()
	
   public:
      afx_msg void OnBnClickedOk();
};
</pre>
<p><b>Step 6</b> &minus; Update CMFCModalDemoDlg::OnInitDialog() as shown in the following code.</p>
<pre class="prettyprint notranslate">
BOOL CMFCModalDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();
   
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);       // Set big icon
   SetIcon(m_hIcon, FALSE);      // Set small icon
   
   if (!m_wndToolBar.Create(this)
      || !m_wndToolBar.LoadToolBar(IDR_TOOLBAR1))
      //if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD |
      // WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS |
      // CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
      // !m_wndToolBar.LoadToolBar(IDR_TOOLBAR1)) {
         TRACE0("Failed to Create Dialog Toolbar\n");
         EndDialog(IDCANCEL);
      }
      butD = TRUE;
      CRect rcClientOld; // Old Client Rect
      CRect rcClientNew; // New Client Rect with Tollbar Added
		
      // Retrive the Old Client WindowSize
      // Called to reposition and resize control bars in the client area of a window
      // The reposQuery FLAG does not really traw the Toolbar. It only does the calculations.
      // And puts the new ClientRect values in rcClientNew so we can do the rest of the Math.
      
      GetClientRect(rcClientOld);
      RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0, reposQuery, rcClientNew);
      // All of the Child Windows (Controls) now need to be moved so the Tollbar does not cover them up.
      // Offest to move all child controls after adding Tollbar 
      CPoint ptOffset(rcClientNew.left - rcClientOld.left, rcClientNew.top - rcClientOld.top); 
		 
      CRect rcChild;
      CWnd* pwndChild = GetWindow(GW_CHILD); //Handle to the Dialog Controls
      
      while (pwndChild) // Cycle through all child controls {
         pwndChild -&gt; GetWindowRect(rcChild); // Get the child control RECT
         ScreenToClient(rcChild);
          
         // Changes the Child Rect by the values of the claculated offset
         rcChild.OffsetRect(ptOffset);
         pwndChild -&gt; MoveWindow(rcChild, FALSE); // Move the Child Control
         pwndChild = pwndChild -&gt; GetNextWindow();
      }
       
      CRect rcWindow;
      // Get the RECT of the Dialog
      GetWindowRect(rcWindow);
       
      // Increase width to new Client Width
      rcWindow.right += rcClientOld.Width() - rcClientNew.Width();
       
      // Increase height to new Client Height
       rcWindow.bottom += rcClientOld.Height() - rcClientNew.Height();
      // Redraw Window
      MoveWindow(rcWindow, FALSE);
       
      // Now we REALLY Redraw the Toolbar
      RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, 0);
       
   // TODO: Add extra initialization here

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p><b>Step 7</b> &minus; Run this application. You will see the following dialog box which also contains the toolbar.</p>
<img src="/mfc/images/mcfmodel_toolbar.jpg" alt="Toolbar4" />
<h2>Accelerators</h2>
<p>An <b>access key</b> is a letter that allows the user to perform a menu action faster by using the keyboard instead of the mouse. This is usually faster because the user would not need to position the mouse anywhere, which reduces the time it takes to perform the action.</p>
<p><b>Step 1</b> &minus; To create an access key, type an ampersand "&amp;" on the left of the menu item.</p>
<img src="/mfc/images/create_access_key.jpg" alt="Create an Access Key" />
<p><b>Step 2</b> &minus; Repeat this step for all menu options. Run this application and press Alt. You will see that the first letter of all menu options are underlined.</p>
<img src="/mfc/images/menu_option.jpg" alt="Menu Option" />
<h3>Shortcut Key</h3>
<p>A shortcut key is a key or a combination of keys used by advanced users to perform an action that would otherwise be done on a menu item. Most shortcuts are a combination of the Ctrl key simultaneously pressed with a letter key. For example, Ctrl + N, Ctrl + O, or Ctrl + D.</p>
<p>To create a shortcut, on the right side of the string that makes up a menu caption, rightclick on the menu item and select properties.</p>
<p>In the Caption field type \t followed by the desired combination as shown below for the New menu option. Repeat the step for all menu options.</p>
<img src="/mfc/images/shortcut_key.jpg" alt="Shortcut Key" />
<h3>Accelerator Table</h3>
<p>An Accelerator Table is a list of items where each item of the table combines an identifier, a shortcut key, and a constant number that specifies the kind of accelerator key. Just like the other resources, an accelerator table can be created manually in a .rc file. Following are the steps to create an accelerator table.</p>
<p><b>Step 1</b> &minus; To create an accelerator table, right-click on *.rc file in the solution explorer.</p>
<img src="/mfc/images/create_accelerator_table.jpg" alt="Accelerator Table" />
<p><b>Step 2</b> &minus; Select Accelerator and click New.</p>
<img src="/mfc/images/select_accelerator.jpg" alt="Select Accelerator" />
<p><b>Step 3</b> &minus; Click the arrow of the ID combo box and select menu Items.</p>
<img src="/mfc/images/accelerator_table.jpg" alt="Accelerator Table" />
<p><b>Step 4</b> &minus; Select Ctrl from the Modifier dropdown.</p>
<p><b>Step 5</b> &minus; Click the Key box and type the respective Keys for both menu options.</p>
<p>We will also add New menu item event handler to testing. Right-click on the New menu option.</p>
<img src="/mfc/images/event_handler.jpg" alt="Event Handler" />
<p><b>Step 6</b> &minus; You can specify a class, message type and handler name. For now, let us leave it as it is and click Add and Edit button.</p>
<img src="/mfc/images/message_type_handler_name.jpg" alt="Message Type  Handler Name" />
<p><b>Step 7</b> &minus; Select Add Event Handler.</p>
<p><b>Step 8</b> &minus; You will now see the event added at the end of the CMFCModalDemoDlg.cpp file.</p>
<pre class="prettyprint notranslate">
void CMFCModalDemoDlg::OnFileNew() {
   // TODO: Add your command handler code here
   MessageBox(L"File &gt; New menu option");
}
</pre>
<p><b>Step 9</b> &minus; <b>Now</b> Let us add a message box that will display the simple menu option message.</p>
<p>To start accelerator table in working add the HACCEL variable and ProcessMessageFilter as shown in the following CMFCModalDemoApp.</p>
<pre class="prettyprint notranslate">
class CMFCModalDemoApp : public CWinApp {
   public:
      CMFCModalDemoApp();
   
   // Overrides
   public:
      virtual BOOL InitInstance();
      HACCEL m_hAccelTable;
      
      // Implementation

      DECLARE_MESSAGE_MAP()
      virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);
};
</pre>
<p><b>Step 10</b> &minus; Load Accelerator and the following call in the CMFCModalDemoApp::InitInstance().</p>
<pre class="prettyprint notranslate">
m_hAccelTable = LoadAccelerators(AfxGetInstanceHandle(),
   MAKEINTRESOURCE(IDR_ACCELERATOR1));
</pre>
<p><b>Step 11</b> &minus; Here is the implementation of ProcessMessageFilter.</p>
<pre class="prettyprint notranslate">
BOOL CMFCModalDemoApp::ProcessMessageFilter(int code, LPMSG lpMsg) {
   if (code &gt;= 0 &amp;&amp; m_pMainWnd &amp;&amp; m_hAccelTable) {
      if (::TranslateAccelerator(m_pMainWnd -&gt; m_hWnd, m_hAccelTable, lpMsg))
      return TRUE;
   }
   return CWinApp::ProcessMessageFilter(code, lpMsg);
}
</pre>
<p><b>Step 12</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/mcfmodel_toolbar.jpg" alt="Accelerator Result" />
<p><b>Step 13</b> &minus; Press Alt button followed by F key and then N key or Ctrl + N. You will see the following message.</p>
<img src="/mfc/images/accelerator_message.jpg" alt="Accelerator Table" />
<h1>MFC - Property Sheets</h1>
<p>A <b>property sheet</b>, also known as a tab dialog box, is a dialog box that contains property pages. Each property page is based on a dialog template resource and contains controls. It is enclosed on a page with a tab on top. The tab names the page and indicates its purpose. Users click a tab in the property sheet to select a set of controls.</p>
<p>To create property pages, let us look into a simple example by creating a dialog based MFC project.</p>
<img src="/mfc/images/mfcprosheetdemo.jpg" alt="MFC Project" />
<p>Once the project is created, we need to add some property pages.</p>
<p>Visual Studio makes it easy to create resources for property pages by displaying the Add Resource dialog box, expanding the Dialog node and selecting one of the IDD_PROPPAGE_X items.</p>
<p><b>Step 1</b> &minus; Right-click on your project in solution explorer and select Add &rarr; Resources.</p>
<img src="/mfc/images/idd_propage_larg.jpg" alt="IDD Propage Larg" />
<p><b>Step 2</b> &minus; Select the IDD_PROPPAGE_LARGE and click NEW.</p>
<img src="/mfc/images/idd_propage_larg_new.jpg" alt="IDD Propage Larg New" />
<p><b>Step 3</b> &minus; Let us change ID and Caption of this property page to <b>IDD_PROPPAGE_1</b> and <b>Property Page 1</b> respectively as shown above.</p>
<p><b>Step 4</b> &minus; Right-click on the property page in designer window.</p>
<img src="/mfc/images/propage_designer_window.jpg" alt="Propage in Designer Window" />
<p><b>Step 5</b> &minus; Select the Add Class option.</p>
<img src="/mfc/images/propage_add_class_option.jpg" alt="Propage Add Class Option" />
<p><b>Step 6</b> &minus; Enter the class name and select CPropertyPage from base class dropdown list.</p>
<p><b>Step 7</b> &minus; Click Finish to continue.</p>
<p><b>Step 8</b> &minus; Add one more property page with ID IDD_PROPPAGE_2 and Caption Property Page 2 by following the above mentioned steps.</p>
<p><b>Step 9</b> &minus; You can now see two property pages created. To implement its functionality, we need a property sheet.</p>
<p>The Property Sheet groups the property pages together and keeps it as entity.</p>
<p>To create a property sheet, follow the steps given below &minus;</p>
<p><b>Step 1</b> &minus; Right-click on your project and select Add &gt; Class menu options.</p>
<img src="/mfc/images/create_property_sheet.jpg" alt="Create Property Sheet" />
<p><b>Step 2</b> &minus; Select Visual C++ &rarr; MFC from the left pane and MFC Class in the template pane and click Add.</p>
<img src="/mfc/images/mfc_class_template_pane.jpg" alt="MFC Class in Template Pane" />
<p><b>Step 3</b> &minus; Enter the class name and select CPropertySheet from base class dropdown list.</p>
<p><b>Step 4</b> &minus; Click finish to continue.</p>
<p><b>Step 5</b> &minus; To launch this property sheet, we need the following changes in our main project class.</p>
<p><b>Step 6</b> &minus; Add the following references in CMFCPropSheetDemo.cpp file.</p>
<pre class="prettyprint notranslate">
#include "MySheet.h"
#include "PropPage1.h"
#include "PropPage2.h"
</pre>
<p><b>Step 7</b> &minus; Modify the CMFCPropSheetDemoApp::InitInstance() method as shown in the following code.</p>
<pre class="prettyprint notranslate">
CMySheet mySheet(L"Property Sheet Demo");
CPropPage1 page1;
CPropPage2 page2;

mySheet.AddPage(&amp;page1);
mySheet.AddPage(&amp;page2);

m_pMainWnd = &amp;mySheet;
INT_PTR nResponse = mySheet.DoModal();
</pre>
<p><b>Step 8</b> &minus; Here is the complete implementation of CMFCPropSheetDemo.cpp file.</p>
<pre class="prettyprint notranslate">

// MFCPropSheetDemo.cpp : Defines the class behaviors for the application.
//
#include "stdafx.h"
#include "MFCPropSheetDemo.h"
#include "MFCPropSheetDemoDlg.h"
#include "MySheet.h"
#include "PropPage1.h"
#include "PropPage2.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMFCPropSheetDemoApp
BEGIN_MESSAGE_MAP(CMFCPropSheetDemoApp, CWinApp)
   ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)
END_MESSAGE_MAP()


// CMFCPropSheetDemoApp construction

CMFCPropSheetDemoApp::CMFCPropSheetDemoApp() {

   // support Restart Manager
   m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;
   // TODO: add construction code here,
   // Place all significant initialization in InitInstance
}


// The one and only CMFCPropSheetDemoApp object

CMFCPropSheetDemoApp theApp;


// CMFCPropSheetDemoApp initialization

BOOL CMFCPropSheetDemoApp::InitInstance() {
   
   // InitCommonControlsEx() is required on Windows XP if an application
   // manifest specifies use of ComCtl32.dll version 6 or later to enable
   // visual styles. Otherwise, any window creation will fail.
   INITCOMMONCONTROLSEX InitCtrls;
   InitCtrls.dwSize = sizeof(InitCtrls);
   // Set this to include all the common control classes you want to use
   // in your application.
   InitCtrls.dwICC = ICC_WIN95_CLASSES;
   InitCommonControlsEx(&amp;InitCtrls);
   
   CWinApp::InitInstance();
   
   
   AfxEnableControlContainer();
   
   // Create the shell manager, in case the dialog contains
   // any shell tree view or shell list view controls.
   CShellManager *pShellManager = new CShellManager;

   // Activate "Windows Native" visual manager for enabling themes in MFC controls
   CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));
   // Standard initialization
   // If you are not using these features and wish to reduce the size
   // of your final executable, you should remove from the following
   // the specific initialization routines you do not need
   // Change the registry key under which our settings are stored
   // TODO: You should modify this string to be something appropriate
   // such as the name of your company or organization
   SetRegistryKey(_T("Local AppWizard-Generated Applications"));
   
   CMySheet mySheet(L"Property Sheet Demo");
   CPropPage1 page1;
   CPropPage2 page2;
   
   mySheet.AddPage(&amp;page1);
   mySheet.AddPage(&amp;page2);
   
   m_pMainWnd = &amp;mySheet;
   INT_PTR nResponse = mySheet.DoModal();
   if (nResponse == IDOK) {
      // TODO: Place code here to handle when the dialog is
      // dismissed with OK
   }else if (nResponse == IDCANCEL) {
      // TODO: Place code here to handle when the dialog is
      // dismissed with Cancel
   }else if (nResponse == -1) {    
      TRACE(traceAppMsg, 0, "Warning: dialog creation failed, 
        so application is terminating unexpectedly.\n");
      TRACE(traceAppMsg, 0, "Warning: if you are using MFC controls on the dialog, 
        you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\n");
   }

   // Delete the shell manager created above.
   if (pShellManager != NULL) {
      delete pShellManager;
   }

   // Since the dialog has been closed, return FALSE so that we exit the
   // application, rather than start the application's message pump.
   return FALSE;
}
</pre>
<p><b>Step 9</b> &minus; When the above code is compiled and executed, you will see the following dialog box. This dialog box contains two property pages.</p>
<img src="/mfc/images/property_pages.jpg" alt="Property Pages" />
<h1>MFC - Windows Layout</h1>
<p><b>Layout of controls</b> is very important and critical for application usability. It is used to arrange a group of GUI elements in your application. There are certain important things to consider while selecting layout &minus; </p>
<ul class="list">
<li>Positions of the child elements.</li>
<li>Sizes of the child elements.</li>
</ul>
<h2>Adding controls</h2>
<p>Let us create new Dialog based MFC Project MFCLayoutDemo.</p>
<p><b>Step 1</b> &minus; Once the project is created, you will see the following screen.</p>
<img src="/mfc/images/create_adding_controls.jpg" alt="Create Adding Controls" />
<p><b>Step 2</b> &minus; Delete the TODO from the dialog box.</p>
<p><b>Step 3</b> &minus; Drag some controls from the Toolbox which you can see on the left side.</p>
<p>(We will drag one Static Text and one Edit Control as shown in the following snapshot).</p>
<img src="/mfc/images/mfclayoutdemo_edit_control.jpg" alt="MFCLayoutDemo Edit" />
<p><b>Step 4</b> &minus; Change the Caption of the Static Text to Name.</p>
<img src="/mfc/images/static_text_name.jpg" alt="Static Text to Name" />
<h2>Control Grid</h2>
<p>Control grid is the guiding grid dots, which can help in positioning of the controls you are adding at the time of designing.</p>
<p>To enable the control grid, you need to click the Toggle Grid button in the toolbar as shown in the following snapshot.</p>
<img src="/mfc/images/control_grid.jpg" alt="Control Grid" />
<h2>Controls Resizing</h2>
<p>After you have added a control to a dialog box, it assumes either its default size or the size you drew it with. To help with the sizes of controls on the form or dialog box, Visual Studio provides a visual grid made of black points.</p>
<p>To resize a control, that is, to give it a particular width or height, position the mouse on one of the handles and drag it in the desired direction.</p>
<img src="/mfc/images/control_resizing.jpg" alt="Control Resizing" />
<p>You can now resize the controls with the help of this dotted grid.</p>
<h2>Controls Positions</h2>
<p>The controls you position on a dialog box or a form assume their given place. Most of the time, these positions are not practical. You can move them around to any position of your choice.</p>
<p>Let us add some more controls &minus;</p>
<img src="/mfc/images/control_position.jpg" alt="Control Position" />
<p><b>Step 1</b> &minus; To move a control, click and drag it in the desired direction until it reaches the intended position.</p>
<p><b>Step 2</b> &minus; To move a group of controls, first select them. Then drag the selection to the desired location. Let us select the Static Texts and Edit Controls.</p>
<img src="/mfc/images/static_texts_edit_controls.jpg" alt="Static Texts and Edit Controls" />
<p><b>Step 3</b> &minus; Move these selected controls to the left side.</p>
<img src="/mfc/images/move_selected_control.jpg" alt="Move Selecred Control" />
<p></p>
<img src="/mfc/images/move_selected_controls.jpg" alt="Move Selecred Control" />
<p>To help with positioning the controls, Visual Studio provides the Dialog toolbar with the following buttons.</p>
<img src="/mfc/images/dialog_toolbar.jpg" alt="Control Position5" />
<p><b>Step 1</b> &minus; Let us align the Check box and Static Text controls to the left by selecting all these controls.</p>
<img src="/mfc/images/select_align_format.jpg" alt="Align Format" />
<p><b>Step 2</b> &minus; Select the Format &rarr; Align &rarr; Lefts.</p>
<img src="/mfc/images/align_format_left.jpg" alt="Align Left" />
<p><b>Step 3</b> &minus; You can now see all these controls are aligned to the left.</p>
<h2>Tab Ordering</h2>
<p>The controls you add to a form or a dialog box are positioned in a sequence that follows the order they were added. When you add control(s) regardless of the section or area you place the new control, it is sequentially positioned at the end of the existing controls. If you do not fix it, the user would have a hard time navigating the controls. The sequence of controls navigation is also known as the tab order.</p>
<p>To change the tab, you can either use the Format &rarr; Tab Order menu option or you can also use the Ctrl + D shortcut. Let us press Ctrl + D.</p>
<img src="/mfc/images/tab_ordering.jpg" alt="Tab Ordering" />
<p>You can now see the order in which all these controls are added to this dialog box. To Change the order or sequence of controls, click on all the controls in sequence in which you want to navigate.</p>
<p>In this example, we will first click on the checkbox followed by Name and Address Edit controls. Then click OK and Cancel as shown in the following snapshot.</p>
<img src="/mfc/images/tab_order.jpg" alt="Table Ordering" />
<p>Let us run this application and you will see the following output.</p>
<img src="/mfc/images/tab_ordering_result.jpg" alt="Tab Ordering Result" />
<h1>MFC - Controls Management</h1>
<p>In MFC applications, after visually adding a control to your application, if you want to refer to it in your code, you can declare a variable based on, or associated with that control. The MFC library allows you to declare two types of variables for some of the controls used in an application a value or a control variable.</p>
<ul class="list">
<li><p>One variable is used for the information stored in the control, which is also known as <b>Control Variable/Instance</b>.</p></li>
<li><p>The other variable is known as <b>Control Value Variable</b>. A user can perform some sort of actions on that control with this variable.</p></li>
</ul>
<h2>Control Variable/Instance</h2>
<p>A control variable is a variable based on the class that manages the control. For example, a button control is based on the CButton class.</p>
<p>To see these concepts in real programming, let us create an MFC dialog based project MFCControlManagement.</p>
<img src="/mfc/images/mfc_control_management.jpg" alt="MFCControlManagement" />
<p>Once the project is created, you will see the following dialog box in designer window.</p>
<img src="/mfc/images/mfccontrolmanagement_created.jpg" alt="MFCControlManagement Created" />
<p><b>Step 1</b> &minus; Delete the TODO line and drag one checkbox and one Edit control as shown in the following snapshot. Change the caption of checkbox to Enable Control.</p>
<img src="/mfc/images/change_caption.jpg" alt="Change Caption" />
<p><b>Step 2</b> &minus; Right-click on the checkbox.</p>
<img src="/mfc/images/mfccontrolmanagement_checkbox.jpg" alt="MFCControlManagement Checkbox" />
<p><b>Step 3</b> &minus; Select Add Variable.</p>
<p><b>Step 4</b> &minus; You can now see the Add Member Variable Wizard.</p>
<img src="/mfc/images/add_member_variable.jpg" alt="Add Member Variable" />
<p>You can select different options on this dialog box. For checkbox, the variable type is CButton. It is selected by default in this dialog box.</p>
<p>Similarly, the control ID is also selected by default now we need to select Control in the Category combo box, and type m_enableDisableCheck in the Variable Name edit box and click finish.</p>
<p><b>Step 5</b> &minus; Similarly, add Control Variable of Edit control with the settings as shown in the following snapshot.</p>
<img src="/mfc/images/edit_control_variables.jpg" alt="Control Variables6" />
<p>Observe the header file of the dialog class. You can see that the new variables have been added now.</p>
<pre class="prettyprint notranslate">
CButton m_enableDisableCheck;
CEdit m_myEditControl;
</pre>
<h2>Control Value Variable</h2>
<p>Another type of variable you can declare for a control is the value variable. Not all controls provide a value variable.</p>
<ul class="list">
<li><p>The value variable must be able to handle the type of value stored in the control it is intended to refer to.</p></li>
<li><p>For example, because a text based control is used to handle text, you can declare a text-based data type for it. This would usually be a CString variable.</p></li>
</ul>
<p>Let us look into this type of variable for checkbox and edit control.</p>
<p><b>Step 1</b> &minus; Right-click on the checkbox and select Add Variable.</p>
<img src="/mfc/images/add_variable.jpg" alt="Add Variable" />
<p><b>Step 2</b> &minus; The Variable type is BOOL. Select Value from the Category dropdown list.</p>
<p><b>Step 3</b> &minus; Click Finish to continue.</p>
<p><b>Step 4</b> &minus; Similarly, add value Variable for Edit control with the settings as shown in the following snapshot.</p>
<img src="/mfc/images/value_variable_edit_control.jpg" alt="Value Variables" />
<p><b>Step 5</b> &minus; Type CString in variable type and m_editControlVal in the variable name field.</p>
<p><b>Step 6</b> &minus; You can now see these variables added in the Header file.</p>
<pre class="prettyprint notranslate">
bool m_enableDisableVal;
CString m_editControlVal;
</pre>
<h2>Controls Event Handlers</h2>
<p>After adding a control to your application, whether you visually added it or created it dynamically, you will also decide how to handle the possible actions that the user can perform on the control.</p>
<ul class="list">
<li><p>For project dialog boxes that are already associated with a class, you can take advantage of some shortcuts when you create event handlers.</p></li>
<li><p>You can quickly create a handler either for the default control notification event or for any applicable Windows message.</p></li>
</ul>
<p>Let us look into the same example in which we added event handler for checkbox.</p>
<p><b>Step 1</b> &minus; Right-click the control for which you want to handle the notification event.</p>
<img src="/mfc/images/handle_notification_event.jpg" alt="Event Handler1" />
<p><b>Step 2</b> &minus; On the shortcut menu, click Add Event Handler to display the Event Handler Wizard.</p>
<img src="/mfc/images/event_handler_wizard.jpg" alt="Event Handler Wizard" />
<p><b>Step 3</b> &minus; Select the event in the Message type box to add to the class selected in the Class list box.</p>
<p><b>Step 4</b> &minus; Accept the default name in the Function handler name box, or provide the name of your choice.</p>
<p><b>Step 5</b> &minus; Click Add and edit to add the event handler.</p>
<p><b>Step 6</b> &minus; You can now see the following event added at the end of CMFCControlManagementDlg.cpp file.</p>
<pre class="prettyprint notranslate">
void CMFCControlManagementDlg::OnBnClickedCheck1() {
   // TODO: Add your control notification handler code here
}
</pre>
<h2>Controls Management</h2>
<p>So far, we have seen how to add controls to an application. We will now see how to manage these controls as per user requirement. We can use the control variable/instance in a particular event handler.</p>
<p><b>Step 1</b> &minus; Let us look into the following example. Here, we will enable/disable the edit control when the checkbox is checked/unchecked.</p>
<p><b>Step 2</b> &minus; We have now added the checkbox click event handler. Here is the implementation &minus;</p>
<pre class="prettyprint notranslate">
void CMFCControlManagementDlg::OnBnClickedCheck1() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   if (m_enableDisableVal)
      m_myEditControl.EnableWindow(TRUE);
   else
      m_myEditControl.EnableWindow(FALSE);
}
</pre>
<p><b>Step 3</b> &minus; When the dialog is created, we need to add the following code to CMFCControlManagementDlg::OnInitDialog(). This will manage these controls.</p>
<pre class="prettyprint notranslate">
UpdateData(TRUE);
if (m_enableDisableVal)
   m_myEditControl.EnableWindow(TRUE);
else
   m_myEditControl.EnableWindow(FALSE);
</pre>
<p><b>Step 4</b> &minus; Here is the complete implementation of CMFCControlManagementDlg.cpp file.</p>
<pre class="prettyprint notranslate">
// MFCControlManagementDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MFCControlManagement.h"
#include "MFCControlManagementDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CAboutDlg dialog used for App About

class CAboutDlg : public CDialogEx {
   public:
      CAboutDlg();
	
   // Dialog Data
   #ifdef AFX_DESIGN_TIME
      enum { IDD = IDD_ABOUTBOX };
   #endif

   protected:
      virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
      
   // Implementation
   protected:
      DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX) {

}
void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
   CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()

// CMFCControlManagementDlg dialog


CMFCControlManagementDlg::CMFCControlManagementDlg(CWnd* pParent /* = NULL*/)
   :CDialogEx(IDD_MFCCONTROLMANAGEMENT_DIALOG, pParent) , 
   m_enableDisableVal(FALSE) , m_editControlVal(_T("")) {
   m_hIcon = AfxGetApp()&rarr LoadIcon(IDR_MAINFRAME);
}

void CMFCControlManagementDlg::DoDataExchange(CDataExchange* pDX) {
   CDialogEx::DoDataExchange(pDX);
   DDX_Control(pDX, IDC_CHECK1, m_enableDisableCheck);
   DDX_Control(pDX, IDC_EDIT1, m_myEditControl);
   DDX_Check(pDX, IDC_CHECK1, m_enableDisableVal);
   DDX_Text(pDX, IDC_EDIT1, m_editControlVal);
}
BEGIN_MESSAGE_MAP(CMFCControlManagementDlg, CDialogEx)
   ON_WM_SYSCOMMAND()
   ON_WM_PAINT()
   ON_WM_QUERYDRAGICON()
   ON_BN_CLICKED(IDC_CHECK1, &amp;CMFCControlManagementDlg::OnBnClickedCheck1)
END_MESSAGE_MAP()

// CMFCControlManagementDlg message handlers

BOOL CMFCControlManagementDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();
      
   // Add "About..." menu item to system menu.
   // IDM_ABOUTBOX must be in the system command range.
   ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);
   ASSERT(IDM_ABOUTBOX &lt; 0xF000);
      
   CMenu* pSysMenu = GetSystemMenu(FALSE);
   if (pSysMenu != NULL) {
      BOOL bNameValid;
      CString strAboutMenu;
      bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
      ASSERT(bNameValid);
      if (!strAboutMenu.IsEmpty()) {
         pSysMenu &rarr; AppendMenu(MF_SEPARATOR);
         pSysMenu &rarr; AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
      }
   }
	
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);        // Set big icon
   SetIcon(m_hIcon, FALSE);       // Set small icon

   // TODO: Add extra initialization here
   UpdateData(TRUE);
   if (m_enableDisableVal)
      m_myEditControl.EnableWindow(TRUE);
   else
      m_myEditControl.EnableWindow(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
void CMFCControlManagementDlg::OnSysCommand(UINT nID, LPARAM lParam) {
   if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) {
      CAboutDlg dlgAbout;
      dlgAbout.DoModal();
   }else {
      CDialogEx::OnSysCommand(nID, lParam);
   }
}

// If you add a minimize button to your dialog, you will need the code below
// to draw the icon. For MFC applications using the document/view model,
// this is automatically done for you by the framework.

void CMFCControlManagementDlg::OnPaint() {
   if (IsIconic()) {
      CPaintDC dc(this); // device context for painting
      
      SendMessage(WM_ICONERASEBKGND,
         reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);
			
      // Center icon in client rectangle
      int cxIcon = GetSystemMetrics(SM_CXICON);
      int cyIcon = GetSystemMetrics(SM_CYICON);
      CRect rect;
      GetClientRect(&amp;rect);
      int x = (rect.Width() - cxIcon + 1) / 2;
      int y = (rect.Height() - cyIcon + 1) / 2;
		
      // Draw the icon
      dc.DrawIcon(x, y, m_hIcon);
   }else {
      CDialogEx::OnPaint();
   }
}

// The system calls this function to obtain the cursor to display while the user drags
// the minimized window.
HCURSOR CMFCControlManagementDlg::OnQueryDragIcon() {
   return static_cast&lt;HCURSOR&gt;(m_hIcon);
}

void CMFCControlManagementDlg::OnBnClickedCheck1() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   if (m_enableDisableVal)
      m_myEditControl.EnableWindow(TRUE);
   else
      m_myEditControl.EnableWindow(FALSE);
}
</pre>
<p><b>Step 5</b> &minus; When the above code is compiled and executed, you will see the following output. The checkbox is unchecked by default. This disables the edit control too.</p>
<img src="/mfc/images/controls_management.jpg" alt="Controls Management" />
<p><b>Step 6</b> &minus; Check the Enable Control checkbox. This will automatically enable the edit control.</p>
<img src="/mfc/images/control_management.jpg" alt="Control Management" />
<h1>MFC - Windows Control</h1>
<p><b>Windows controls</b> are objects that users can interact with to enter or manipulate data. They commonly appear in dialog boxes or on toolbars. There are various types of controls &minus;</p>
<ul class="list">
<li><p>A <b>text based control</b> which is used to display text to the user or request text from the user.</p></li>
<li><p>A <b>list based control</b> displays a list of items.</p></li>
<li><p>A <b>progress based control</b> is used to show the progress of an action.</p></li>
<li><p>A <b>static control</b> can be used to show colors, a picture or something that does not regularly fit in the above categories.</p></li>
</ul>
<table class="table table-bordered">
<tr>
<th>Sr.No.</th>
<th style="text-align:center;">Controls &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><a href="/mfc/mfc_static_control.htm">Static Control</a>
<p>A static control is an object that displays information to the user without his or her direct intervention. It can be used to show colors, a geometric shape, or a picture such as an icon, a bitmap, or an animation.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><a href="/mfc/mfc_animation_control.htm">Animation Control</a>
<p>An animation control is a window that displays an Audio clip in AVI format. An AVI clip is a series of bitmap frames, like a movie. Animation controls can only play simple AVI clips, and they do not support sound. It is represented by the <b>CAnimateCtrl</b> class.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><a href="/mfc/mfc_button.htm">Button</a>
<p>A <b>button</b> is an object that the user clicks to initiate an action. Button control is represented by <b>CButton class</b>.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><a href="/mfc/mfc_bitmap_button.htm">Bitmap Button</a>
<p>A <b>bitmap button</b> displays a picture or a picture and text on its face. This is usually intended to make the button a little explicit. A bitmap button is created using the <b>CBitmapButton class</b>, which is derived from CButton.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><a href="/mfc/mfc_command_button.htm">Command Button</a>
<p>A <b>command button</b> is an enhanced version of the regular button. It displays a green arrow icon on the left, followed by a caption in regular size. Under the main caption, it can display another smaller caption that serves as a hint to provide more information.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><a href="/mfc/mfc_static_text.htm">Static Text</a>
<p>A <b>static control</b> displays a text string, box, rectangle, icon, cursor, bitmap, or enhanced metafile. It is represented by <b>CStatic class</b>. It can be used to label, box, or separateother controls. A static control normally takes no input and provides no output.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><a href="/mfc/mfc_list_box.htm">List Box</a>
<p>A <b>list box</b> displays a list of items, such as filenames, that the user can view and select. A List box is represented by <b>CListBox class</b>. In a single-selection list box, the user can select only one item. In a multiple-selection list box, a range of items can be selected. When the user selects an item, it is highlighted and the list box sends a notification message to the parent window.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><a href="/mfc/mfc_combo_boxes.htm">Combo Boxes</a>
<p>A <b>combo box</b> consists of a list box combined with either a static control or edit control. it is represented by <b>CComboBox class</b>. The list-box portion of the control may be displayed at all times or may only drop down when the user selects the drop-down arrow next to the control.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><a href="/mfc/mfc_radio_buttons.htm">Radio Buttons</a>
<p>A <b>radio button</b> is a control that appears as a dot surrounded by a round box. In reality, a radio button is accompanied by one or more other radio buttons that appear and behave as a group.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><a href="/mfc/mfc_checkboxes.htm">Checkboxes</a>
<p>A checkbox is a Windows control that allows the user to set or change the value of an item as true or false.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><a href="/mfc/mfc_image_lists.htm">Image Lists</a>
<p>An <b>Image List</b> is a collection of same-sized images, each of which can be referred to by its zero-based index. Image lists are used to efficiently manage large sets of icons or bitmaps. Image lists are represented by <b>CImageList class</b>.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><a href="/mfc/mfc_edit_box.htm">Edit Box</a>
<p>An <b>Edit Box</b> is a rectangular child window in which the user can enter text. It is represented by <b>CEdit class</b>.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><a href="/mfc/mfc_rich_edit.htm">Rich Edit</a>
<p>A <b>Rich Edit</b> Control is a window in which the user can enter and edit text. The text can be assigned character and paragraph formatting, and can include embedded OLE objects. It is represented by <b>CRichEditCtrl class</b>.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><a href="/mfc/mfc_group_box.htm">Group Box</a>
<p>A <b>group box</b> is a static control used to set a visible or programmatic group of controls. The control is a rectangle that groups other controls together.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><a href="/mfc/mfc_spin_button.htm">Spin Button</a>
<p>A <b>Spin Button</b> Control (also known as an up-down control) is a pair of arrow buttons that the user can click to increment or decrement a value, such as a scroll position or a number displayed in a companion control. it is represented by <b>CSpinButtonCtrl class</b>.</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><a href="/mfc/mfc_managing_updown_control.htm">Managing the Updown Control</a>
<p>It manages the Updown Controls.</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><a href="/mfc/mfc_progress_control.htm">Progress Control</a>
<p>A <b>progress bar control</b> is a window that an application can use to indicate the progress of a lengthy operation. It consists of a rectangle that is gradually filled, from left to right, with the system highlight color as an operation progresses. It is represented by <b>CProgressCtrl class</b>.</p></td>
</tr>
<tr>
<td class="ts">18</td>
<td><a href="/mfc/mfc_progress_bars.htm">Progress Bars</a>
<p>A <b>progress bars</b> is a window that an application can use to indicate the progress of a operation.</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><a href="/mfc/mfc_timer.htm">Timer</a>
<p>A <b>timer</b> is a non-spatial object that uses recurring lapses of time from a computer or fromyour application. To work, every lapse of period, the control sends a message to the operating system. Unlike most other controls, the MFC timer has neither a button to represent it nor a class. To create a timer, you simply call the CWnd::SetTimer() method. This function call creates a timer for your application. Like the other controls, a timer uses an identifier.</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><a href="/mfc/mfc_date_time_picker.htm">Date &amp; Time Picker</a>
<p>The date and time picker control (<b>CDateTimeCtrl</b>) implements an intuitive and recognizable method of entering or selecting a specific date. The main interface of the control is similar in functionality to a combo box. However, if the user expands the control, a month calendar control appears (by default), allowing the user to specify a particular date. When a date is chosen, the month calendar control automatically disappears.</p></td>
</tr>
<tr>
<td class="ts">21</td>
<td><a href="/mfc/mfc_picture.htm">Picture</a>
<p>If you need to display a picture for your application, Visual C++ provides a special control for that purpose.</p></td>
</tr>
<tr>
<td class="ts">22</td>
<td><a href="/mfc/mfc_image_editor.htm">Image Editor</a>
<p>The <b>Image editor</b> has an extensive set of tools for creating and editing images, as wellas features to help you create toolbar bitmaps. In addition to bitmaps, icons, and cursors, you can edit images in GIF or JPEG format using commands on the Image menu and tools on the Image Editor Toolbar.</p></td>
</tr>
<tr>
<td class="ts">23</td>
<td><a href="/mfc/mfc_slider_controls.htm">Slider Controls</a>
<p>A <b>Slider Control</b> (also known as a trackbar) is a window containing a slider and optional tick marks. When the user moves the slider, using either the mouse or the direction keys, the control sends notification messages to indicate the change. There are two types of sliders &minus; horizontal and vertical. It is represented by <b>CSliderCtrl class</b>.</p></td>
</tr>
<tr>
<td class="ts">24</td>
<td><a href="/mfc/mfc_scrollbars.htm">Scrollbars</a>
<p>A <b>scrollbar</b> is a graphical control element with which continuous text, pictures or anything else can be scrolled in two directions along a control by clicking an arrow. This control can assume one of two directions &minus; horizontal or vertical. It is represented by <b>CScrollBar</b> class.</p></td>
</tr>
<tr>
<td class="ts">25</td>
<td><a href="/mfc/mfc_tree_control.htm">Tree Control</a>
<p>A <b>Tree View Control</b> is a window that displays a hierarchical list of items, such as the headings in a document, the entries in an index, or the files and directories on a disk. Each item consists of a label and an optional bitmapped image, and each item can have a list of subitems associated with it. By clicking an item, the user can expand and collapse the associated list of subitems. It is represented by <b>CTreeCtrl</b> class.</p></td>
</tr>
<tr>
<td class="ts">26</td>
<td><a href="/mfc/mfc_list_control.htm">List Control</a>
<p>Encapsulates the functionality of a List View Control, which displays a collection of items each consisting of an icon (from an image list) and a label. It is represented by <b>CListCtrl</b> class. A list control consists of using one of four views to display a list of items.</p></td>
</tr>
</table>
<h1>MFC - Messages &amp; Events</h1>
<p>An application is made of various objects. Most of the time, more than one application is running on the computer and the operating system is constantly asked to perform some assignments. Because there can be so many requests presented unpredictably, the operating system leaves it up to the objects to specify what they want, when they want it, and what behavior or result they expect.</p>
<h2>Overview</h2>
<ul class="list">
<li><p>The Microsoft Windows operating system cannot predict what kinds of requests one object would need to be taken care of and what type of assignment another object would need.</p></li>
<li><p>To manage all these assignments and requests, the objects send messages.</p></li>
<li><p>Each object has the responsibility to decided what message to send and when.</p></li>
<li><p>In order to send a message, a control must create an event.</p></li>
<li><p>To make a distinction between the two, a message's name usually starts with WM_ which stands for Window Message.</p></li>
<li><p>The name of an event usually starts with On which indicates an action.</p></li>
<li><p>The event is the action of sending the message.</p></li>
</ul>
<h2>Map of Messages</h2>
<p>Since Windows is a message-oriented operating system, a large portion of programming for the Windows environment involves message handling. Each time an event such as a keystroke or mouse click occurs, a message is sent to the application, which must then handle the event.</p>
<ul class="list">
<li><p>For the compiler to manage messages, they should be included in the class definition.</p></li>
<li><p>The <b>DECLARE_MESSAGE_MAP</b> macro should be provided at the end of the class definition as shown in the following code.</p></li>
</ul>
<pre class="prettyprint notranslate">
class CMainFrame : public CFrameWnd {
   public:
      CMainFrame();
   protected:
      DECLARE_MESSAGE_MAP()
};
</pre>
<ul class="list">
<li><p>The actual messages should be listed just above the DECLARE_MESSAGE_MAP line.</p></li>
<li><p>To implement the messages, you need to create a table of messages that your program is using.</p></li>
<li><p>This table uses two delimiting macros;</p></li>
<li><p>Its starts with a <b>BEGIN_MESSAGE_MAP</b> and ends with an <b>END_MESSAGE_MAP</b> macros.</p></li>
<li><p>The BEGIN_MESSAGE_MAP macro takes two arguments, the name of your class and the MFC class you derived your class from as shown in the following code.</p></li>
</ul>
<pre class="prettyprint notranslate">
#include &lt;afxwin.h&gt;
class CMainFrame : public CFrameWnd {
   public:
      CMainFrame();
   protected:
      DECLARE_MESSAGE_MAP()
};
CMainFrame::CMainFrame() {

   // Create the window's frame
   Create(NULL, L"MFC Messages Demo", WS_OVERLAPPEDWINDOW,
                                      CRect(120, 100, 700, 480), NULL);
}
class CMessagesApp : public CWinApp {
   public:
      BOOL InitInstance();
};
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
END_MESSAGE_MAP()
BOOL CMessagesApp::InitInstance(){
   m_pMainWnd = new CMainFrame;
   m_pMainWnd-&gt;ShowWindow(SW_SHOW);
   m_pMainWnd-&gt;UpdateWindow();
   return TRUE;
}
CMessagesApp theApp;
</pre>
<p>Let us look into a simple example by creating a new Win32 project.</p>
<img src="/mfc/images/win32_project.jpg" alt="Win32 Project" />
<p><b>Step 1</b> &minus; To create an MFC project, right-click on the project and select Properties.</p>
<p><b>Step 2</b> &minus; In the left section, click Configuration Properties &rarr; General.</p>
<p><b>Step 3</b> &minus; Select the ‘Use MFC in Shared DLL’ option in Project Defaults section and click OK.</p>
<p><b>Step 4</b> &minus; We need to add a new source file.</p>
<p><b>Step 5</b> &minus; Right-click on your Project and select Add &rarr; New Item.</p>
<p><b>Step 6</b> &minus; In the Templates section, click C++ File (.cpp).</p>
<img src="/mfc/images/win32_project_temp_section.jpg" alt="Win Project" />
<p><b>Step 7</b> &minus; Click Add to Continue.</p>
<p><b>Step 8</b> &minus; Now, add the following code in the *.cpp file.</p>
<pre class="prettyprint notranslate">
#include &lt;afxwin.h&gt;
class CMainFrame : public CFrameWnd {
   public:
      CMainFrame();
   protected:
      DECLARE_MESSAGE_MAP()
};

CMainFrame::CMainFrame() {
   // Create the window's frame
   Create(NULL, L"MFC Messages Demo", WS_OVERLAPPEDWINDOW,
      CRect(120, 100, 700, 480), NULL);
}

class CMessagesApp : public CWinApp {
   public:
      BOOL InitInstance();
};

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
END_MESSAGE_MAP()
BOOL CMessagesApp::InitInstance() {
   m_pMainWnd = new CMainFrame;
   m_pMainWnd-&gt;ShowWindow(SW_SHOW);
   m_pMainWnd-&gt;UpdateWindow();
   return TRUE;
}
CMessagesApp theApp;
</pre>
<h2>Windows Messages</h2>
<p>There are different types of Windows messages like creating a window, showing a window etc. Here are some of the commonly used windows messages.</p>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Given below are the different types of Window messages.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered" style="font-size:13px;">
<tr>
<th style="text-align:center;">Message</th>
<th style="text-align:center;">Map entry</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_ACTIVATE</b></td>
<td style="vertical-align:middle">ON_WM_ACTIVATE()</td>
<td>The framework calls this member function when a CWnd object is being activated or deactivated.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_ACTIVATEA PP</b</td>
<td>ON_WM_ACTIVATEAPP()</td>
<td>The framework calls this member function to all top-level windows of the task being activated and for all top-level windows of the task being deactivated.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_APPCOMM AND</b></td>
<td style="vertical-align:middle">ON_WM_APPCOMMAND()</td>
<td>The framework calls this member function when the user generates an application command event.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CANCELMODE</b></td>
<td style="vertical-align:middle">WM_CANCELMODE()</td>
<td>The framework calls this member function to inform CWnd to cancel any internal mode.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CHILDACTIVATE</b></td>
<td style="vertical-align:middle">ON_WM_CHILDACTIVATE()</td>
<td>If the CWnd object is a multiple document interface (MDI) child window, OnChildActivate is called by the framework when the user clicks the window's title bar or when the window is activated, moved, or sized.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CLIPBOAR DUPDATE</b></td>
<td style="vertical-align:middle">ON_WM_CLIPBOARDUPDATE()</td>
<td>The framework calls this member function when the contents of the clipboard have changed.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CLOSE</b></td>
<td style="vertical-align:middle">ON_WM_CLOSE()</td>
<td>The framework calls this member function as a signal that the CWnd or an application is to terminate.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CONTEXTMENU</b></td>
<td style="vertical-align:middle">ON_WM_CONTEXTMENU()</td>
<td>Called by the framework when the user has clicked the right mouse button (rightclicked) in the window.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_COPYDATA</b></td>
<td style="vertical-align:middle">ON_WM_COPYDATA()</td>
<td>This member function is called by the framework to copy data from one application to another.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CREATE</b></td>
<td style="vertical-align:middle">ON_WM_CREATE()</td>
<td>The framework calls this member function when an application requests that the Windows window be created by calling the Create or CreateEx member function.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_CTLCOLOR</b></td>
<td style="vertical-align:middle">ON_WM_CTLCOLOR()</td>
<td>The framework calls this member function when a child control is about to be drawn.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_DELETEITEM</b></td>
<td style="vertical-align:middle">ON_WM_DELETEITEM()</td>
<td>The framework calls this member function to inform the owner of an owner-draw list box or combo box that the list box or combo box is destroyed or that items have been removed.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_DESTROY</b></td>
<td style="vertical-align:middle">ON_WM_DESTROY()</td>
<td>he framework calls this member function to inform the CWnd object that it is being destroyed.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_DRAWITEM</b></td>
<td style="vertical-align:middle">ON_WM_DRAWITEM()</td>
<td>The framework calls this member function for the owner of an owner-draw button control, combo-box control, list-box control, or menu when a visual aspect of the control or menu has changed.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_DROPFILES</b></td>
<td style="vertical-align:middle">ON_WM_DROPFILES()</td>
<td>The framework calls this member function when the user releases the left mouse button over a window that has registered itself as the recipient of dropped files.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_ENABLE</b></td>
<td style="vertical-align:middle">ON_WM_ENABLE()</td>
<td>The framework calls this member function when an application changes the enabled state of the CWnd object. Syntax.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_HELPINFO</b></td>
<td style="vertical-align:middle">ON_WM_HELPINFO()</td>
<td>Handles F1 Help within the application (using the current context).</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_HOTKEY</b></td>
<td style="vertical-align:middle">ON_WM_HOTKEY()</td>
<td>The framework calls this member function when the user presses a system-wide hot key.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_HSCROLL</b></td>
<td style="vertical-align:middle">ON_WM_HSCROLL()</td>
<td>The framework calls this member function when the user clicks a window's horizontal scroll bar.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_KEYDOWN</b></td>
<td style="vertical-align:middle">ON_WM_KEYDOWN()</td>
<td>The framework calls this member function when a nonsystem key is pressed.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_KEYUP</b></td>
<td style="vertical-align:middle">ON_WM_KEYUP()</td>
<td>The framework calls this member function when a nonsystem key is released.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_KILLFOCUS</b></td>
<td style="vertical-align:middle">ON_WM_KILLFOCUS()</td>
<td>The framework calls this member function immediately before losing the input focus.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_LBUTTONDBLCLK</b></td>
<td style="vertical-align:middle">ON_WM_LBUTTONDBLCLK()</td>
<td>The framework calls this member function when the user double-clicks the left mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_LBUTTONDOWN</b></td>
<td style="vertical-align:middle">ON_WM_LBUTTONDOWN()</td>
<td>The framework calls this member function when the user presses the left mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_LBUTTONUP</b></td>
<td style="vertical-align:middle">ON_WM_LBUTTONUP()</td>
<td>The framework calls this member function when the user releases the left mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MBUTTONDBLCLK</b></td>
<td style="vertical-align:middle">ON_WM_MBUTTONDBLCLK()</td>
<td>The framework calls this member function when the user double-clicks the middle mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MBUTTONDOWN</b></td>
<td style="vertical-align:middle">ON_WM_MBUTTONDOWN()</td>
<td>The framework calls this member function when the user presses the middle mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MBUTTONUP</b></td>
<td style="vertical-align:middle">ON_WM_MBUTTONUP()</td>
<td>The framework calls this member function when the user releases the middle mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MENUSELECT</b></td>
<td style="vertical-align:middle">ON_WM_MENUSELECT()</td>
<td>If the CWnd object is associated with a menu, OnMenuSelect is called by the framework when the user selects a menu item.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MOUSEACTIVATE</b></td>
<td style="vertical-align:middle">ON_WM_MOUSEACTIVATE()</td>
<td>The framework calls this member function when the cursor is in an inactive window and the user presses a mouse button.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MOUSEHOVER</b></td>
<td style="vertical-align:middle">ON_WM_MOUSEHOVER()</td>
<td>The framework calls this member function when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MOUSEHWHEEL</b></td>
<td style="vertical-align:middle">ON_WM_MOUSEHWHEEL()</td>
<td>The framework calls this member when the current window is composed by the Desktop Window Manager (DWM), and that window is maximized.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MOUSELEAVE</b></td>
<td style="vertical-align:middle">ON_WM_MOUSELEAVE()</td>
<td>The framework calls this member function when the cursor leaves the client area of the window specified in a prior call to TrackMouseEvent.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MOUSEMOVE</b></td>
<td style="vertical-align:middle">ON_WM_MOUSEMOVE()</td>
<td>The framework calls this member function when the mouse cursor moves.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_MOVE</b></td>
<td style="vertical-align:middle">ON_WM_MOVE()</td>
<td>The framework calls this member function after the CWnd object has been moved.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_PAINT</b></td>
<td style="vertical-align:middle">ON_WM_PAINT()</td>
<td>The framework calls this member function when Windows or an application makes a request to repaint a portion of an application's window.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_SETFOCUS()</b></td>
<td style="vertical-align:middle">ON_WM_SETFOCUS( )</td>
<td>The framework calls this member function after gaining the input focus.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_SIZE( )</b></td>
<td style="vertical-align:middle">ON_WM_SIZE( )</td>
<td>The framework calls this member function after the window's size has changed.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_TIMER</b></td>
<td style="vertical-align:middle">ON_WM_TIMER()</td>
<td>The framework calls this member function after each interval specified in the SetTimer member function used to install a timer.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_VSCROLL</b></td>
<td style="vertical-align:middle">ON_WM_VSCROLL()</td>
<td>The framework calls this member function when the user clicks the window's vertical scroll bar.</td>
</tr>
<tr>
<td style="vertical-align:middle"><b>WM_WINDOWPOSCHANGED</b></td>
<td style="vertical-align:middle">ON_WM_WINDOWPOSCHANGED()</td>
<td>The framework calls this member function when the size, position, or Z-order has changed as a result of a call to the SetWindowPos member function or another window-management function.</td>
</tr>
</table>
</div>
</section>
<p>Let us look into a simple example of window creation.</p>
<p><b>WM_CREATE</b> &minus; When an object, called a window, is created, the frame that creates the objects sends a message identified as <b>ON_WM_CREATE</b>.</p>
<p><b>Step 1</b> &minus; To create ON_WM_CREATE, add afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct); before the DECLARE_MESSAGE_MAP() as shown below.</p>
<pre class="prettyprint notranslate">
class CMainFrame : public CFrameWnd {
   public:
      CMainFrame();
   protected:
      afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
      DECLARE_MESSAGE_MAP()
};
</pre>
<p><b>Step 2</b> &minus; Add the ON_WM_CREATE() after the BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd) and before END_MESSAGE_MAP()</p>
<pre class="prettyprint notranslate">
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   ON_WM_CREATE()
END_MESSAGE_MAP()
</pre>
<p><b>Step 3</b> &minus; Here is the Implementation of OnCreate()</p>
<pre class="prettyprint notranslate">
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) {
   // Call the base class to create the window
   if (CFrameWnd::OnCreate(lpCreateStruct) == 0) {

      // If the window was successfully created, let the user know
      MessageBox(L"The window has been created!!!");
      // Since the window was successfully created, return 0
      return 0;
   }
   // Otherwise, return -1
   return -1;
}
</pre>
<p><b>Step 4</b> &minus; Now your *.cpp file will look like as shown in the following code.</p>
<pre class="prettyprint notranslate">
#include &lt;afxwin.h&gt;
class CMainFrame : public CFrameWnd {
   public:
      CMainFrame();
   protected:
      afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
      DECLARE_MESSAGE_MAP()
};
CMainFrame::CMainFrame() {

   // Create the window's frame
   Create(NULL, L"MFC Messages Demo", WS_OVERLAPPEDWINDOW,
      CRect(120, 100, 700, 480), NULL);
}
class CMessagesApp : public CWinApp {
   public:
      BOOL InitInstance();
};
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   ON_WM_CREATE()
END_MESSAGE_MAP()
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) {
   // Call the base class to create the window
   if (CFrameWnd::OnCreate(lpCreateStruct) == 0) {
      // If the window was successfully created, let the user know
      MessageBox(L"The window has been created!!!");
      // Since the window was successfully created, return 0
      return 0;
   }
   // Otherwise, return -1
   return -1;
}
BOOL CMessagesApp::InitInstance() { 
   m_pMainWnd = new CMainFrame;
   m_pMainWnd -&gt; ShowWindow(SW_SHOW);
   m_pMainWnd -&gt; UpdateWindow();
   return TRUE;
}
CMessagesApp theApp;
</pre>
<p><b>Step 5</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/message.jpg" alt="Message" />
<p><b>Step 6</b> &minus; When you click OK, it will display the main window.</p>
<img src="/mfc/images/message_window.jpg" alt="Message" />
<h2>Command Messages</h2>
<p>One of the main features of a graphical application is to present Windows controls and resources that allow the user to interact with the machine. Examples of controls that we will learn are buttons, list boxes, combo boxes, etc.</p>
<p>One type of resource we introduced in the previous lesson is the menu. Such controls and resources can initiate their own messages when the user clicks them. A message that emanates from a Windows control or a resource is called a command message.</p>
<p>Let us look into a simple example of Command messages.</p>
<p>To provide your application the ability to create a new document, the CWinApp class provides the OnFileNew() method.</p>
<pre class="prettyprint notranslate">
afx_msg void OnFileNew();

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   ON_COMMAND(ID_FILE_NEW, CMainFrame::OnFileNew)
END_MESSAGE_MAP()
</pre>
<p>Here is the method definition &minus;</p>
<pre class="prettyprint notranslate">
void CMainFrame::OnFileNew() {
   // Create New file
}
</pre>
<h2>Keyboard Messages</h2>
<p>A <b>keyboard</b> is a hardware object attached to the computer. By default, it is used to enter recognizable symbols, letters, and other characters on a control. Each key on the keyboard displays a symbol, a letter, or a combination of those, to give an indication of what the key could be used for. The user typically presses a key, which sends a signal to a program.</p>
<p>Each key has a code that the operating system can recognize. This code is known as the <b>virtual key code</b>.</p>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>The virtual key codes are as follows.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Constant/value &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>VK_LBUTTON</b></p>
<p>Left mouse button</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>VK_RBUTTON</b></p>
<p>Right mouse button</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>VK_CANCEL</b></p>
<p>Control-break processing</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>VK_MBUTTON</b></p>
<p>Middle mouse button (three-button mouse)</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>VK_BACK</b></p>
<p>BACKSPACE key</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>VK_RETURN</b></p>
<p>ENTER key</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>VK_TAB</b></p>
<p>TAB key</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>VK_CLEAR</b></p>
<p>CLEAR key</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>VK_SHIFT</b></p>
<p>SHIFT key</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>VK_CONTROL</b></p>
<p>CTRL key</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>VK_MENU</b></p>
<p>ALT key</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>VK_PAUSE</b></p>
<p>PAUSE key</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>VK_CAPITAL</b></p>
<p>CAPS LOCK key</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>VK_ESCAPE</b></p>
<p>ESC key</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>VK_SPACE</b></p>
<p>SPACEBAR</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>VK_PRIOR</b></p>
<p>PAGE UP key</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>VK_NEXT</b></p>
<p>PAGE DOWN key</p></td>
</tr>
<tr>
<td class="ts">18</td>
<td><p><b>VK_END</b></p>
<p>END key</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><p><b>VK_HOME</b></p>
<p>HOME key</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><p><b>VK_LEFT</b></p>
<p>LEFT ARROW key</p></td>
</tr>
<tr>
<td class="ts">21</td>
<td><p><b>VK_UP</b></p>
<p>UP ARROW key</p></td>
</tr>
<tr>
<td class="ts">22</td>
<td><p><b>VK_RIGHT</b></p>
<p>RIGHT ARROW key</p></td>
</tr>
<tr>
<td class="ts">23</td>
<td><p><b>VK_DOWN</b></p>
<p>DOWN ARROW key</p></td>
</tr>
<tr>
<td class="ts">24</td>
<td><p><b>VK_SELECT</b></p>
<p>SELECT key</p></td>
</tr>
<tr>
<td class="ts">25</td>
<td><p><b>VK_PRINT</b></p>
<p>PRINT key</p></td>
</tr>
<tr>
<td class="ts">26</td>
<td><p><b>VK_EXECUTE</b></p>
<p>EXECUTE key</p></td>
</tr>
<tr>
<td class="ts">27</td>
<td><p><b>VK_SNAPSHOT</b></p>
<p>PRINT SCREEN key</p></td>
</tr>
<tr>
<td class="ts">28</td>
<td><p><b>VK_INSERT</b></p>
<p>INS key</p></td>
</tr>
<tr>
<td class="ts">29</td>
<td><p><b>VK_DELETE</b></p>
<p>DEL key</p></td>
</tr>
<tr>
<td class="ts">30</td>
<td><p><b>VK_NUMPAD0</b></p>
<p>Numeric keypad 0 key</p></td>
</tr>
<tr>
<td class="ts">31</td>
<td><p><b>VK_NUMPAD1</b></p>
<p>Numeric keypad 1 key</p></td>
</tr>
<tr>
<td class="ts">32</td>
<td><p><b>VK_NUMPAD2</b></p>
<p>Numeric keypad 2 key</p></td>
</tr>
<tr>
<td class="ts">33</td>
<td><p><b>VK_NUMPAD3</b></p>
<p>Numeric keypad 3 key</p></td>
</tr>
<tr>
<td class="ts">34</td>
<td><p><b>VK_NUMPAD4</b></p>
<p>Numeric keypad 4 key</p></td>
</tr>
<tr>
<td class="ts">35</td>
<td><p><b>VK_NUMPAD5</b></p>
<p>Numeric keypad 5 key</p></td>
</tr>
<tr>
<td class="ts">36</td>
<td><p><b>VK_NUMPAD6</b></p>
<p>Numeric keypad 6 key</p></td>
</tr>
<tr>
<td class="ts">37</td>
<td><p><b>VK_NUMPAD7</b></p>
<p>Numeric keypad 7 key</p></td>
</tr>
<tr>
<td class="ts">38</td>
<td><p><b>VK_NUMPAD8</b></p>
<p>Numeric keypad 8 key</p></td>
</tr>
<tr>
<td class="ts">39</td>
<td><p><b>VK_NUMPAD9</b></p>
<p>Numeric keypad 9 key</p></td>
</tr>
<tr>
<td class="ts">40</td>
<td><p><b>VK_MULTIPLY</b></p>
<p>Multiply key</p></td>
</tr>
<tr>
<td class="ts">41</td>
<td><p><b>VK_ADD</b></p>
<p>Add key</p></td>
</tr>
<tr>
<td class="ts">42</td>
<td><p><b>VK_SEPARATOR</b></p>
<p>Separator key</p></td>
</tr>
<tr>
<td class="ts">43</td>
<td><p><b>VK_SUBTRACT</b></p>
<p>Subtract key</p></td>
</tr>
<tr>
<td class="ts">44</td>
<td><p><b>VK_DECIMAL</b></p>
<p>Decimal key</p></td>
</tr>
<tr>
<td class="ts">45</td>
<td><p><b>VK_DIVIDE</b></p>
<p>Divide key</p></td>
</tr>
<tr>
<td class="ts">46</td>
<td><p><b>VK_F1</b></p>
<p>F1 key</p></td>
</tr>
<tr>
<td class="ts">47</td>
<td><p><b>VK_F2</b></p>
<p>F2 key</p></td>
</tr>
<tr>
<td class="ts">48</td>
<td><p><b>VK_F3</b></p>
<p>F3 key</p></td>
</tr>
<tr>
<td class="ts">49</td>
<td><p><b>VK_F4</b></p>
<p>F4 key</p></td>
</tr>
<tr>
<td class="ts">50</td>
<td><p><b>VK_F5</b></p>
<p>F5 key</p></td>
</tr>
<tr>
<td class="ts">52</td>
<td><p><b>VK_F6</b></p>
<p>F6 key</p></td>
</tr>
<tr>
<td class="ts">53</td>
<td><p><b>VK_F7</b></p>
<p>F7 key</p></td>
</tr>
<tr>
<td class="ts">54</td>
<td><p><b>VK_F8</b></p>
<p>F8 key</p></td>
</tr>
<tr>
<td class="ts">55</td>
<td><p><b>VK_F9</b></p>
<p>F9 key</p></td>
</tr>
<tr>
<td class="ts">56</td>
<td><p><b>VK_F10</b></p>
<p>F10 key</p></td>
</tr>
<tr>
<td class="ts">57</td>
<td><p><b>VK_F11</b></p>
<p>F11 key</p></td>
</tr>
<tr>
<td class="ts">58</td>
<td><p><b>VK_F12</b></p>
<p>F12 key</p></td>
</tr>
<tr>
<td class="ts">59</td>
<td><p><b>VK_NUMLOCK</b></p>
<p>NUM LOCK key</p></td>
</tr>
<tr>
<td class="ts">60</td>
<td><p><b>VK_SCROLL</b></p>
<p>SCROLL LOCK key</p></td>
</tr>
<tr>
<td class="ts">61</td>
<td><p><b>VK_LSHIFT</b></p>
<p>Left SHIFT key</p></td>
</tr>
<tr>
<td class="ts">62</td>
<td><p><b>VK_RSHIFT</b></p>
<p>Right SHIFT key</p></td>
</tr>
<tr>
<td class="ts">63</td>
<td><p><b>VK_LCONTROL</b></p>
<p>Left CONTROL key</p></td>
</tr>
<tr>
<td class="ts">64</td>
<td><p><b>VK_RCONTROL</b></p>
<p>Right CONTROL key</p></td>
</tr>
</table>
</div>
</section>
<p>Pressing a key causes a <a href="https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-keydown" target="_blank" rel="nofollow">WM_KEYDOWN</a> or <a href="https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-syskeydown" target="_blank" rel="nofollow">WM_SYSKEYDOWN</a> message to be placed in the thread message. This can be defined as follows &minus;</p>
<pre class="prettyprint notranslate">
afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
</pre>
<p>Let us look into a simple example.</p>
<p><b>Step 1</b> &minus; Here is the message.</p>
<pre class="prettyprint notranslate">
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   ON_WM_CREATE()
   ON_WM_KEYDOWN()
END_MESSAGE_MAP()
</pre>
<p><b>Step 2</b> &minus; Here is the implementation of OnKeyDown().</p>
<pre class="prettyprint notranslate">
void CMainFrame::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) {
   switch (nChar) {

      case VK_RETURN:
         MessageBox(L"You pressed Enter");
         break;
      case VK_F1:
         MessageBox(L"Help is not available at the moment");
         break;
      case VK_DELETE:
         MessageBox(L"Can't Delete This");
         break;
      default:
         MessageBox(L"Whatever");
   }
}
</pre>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/message_window.jpg" alt="Message Window" />
<p><b>Step 4</b> &minus; When you press Enter, it will display the following message.</p>
<img src="/mfc/images/message_output.jpg" alt="Message Output" />
<h2>Mouse Messages</h2>
<p>The mouse is another object that is attached to the computer allowing the user to interact with the machine.</p>
<ul class="list">
<li><p>If the left mouse button was pressed, an ON_WM_LBUTTONDOWN message is sent. The syntax of this message is &minus; </p>
<ul class="list">
<li><p>afx_msg void OnLButtonDown(UINT nFlags, CPoint point)</p></li>
</ul>
</li>
<li><p>If the right mouse button was pressed, an ON_WM_RBUTTONDOWN message is sent. Its syntax is &minus;</p>
<ul class="list">
<li><p>afx_msg void OnRButtonDown(UINT nFlags, CPoint point)</p></li>
</ul>
</li>
<li><p>Similarly If the left mouse is being released, the ON_WM_LBUTTONUP message is sent. Its syntax is &minus;</p>
<ul class="list">
<li><p>afx_msg void OnLButtonUp(UINT nFlags, CPoint point)</p></li>
</ul>
</li>
<li><p>If the right mouse is being released, the ON_WM_TBUTTONUP message is sent. Its syntax is &minus;</p>
<ul class="list">
<li><p>afx_msg void OnRButtonUp(UINT nFlags, CPoint point)</p></li>
</ul>
</li>
</ul>
<p>Let us look into a simple example.</p>
<p><b>Step 1</b> &minus; Add the following two functions in CMainFrame class definition as shown in the following code.</p>
<pre class="prettyprint notranslate">
class CMainFrame : public CFrameWnd {
   public:
      CMainFrame();
   protected:
      afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
      afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
      afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
      DECLARE_MESSAGE_MAP()
};
</pre>
<p><b>Step 2</b> &minus; Add the following two Message Maps.</p>
<pre class="prettyprint notranslate">
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   ON_WM_KEYDOWN()
   ON_WM_LBUTTONDOWN()
   ON_WM_RBUTTONUP()
END_MESSAGE_MAP()
</pre>
<p><b>Step 3</b> &minus; Here is the functions definition.</p>
<pre class="prettyprint notranslate">
void CMainFrame::OnLButtonDown(UINT nFlags, CPoint point) { 
   CString MsgCoord;
   MsgCoord.Format(L"Left Button at P(%d, %d)", point.x, point.y);
   MessageBox(MsgCoord);
}
void CMainFrame::OnRButtonUp(UINT nFlags, CPoint point) { 
   MessageBox(L"Right Mouse Button Up");
}
</pre>
<p><b>Step 4</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/message_window.jpg" alt="Mouse Messages" />
<p><b>Step 5</b> &minus; When you click OK, you will see the following message.</p>
<img src="/mfc/images/mouse_messages2.jpg" alt="Mouse Messages" />
<p><b>Step 6</b> &minus; Right-click on this window. Now, when you release the right button of the mouse, it will display the following message.</p>
<img src="/mfc/images/mouse_messages3.jpg" alt="Mouse Messages" />
<h1>MFC - Activex Control</h1>
<p>An <b>ActiveX control container</b> is a parent program that supplies the environment for an ActiveX (formerly OLE) control to run.</p>
<ul class="list">
<li><p>ActiveX control is a control using Microsoft ActiveX technologies.</p></li>
<li><p>ActiveX is not a programming language, but rather a set of rules for how applications should share information.</p></li>
<li><p>Programmers can develop ActiveX controls in a variety of languages, including C, C++, Visual Basic, and Java.</p></li>
<li><p>You can create an application capable of containing ActiveX controls with or without MFC, but it is much easier to do with MFC.</p></li>
</ul>
<p>Let us look into simple example of add ActiveX controls in your MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Right-click on the dialog in the designer window and select Insert ActiveX Control.</p>
<img src="/mfc/images/picture_activex_control.jpg" alt="Insert Activex Control" />
<p><b>Step 2</b> &minus; Select the Microsoft Picture Clip Control and click OK.</p>
<img src="/mfc/images/mfcpicture_control.jpg" alt="Microsoft Picture Control" />
<p><b>Step 3</b> &minus; Resize the Picture control and in the Properties window, click the Picture field.</p>
<p><b>Step 4</b> &minus; Browse the folder that contains Pictures. Select any picture.</p>
<p><b>Step 5</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/mfcpicture_controls.jpg" alt="Insert Activex" />
<p>Let us have a look into another simple example.</p>
<p><b>Step 1</b> &minus; Right-click on the dialog in the designer window.</p>
<img src="/mfc/images/progress_bars1.jpg" alt="Designer Window" />
<p><b>Step 2</b> &minus; Select Insert ActiveX Control.</p>
<img src="/mfc/images/insert_activex_control.jpg" alt="Designer Window" />
<p><b>Step 3</b> &minus; Select the Microsoft ProgressBar Control 6.0, click OK.</p>
<p><b>Step 4</b> &minus; Select the progress bar and set its Orientation in the Properties Window to <b>1 – ccOrientationVertical</b>.</p>
<p><b>Step 5</b> &minus; Add control variable for Progress bar.</p>
<img src="/mfc/images/progress_bars3.jpg" alt="Designer Window" />
<p><b>Step 6</b> &minus; Add the following code in the OnInitDialog()</p>
<pre class="prettyprint notranslate">
m_progBarCtrl.SetScrollRange(0,100,TRUE);
m_progBarCtrl.put_Value(53);
</pre>
<p><b>Step 7</b> &minus; When you run this application again, you will see the progress bar in Vertical direction as well.</p>
<img src="/mfc/images/mfcprogress_control.jpg" alt="Designer Window" />
<h1>MFC - File System</h1>
<p>In this chapter, we will discuss the various components of the file system.</p>
<h2>Drives</h2>
<p>A <b>drive</b> is a physical device attached to a computer so it can store information. A logical disk, logical volume or virtual disk (VD or vdisk for short) is a virtual device that provides an area of usable storage capacity on one or more physical disk drive(s) in a computer system. A drive can be a hard disk, a CD ROM, a DVD ROM, a flash (USB) drive, a memory card, etc.</p>
<p>One of the primary operations you will want to perform is to get a list of drives on the computer.</p>
<p>Let us look into a simple example by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Drag one button from the toolbox, change its Caption to Get Drives Info.</p>
<p><b>Step 2</b> &minus; Remove the Caption of Static control (TODO line) and change its ID to IDC_STATIC_TEXT.</p>
<img src="/mfc/images/static_caption1.jpg" alt="Static Caption" />
<p><b>Step 3</b> &minus; Right-click on the button and select Add Event Handler.</p>
<img src="/mfc/images/static_caption2.jpg" alt="Static Caption" />
<p><b>Step 4</b> &minus; Select the BN_CLICKED message type and click the Add and Edit button.</p>
<p><b>Step 5</b> &minus; Add the value variable m_strDrives for Static Text control.</p>
<img src="/mfc/images/static_caption3.jpg" alt="Static Caption" />
<p>To support drives on a computer, the Win32 library provides the GetLogicalDrives() function of Microsoft Window, which will retrieve a list of all drives on the current computer.</p>
<p><b>Step 6</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/static_caption4.jpg" alt="Static Caption" />
<p><b>Step 7</b> &minus; When you click the button, you can see all the drives on your computer.</p>
<img src="/mfc/images/static_caption5.jpg" alt="Static Caption" />
<h2>Directories</h2>
<p>In computing, a <b>directory</b> is a file system cataloging structure which contains references to other computer files, and possibly other directories. Directory is a physical location. It can handle operations not available on a drive.</p>
<p>Let us look into a simple example by creating a new MFC dialog based application</p>
<p><b>Step 1</b> &minus; Drag three buttons from the toolbox. Change their Captions to Create Directory, Delete Directory and Move Directory.</p>
<p><b>Step 2</b> &minus; Change the IDs of these buttons to <b>IDC_BUTTON_CREATE</b>, <b>IDC_BUTTON_DELETE</b> and <b>IDC_BUTTON_MOVE</b>.</p>
<p><b>Step 3</b> &minus; Remove the TODO line.</p>
<img src="/mfc/images/directories1.jpg" alt="Directories" />
<p><b>Step 4</b> &minus; Add event handler for each button.</p>
<p><b>Step 5</b> &minus; To create a directory, you can call the CreateDirectory() method of the Win32 library.</p>
<p><b>Step 6</b> &minus; Here is the Create button event handler implementation in which we will create one directory and then two more sub directories.</p>
<pre class="prettyprint notranslate">
void CMFCDirectoriesDemoDlg::OnBnClickedButtonCreate() {
   // TODO: Add your control notification handler code here
   SECURITY_ATTRIBUTES saPermissions;

   saPermissions.nLength = sizeof(SECURITY_ATTRIBUTES);
   saPermissions.lpSecurityDescriptor = NULL;
   saPermissions.bInheritHandle = TRUE;

   if (CreateDirectory(L"D:\\MFCDirectoryDEMO", &amp;saPermissions) == TRUE)
      AfxMessageBox(L"The directory was created.");
   CreateDirectory(L"D:\\MFCDirectoryDEMO\\Dir1", NULL);
   CreateDirectory(L"D:\\MFCDirectoryDEMO\\Dir2", NULL);
}
</pre>
<p><b>Step 7</b> &minus; To get rid of a directory, you can call the <b>RemoveDirectory()</b> function of the Win32 library. Here is the implementation of delete button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCDirectoriesDemoDlg::OnBnClickedButtonDelete() {
   // TODO: Add your control notification handler code here
   if (RemoveDirectory(L"D:\\MFCDirectoryDEMO\\Dir1") == TRUE)
      AfxMessageBox(L"The directory has been deleted");
}
</pre>
<p><b>Step 8</b> &minus; If you want to move a directory, you can also call the same MoveFile() function. Here is the implementation of move button event handler in which we will create first new directory and then move the Dir2 to that directory.</p>
<pre class="prettyprint notranslate">
void CMFCDirectoriesDemoDlg::OnBnClickedButtonMove() {
   // TODO: Add your control notification handler code here
   CreateDirectory(L"D:\\MFCDirectory", NULL);

   if (MoveFile(L"D:\\MFCDirectoryDEMO\\Dir1", L"D:\\MFCDirectory\\Dir1") == TRUE)
      AfxMessageBox(L"The directory has been moved");
}
</pre>
<p><b>Step 9</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/directories2.jpg" alt="Directories" />
<p><b>Step 10</b> &minus; When you click the Create Directory button, it will create these directories.</p>
<img src="/mfc/images/directories3.jpg" alt="Directories" />
<p><b>Step 11</b> &minus; When you click on Delete Directory button, it will delete the Dir1.</p>
<img src="/mfc/images/directories4.jpg" alt="Directories" />
<h2>File Processing</h2>
<p>Most of the <b>file processing</b> in an MFC application is performed in conjunction with a class named <b>CArchive</b>. The CArchive class serves as a relay between the application and the medium used to either store data or make it available. It allows you to save a complex network of objects in a permanent binary form (usually disk storage) that persists after those objects are deleted.</p>
<p>Here is the list of methods in CArchive class &minus;</p>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Given below is the list of methods in CDC class.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Abort</b></p>
<p>Closes an archive without throwing an exception.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>Close</b></p>
<p>Flushes unwritten data and disconnects from the <b>CFile</b>.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Flush</b></p>
<p>Flushes unwritten data from the archive buffer.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>GetFile</b></p>
<p>Gets the CFile object pointer for this archive.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>GetObjectSchema</b></p>
<p>Called from the <b>Serialize</b> function to determine the version of the object that is being deserialized.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>IsBufferEmpty</b></p>
<p>Determines whether the buffer has been emptied during a Windows Sockets receive process.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>IsLoading</b></p>
<p>Determines whether the archive is loading.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>IsStoring</b></p>
<p>Determines whether the archive is storing.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>MapObject</b></p>
<p>Places objects in the map that are not serialized to the file, but that are available for subobjects to reference.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>Read</b></p>
<p>Reads raw bytes.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>ReadClass</b></p>
<p>Reads a class reference previously stored with <b>WriteClass</b>.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>ReadObject</b></p>
<p>Calls an object's Serialize function for loading.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>ReadString</b></p>
<p>Reads a single line of text.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>SerializeClass</b></p>
<p>Reads or writes the class reference to the CArchive object depending on the direction of the CArchive.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>SetLoadParams</b></p>
<p>Sets the size to which the load array grows. Must be called before any object is loaded or before <b>MapObject</b> or <b>ReadObject</b> is called.</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>SetObjectSchema</b></p>
<p>Sets the object schema stored in the archive object.</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>SetStoreParams</b></p>
<p>Sets the hash table size and the block size of the map used to identify unique objects during the serialization process.</p></td>
</tr>
<tr>
<td class="ts">18</td>
<td><p><b>Write</b></p>
<p>Writes raw bytes.</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><p><b>WriteClass</b></p>
<p>Writes a reference to the <b>CRuntimeClass</b> to the CArchive.</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><p><b>WriteObject</b></p>
<p>Calls an object's Serialize function for storing.</p></td>
</tr>
<tr>
<td class="ts">21</td>
<td><p><b>WriteString</b></p>
<p>Writes a single line of text.</p></td>
</tr>
</table>
</div>
</section>
<p>Here is the list of operators used to store and retrieve data</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>operator &lt;&lt;</b></p>
<p>Stores objects and primitive types to the archive.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>operator &gt;&gt;</b></p>
<p>Loads objects and primitive types from the archive.</td></p>
</tr>
</table>
<p>Let us look into a simple example by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Drag one edit control and two buttons as shown in the following snapshot.</p>
<img src="/mfc/images/new_mfc1.jpg" alt="New MFC" />
<p><b>Step 2</b> &minus; Add control variable <b>m_editCtrl</b> and value variable <b>m_strEdit</b> for edit control.</p>
<p><b>Step 3</b> &minus; Add click event handler for Open and Save buttons.</p>
<p><b>Step 4</b> &minus; Here is the implementation of event handlers.</p>
<pre class="prettyprint notranslate">
void CMFCFileProcessingDlg::OnBnClickedButtonOpen() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   
   CFile file;
   
   file.Open(L"ArchiveText.rpr", CFile::modeRead);
   if(file) {
      CArchive ar(&amp;file, CArchive::load);
   
      ar &gt;&gt; m_strEdit;
   
      ar.Close();
      file.Close();
   }
   UpdateData(FALSE);
}

void CMFCFileProcessingDlg::OnBnClickedButtonSave() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);

   if (m_strEdit.GetLength() == 0) {
      AfxMessageBox(L"You must enter the name of the text.");
      return;
   }
   CFile file;
   
   file.Open(L"ArchiveText.rpr", CFile::modeCreate | CFile::modeWrite);
   CArchive ar(&amp;file, CArchive::store);
   ar &lt;&lt; m_strEdit;
   
   ar.Close();
   file.Close();
}
</pre>
<p><b>Step 5</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/new_mfc2.jpg" alt="New MFC" />
<p><b>Step 6</b> &minus; Write something and click Save. It will save the data in binary format.</p>
<img src="/mfc/images/new_mfc3.jpg" alt="New MFC" />
<p><b>Step 7</b> &minus; Remove the test from edit control. As you click Open, observe that the same text is loaded again.</p>
<h1>MFC - Standard I/O</h1>
<p>The MFC library provides its own version of file processing. This is done through a class named CStdioFile. The CStdioFile class is derived from CFile. It can handle the reading and writing of Unicode text files as well as ordinary multi-byte text files.</p>
<p>Here is the list of constructors, which can initialize a CStdioFile object &minus;</p>
<pre class="prettyprint notranslate">
CStdioFile();
CStdioFile(CAtlTransactionManager* pTM);
CStdioFile(FILE* pOpenStream);
CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags);
CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM);
</pre>
<p>Here is the list of methods in CStdioFile &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Open</b></p>
<p>Overloaded. Open is designed for use with the default CStdioFile constructor (Overrides CFile::Open).</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>ReadString</b></p>
<p>Reads a single line of text.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Seek</b></p>
<p>Positions the current file pointer.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>WriteString</b></p>
<p>Writes a single line of text.</p></td>
</tr>
</table>
<p>Let us look into a simple example again by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Drag one edit control and two buttons as shown in the following snapshot.</p>
<img src="/mfc/images/snapshot1.jpg" alt="Snapshot" />
<p><b>Step 2</b> &minus; Add value variable <b>m_strEditCtrl</b> for edit control.</p>
<img src="/mfc/images/snapshot2.jpg" alt="Snapshot" />
<p><b>Step 3</b> &minus; Add click event handler for Open and Save buttons.</p>
<p><b>Step 4</b> &minus; Here is the implementation of event handlers.</p>
<pre class="prettyprint notranslate">
void CMFCStandardIODlg::OnBnClickedButtonOpen() {
   
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);

   CStdioFile file;
   file.Open(L"D:\\MFCDirectoryDEMO\\test.txt", CFile::modeRead | CFile::typeText);
   
   file.ReadString(m_strEditCtrl);
   file.Close();
   UpdateData(FALSE);
}

void CMFCStandardIODlg::OnBnClickedButtonSave() {
   
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   CStdioFile file;
   if (m_strEditCtrl.GetLength() == 0) {

      AfxMessageBox(L"You must specify the text.");
      return;
   }
   file.Open(L"D:\\MFCDirectoryDEMO\\test.txt", CFile::modeCreate |
      CFile::modeWrite | CFile::typeText);
   file.WriteString(m_strEditCtrl);
   file.Close();
}
</pre>
<p><b>Step 5</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/snapshot3.jpg" alt="Snapshot" />
<p><b>Step 6</b> &minus; Write something and click Save. It will save the data in *.txt file.</p>
<img src="/mfc/images/snapshot4.jpg" alt="Snapshot" />
<p><b>Step 7</b> &minus; If you look at the location of the file, you will see that it contains the test.txt file.</p>
<img src="/mfc/images/snapshot5.jpg" alt="Snapshot" />
<p><b>Step 8</b> &minus; Now, close the application. Run the same application. When you click Open, the same text loads again.</p>
<p><b>Step 9</b> &minus; It starts by opening the file, reading the file, followed by updating the Edit Control.</p>
<h1>MFC - Document View</h1>
<p>The <b>Document/View architecture</b> is the foundation used to create applications based on the Microsoft Foundation Classes library. It allows you to make distinct the different parts that compose a computer program including what the user sees as part of your application and the document a user would work on. This is done through a combination of separate classes that work as an ensemble.</p>
<p>The parts that compose the Document/View architecture are a frame, one or more documents, and the view. Put together, these entities make up a usable application.</p>
<h2>View</h2>
<p>A <b>view</b> is the platform the user is working on to do his or her job. To let the user do anything on an application, you must provide a view, which is an object based on the CView class. You can either directly use one of the classes derivedfrom CView or you can derive your own custom class from CView or one of its child classes.</p>
<h2>Document</h2>
<p>A <b>document</b> is similar to a bucket. For a computer application, a document holds the user's data. To create the document part of this architecture, you must derive an object from the CDocument class.</p>
<h2>Frame</h2>
<p>As the name suggests, a <b>frame</b> is a combination of the building blocks, the structure, and the borders of an item. A frame gives "physical" presence to a window. It also defines the location of an object with regards to the Windows desktop.</p>
<h2>Single Document Interface (SDI)</h2>
<p>The expression <b>Single Document Interface</b> or SDI refers to a document that can present only one view to the user. This means that the application cannot display more than one document at a time. If you want to view another type of document of the current application, you must create another instance of the application. Notepad and WordPad are examples of SDI applications.</p>
<p>Let us look into a simple example of single document interface or SDI by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Let us create a new MFC Application <b>MFCSDIDemo</b> with below mentioned settings.</p>
<img src="/mfc/images/sdi1.jpg" alt="SDI" />
<p><b>Step 2</b> &minus; Select Single document from the Application type and MFC standard from Project Style.</p>
<p><b>Step 3</b> &minus; Click Finish to Continue.</p>
<p><b>Step 4</b> &minus; Once the project is created, run the application and you will see the following output.</p>
<img src="/mfc/images/sdi2.jpg" alt="SDI" />
<h2>Multiple Document Interface (MDI)</h2>
<p>An application is referred to as a <b>Multiple Document Interface</b>, or MDI, if the user can open more than one document in the application without closing it. To provide this functionality, the application provides a parent frame that acts as the main frame of the computer program. Inside this frame, the application allows creating views with individual frames, making each view distinct from the other.</p>
<p>Let us look into a simple example of multiple document interface or MDI by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Let us create a new MFC Application <b>MFCMDIDemo</b> with below mentioned settings.</p>
<img src="/mfc/images/mdi1.jpg" alt="MDI" />
<p><b>Step 2</b> &minus; Select Multiple document from the Application type and MFC standard from Project Style.</p>
<p><b>Step 3</b> &minus; Click Finish to Continue.</p>
<p><b>Step 4</b> &minus; Once the project is created, run the application and you will see the following output.</p>
<img src="/mfc/images/mdi2.jpg" alt="MDI" />
<p><b>Step 5</b> &minus; When you click on File &rarr; New menu option, it will create another child window as shown in the following snapshot.</p>
<img src="/mfc/images/mdi3.jpg" alt="MDI" />
<p><b>Step 6</b> &minus; In Multiple Document Interface (MDI) applications, there is one main frame per application. In this case, a CMDIFrameWnd, and one CMDIChildWnd derived child frame for each document.</p>
<h1>MFC - Strings</h1>
<p><b>Strings</b> are objects that represent sequences of characters. The C-style character string originated within the C language and continues to be supported within C++.</p>
<ul class="list">
<li><p>This string is actually a one-dimensional array of characters which is terminated by a null character '\0'.</p></li>
<li><p>A null-terminated string contains the characters that comprise the string followed by a null.</p></li>
</ul>
<p>Here is the simple example of character array.</p>
<pre class="prettyprint notranslate">
char word[12] = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\0' };
</pre>
<p>Following is another way to represent it.</p>
<pre class="prettyprint notranslate">
char word[] = "Hello, World";
</pre>
<p>Microsoft Foundation Class (MFC) library provides a class to manipulate string called <b>CString</b>. Following are some important features of CString.</p>
<ul class="list">
<li><p>CString does not have a base class.</p></li>
<li><p>A CString object consists of a variable-length sequence of characters.</p></li>
<li><p>CString provides functions and operators using a syntax similar to that of Basic.</p></li>
<li><p>Concatenation and comparison operators, together with simplified memory management, make CString objects easier to use than ordinary character arrays.</p></li>
</ul>
<p>Here is the constructor of CString.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>CString</b></p>
<p>Constructs CString objects in various ways</p></td>
</tr>
</table>
<p>Here is a list of Array Methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>GetLength</b></p>
<p>Returns the number of characters in a CString object.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>IsEmpty</b></p>
<p>Tests whether a CString object contains no characters.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Empty</b></p>
<p>Forces a string to have 0 length.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>GetAt</b></p>
<p>Returns the character at a specified position.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>SetAt</b></p>
<p>Sets a character at a specified position.</p></td>
</tr>
</table>
<p>Here is a list of Comparison Methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Compare</b></p>
<p>Compares two strings (case sensitive).</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>CompareNoCase</b></p>
<p>Compares two strings (case insensitive).</p></td>
</tr>
</table>
<p>Here is a list of Extraction Methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Mid</b></p>
<p>Extracts the middle part of a string (like the Basic MID$ function).</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>Left</b></p>
<p>Extracts the left part of a string (like the Basic LEFT$ function).</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Right</b></p>
<p>Extracts the right part of a string (like the Basic RIGHT$ function).</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>SpanIncluding</b></p>
<p>Extracts the characters from the string, which are in the given character set.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>SpanExcluding</b></p>
<p>Extracts the characters from the string which are not in the given character set.</p></td>
</tr>
</table>
<p>Here is a list of Conversion Methods.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>MakeUpper</b></p>
<p>Converts all the characters in this string to uppercase characters.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>MakeLower</b></p>
<p>Converts all the characters in this string to lowercase characters.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>MakeReverse</b></p>
<p>Reverses the characters in this string.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>Format</b></p>
<p>Format the string as sprintf does.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>TrimLeft</b></p>
<p>Trim leading white-space characters from the string.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>TrimRight</b></p>
<p>Trim trailing white-space characters from the string.</p></td>
</tr>
</table>
<p>Here is a list of Searching Methods.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Find</b></p>
<p>Finds a character or substring inside a larger string.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>ReverseFind</b></p>
<p>Finds a character inside a larger string; starts from the end.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>FindOneOf</b></p>
<p>Finds the first matching character from a set.</p></td>
</tr>
</table>
<p>Here is a list of Buffer Access Methods.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>GetBuffer</b></p>
<p>Returns a pointer to the characters in the CString.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>GetBufferSetLength</b></p>
<p>Returns a pointer to the characters in the CString, truncating to the specified length.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>ReleaseBuffer</b></p>
<p>Releases control of the buffer returned by GetBuffer </p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>FreeExtra</b></p>
<p>Removes any overhead of this string object by freeing any extra memory previously allocated to the string.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>LockBuffer</b></p>
<p>Disables reference counting and protects the string in the buffer. </p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>UnlockBuffer</b></p>
<p>Enables reference counting and releases the string in the buffer. </p></td>
</tr>
</table>
<p>Here is a list of Windows-Specific Methods.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>AllocSysString</b></p>
<p>Allocates a BSTR from CString data.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>SetSysString</b></p>
<p>Sets an existing BSTR object with data from a CString object.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>LoadString</b></p>
<p>Loads an existing CString object from a Windows CE resource.</p></td>
</tr>
</table>
<p>Following are the different operations on CString objects &minus;</p>
<h2>Create String</h2>
<p>You can create a string by either using a string literal or creating an instance of CString class.</p>
<pre class="prettyprint notranslate">
BOOL CMFCStringDemoDlg::OnInitDialog() {

   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);         // Set big icon
   SetIcon(m_hIcon, FALSE);       // Set small icon

   CString string1 = _T("This is a string1");
   CString string2("This is a string2");

   m_strText.Append(string1 + L"\n");
   m_strText.Append(string2);

   UpdateData(FALSE);

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/create_string.jpg" alt="Create String" />
<h2>Empty String</h2>
<p>You can create an empty string by either using an empty string literal or by using CString::Empty() method. You can also check whether a string is empty or not using Boolean property isEmpty.</p>
<pre class="prettyprint notranslate">
BOOL CMFCStringDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);            // Set big icon
   SetIcon(m_hIcon, FALSE);           // Set small icon

   CString string1 = _T("");
   CString string2;
   string2.Empty();

   if(string1.IsEmpty())
      m_strText.Append(L"String1 is empty\n");
   else
      m_strText.Append(string1 + L"\n");
   
   if(string2.IsEmpty())
      m_strText.Append(L"String2 is empty");
   else
      m_strText.Append(string2);
   UpdateData(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed you will see the following output.</p>
<img src="/mfc/images/empty_string.jpg" alt="Empty String" />
<h2>String Concatenation</h2>
<p>To concatenate two or more strings, you can use + operator to concatenate two strings or a CString::Append() method.</p>
<pre class="prettyprint notranslate">
BOOL CMFCStringDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);              // Set big icon
   SetIcon(m_hIcon, FALSE);              // Set small icon

   //To concatenate two CString objects
   CString s1 = _T("This ");           // Cascading concatenation
   s1 += _T("is a ");
   CString s2 = _T("test");
   CString message = s1;
   message.Append(_T("big ") + s2);
   // Message contains "This is a big test".

   m_strText = L"message: " + message;

   UpdateData(FALSE);

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed you will see the following output.</p>
<img src="/mfc/images/string_concatination.jpg" alt="String Concatination" />
<h2>String Length</h2>
<p>To find the length of the string you can use the CString::GetLength() method, which returns the number of characters in a CString object.</p>
<pre class="prettyprint notranslate">
BOOL CMFCStringDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();
   
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);              // Set big icon
   SetIcon(m_hIcon, FALSE);              // Set small icon

   CString string1 = _T("This is string 1");
   int length = string1.GetLength();
   CString strLen;

   strLen.Format(L"\nString1 contains %d characters", length);
   m_strText = string1 + strLen;

   UpdateData(FALSE);

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed you will see the following output.</p>
<img src="/mfc/images/string_length.jpg" alt="String Length" />
<h2>String Comparison</h2>
<p>To compare two strings variables you can use == operator</p>
<pre class="prettyprint notranslate">
BOOL CMFCStringDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();
   
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);            // Set big icon
   SetIcon(m_hIcon, FALSE);          // Set small icon

   CString string1 = _T("Hello");
   CString string2 = _T("World");

   CString string3 = _T("MFC Tutorial");
   CString string4 = _T("MFC Tutorial");

   if (string1 == string2)
      m_strText = "string1 and string1 are same\n";
   else
      m_strText = "string1 and string1 are not same\n";

   if (string3 == string4)
      m_strText += "string3 and string4 are same";
   else
      m_strText += "string3 and string4 are not same";

   UpdateData(FALSE);

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed you will see the following output.</p>
<img src="/mfc/images/string_comparison.jpg" alt="String Comparison" />
<h1>MFC - CArray</h1>
<p><b>CArray</b> is a collection that is best used for data that is to be accessed in a random or non sequential manner. CArray class supports arrays that are like C arrays, but can dynamically shrink and grow as necessary.</p>
<ul class="list">
<li><p>Array indexes always start at position 0.</p></li>
<li><p>You can decide whether to fix the upper bound or enable the array to expand when you add elements past the current bound.</p></li>
<li><p>Memory is allocated contiguously to the upper bound, even if some elements are null.</p></li>
</ul> 
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here is a list of CArray class methods.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Add</b></p>
<p>Adds an element to the end of the array; grows the array if necessary.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>Append</b></p>
<p>Appends another array to the array; grows the array if necessary</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Copy</b></p>
<p>Copies another array to the array; grows the array if necessary.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>ElementAt</b></p>
<p>Returns a temporary reference to the element pointer within the array.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>FreeExtra</b></p>
<p>Frees all unused memory above the current upper bound.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>GetAt</b></p>
<p>Frees all unused memory above the current upper bound.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>GetCount</b></p>
<p>Gets the number of elements in this array.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>GetData</b></p>
<p>Allows access to elements in the array. Can be <b>NULL</b>.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>GetSize</b></p>
<p>Gets the number of elements in this array.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>GetUpperBound</b></p>
<p>Returns the largest valid index.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>InsertAt</b></p>
<p>Inserts an element (or all the elements in another array) at a specified index.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>IsEmpty</b></p>
<p>Determines whether the array is empty.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>RemoveAll</b></p>
<p>Removes all the elements from this array.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>RemoveAt</b></p>
<p>Removes an element at a specific index.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>SetAt</b></p>
<p>Sets the value for a given index; array not allowed
to grow.</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>SetAtGrow</b></p>
<p>Sets the value for a given index; grows the array if necessary.</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>SetSize</b></p>
<p>Sets the number of elements to be contained in this array.</p></td>
</tr>
</table>
</div>
</section>
<p>Following are the different operations on CArray objects &minus;</p>
<h2>Create CArray Object</h2>
<p>To create a collection of CArray values or objects, you must first decide the type of values of the collection. You can use one of the existing primitive data types such as int, CString, double etc. as shown below;</p>
<pre class="prettyprint notranslate">
CArray&lt;CString, CString&gt;strArray;
</pre>
<h2>Add items</h2>
<p>To add an item you can use CArray::Add() function. It adds an item at the end of the array. In the OnInitDialog(), CArray object is created and three names are added as shown in the following code.</p>
<pre class="prettyprint notranslate">
CArray&lt;CString, CString&gt;strArray;

//Add names to CArray
strArray.Add(L"Ali");
strArray.Add(L"Ahmed");
strArray.Add(L"Mark");
</pre>
<h2>Retrieve Items</h2>
<p>To retrieve any item, you can use the CArray::GetAt() function. This function takes one integer parameter as an index of the array.</p>
<p><b>Step 1</b> &minus; Let us look at a simple example, which will retrieve all the names.</p>
<pre class="prettyprint notranslate">
//Retrive names from CArray
   for (int i = 0; i &lt; strArray.GetSize(); i++) {
      m_strText.Append(strArray.GetAt(i) + L"\n");
   }
</pre>
<p><b>Step 2</b> &minus; Here is the complete implementation of CMFCCArrayDlg::OnInitDialog()</p>
<pre class="prettyprint notranslate">
BOOL CMFCCArrayDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);               // Set big icon
   SetIcon(m_hIcon, FALSE);             // Set small icon

   // TODO: Add extra initialization here
   CArray&lt;CString, CString&gt;strArray;
   
   //Add names to CArray
   strArray.Add(L"Ali");
   strArray.Add(L"Ahmed");
   strArray.Add(L"Mark");
   
   //Retrive names from CArray
   for (int i = 0; i &lt; strArray.GetSize(); i++) {
      m_strText.Append(strArray.GetAt(i) + L"\n");
   }
   
   UpdateData(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/retrieve_items.jpg" alt="Retrieve Items" />
<h2>Add Items in the Middle</h2>
<p>To add item in the middle of array you can use the CArray::.InsertAt() function. It takes two paramerters — First, the index and Second, the value.</p>
<p>Let us insert a new item at index 1 as shown in the following code.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCArrayDlg::OnInitDialog() {
   
   CDialogEx::OnInitDialog();
   
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);             // Set big icon
   SetIcon(m_hIcon, FALSE);            // Set small icon

   // TODO: Add extra initialization here
   CArray&lt;CString, CString&gt;strArray;
   //Add names to CArray
   strArray.Add(L"Ali");
   strArray.Add(L"Ahmed");
   strArray.Add(L"Mark");

   strArray.InsertAt(1, L"Allan");

   //Retrive names from CArray
   for (int i = 0; i &lt; strArray.GetSize(); i++) {
      m_strText.Append(strArray.GetAt(i) + L"\n");
   }

   UpdateData(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed, you will see the following output. You can now see the name Allan dded as the second index.</p>
<img src="/mfc/images/add_items.jpg" alt="Add Items" />
<h2>Update Item Value</h2>
<p>To update item in the middle of array you can use the CArray::.SetAt() function. It takes two paramerters — First, the index and Second, the value.</p>
<p>Let us update the third element in the array as shown in the following code.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCArrayDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);                 // Set big icon
   SetIcon(m_hIcon, FALSE);               // Set small icon

   // TODO: Add extra initialization here
   CArray&lt;CString, CString&gt;strArray;

   //Add names to CArray
   strArray.Add(L"Ali");
   strArray.Add(L"Ahmed");
   strArray.Add(L"Mark");
  
   strArray.InsertAt(1, L"Allan");
   
   strArray.SetAt(2, L"Salman");
   
   //Retrive names from CArray
   for (int i = 0; i &lt; strArray.GetSize(); i++) {
      m_strText.Append(strArray.GetAt(i) + L"\n");
   }

   UpdateData(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed, you will see the following output. You can now see that the value of third element is updated.</p>
<img src="/mfc/images/update_items.jpg" alt="Update Items" />
<h2>Copy Array</h2>
<p>To copy the entire array into another CArray object, you can use CArray::Copy() function.</p>
<p><b>Step1</b> &minus; Let us create another array and copy all the elements from first array as shown in the following code.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCArrayDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Add "About..." menu item to system menu.

   // IDM_ABOUTBOX must be in the system command range.
   ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);
   ASSERT(IDM_ABOUTBOX &lt; 0xF000);
   CMenu* pSysMenu = GetSystemMenu(FALSE);
   if (pSysMenu != NULL) {
      BOOL bNameValid;
      CString strAboutMenu;
      bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
      ASSERT(bNameValid);
      if (!strAboutMenu.IsEmpty()) {
         pSysMenu&rarr;AppendMenu(MF_SEPARATOR);
         pSysMenu&rarr;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
      }
   }
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);               // Set big icon
   SetIcon(m_hIcon, FALSE);              // Set small icon

   // TODO: Add extra initialization here
   CArray&lt;CString, CString&gt;strArray;
   //Add names to CArray
   strArray.Add(L"Ali");
   strArray.Add(L"Ahmed");
   strArray.Add(L"Mark");

   strArray.InsertAt(1, L"Allan");

   strArray.SetAt(2, L"Salman");

   CArray&lt;CString, CString&gt;strArray2;
   strArray2.Copy(strArray);
   //Retrive names from CArray
   for (int i = 0; i &lt; strArray2.GetSize(); i++) {
      m_strText.Append(strArray2.GetAt(i) + L"\n");
   }

   UpdateData(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>You can now see that we have retrieved element from the 2<sup>nd</sup> array and the output is the same because we have used the copy function.</p>
<img src="/mfc/images/copy_array.jpg" alt="Copy Array" />
<h2>Remove Items</h2>
<p>To remove any particular item, you can use CArray::RemoveAt() function. To remove all the element from the list, CArray::RemoveAll() function can be used.</p>
<p>Let us remove the second element from an array.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCArrayDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   SetIcon(m_hIcon, TRUE);             // Set big icon
   SetIcon(m_hIcon, FALSE);            // Set small icon

   // TODO: Add extra initialization here
   CArray&lt;CString, CString&gt;strArray;

   //Add names to CArray
   strArray.Add(L"Ali");
   strArray.Add(L"Ahmed");
   strArray.Add(L"Mark");

   strArray.InsertAt(1, L"Allan");

   strArray.SetAt(2, L"Salman");

   CArray&lt;CString, CString&gt;strArray2;
   strArray2.Copy(strArray);

   strArray2.RemoveAt(1);

   //Retrive names from CArray
   for (int i = 0; i &lt; strArray2.GetSize(); i++) {
      m_strText.Append(strArray2.GetAt(i) + L"\n");
   }

   UpdateData(FALSE);
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed, you will see the following output. You can now see that the name Allan is no longer part of the array.</p>
<img src="/mfc/images/remove_items.jpg" alt="Remove Items" />
<h1>MFC - Linked Lists</h1>
<p>A <b>linked list</b> is a linear data structure where each element is a separate object. Each element (we will call it a node) of a list comprises two items — the data and a reference to the next node. The last node has a reference to null.</p>
<p>A linked list is a data structure consisting of a group of nodes which together represent a sequence. It is a way to store data with structures so that the programmer can automatically create a new place to store data whenever necessary. Some of its salient features are &minus;</p>
<ul class="list">
<li><p>Linked List is a sequence of links which contains items.</p></li>
<li><p>Each link contains a connection to another link.</p></li>
<li><p>Each item in the list is called a node.</p></li>
<li><p>If the list contains at least one node, then a new node is positioned as the last element in the list.</p></li>
<li><p>If the list has only one node, that node represents the first and the last item.</p></li>
</ul>
<p>There are two types of link list &minus;</p>
<h2>Singly Linked List</h2>
<p>Singly Linked Lists are a type of data structure. In a singly linked list, each node in the list stores the contents of the node and a pointer or reference to the next node in the list.</p>
<img src="/mfc/images/single_linked_list.jpg" alt="Single Linked List" />
<h2>Doubly Linked List</h2>
<p>A doubly linked list is a linked data structure that consists of a set of sequentially linked records called nodes. Each node contains two fields that are references to the previous and to the next node in the sequence of nodes.</p>
<img src="/mfc/images/double_linked_list.jpg" alt="Double Linked List" />
<h2>CList Class</h2>
<p>MFC provides a class <b>CList</b> which is a template linked list implementation and works perfectly. CList lists behave like doubly-linked lists. A variable of type POSITION is a key for the list. You can use a POSITION variable as an iterator to traverse a list sequentially and as a bookmark to hold a place.</p> 
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here is the list of methods in CList class.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>AddHead</b></p>
<p>Adds an element (or all the elements in another list) to the head of the list (makes a new head).</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>AddTail</b></p>
<p>Adds an element (or all the elements in another list) to the tail of the list (makes a new tail).</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Find</b></p>
<p>Gets the position of an element specified by pointer value.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>FindIndex</b></p>
<p>Gets the position of an element specified by a zero-based index.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>GetAt</b></p>
<p>Gets the element at a given position.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>GetCount</b></p>
<p>Returns the number of elements in this list.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>GetHead</b></p>
<p>Returns the head element of the list (cannot be empty).</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>GetHeadPosition</b></p>
<p>Returns the position of the head element of the list.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>GetNext</b></p>
<p>Gets the next element for iterating.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>GetPrev</b></p>
<p>Gets the previous element for iterating.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>GetSize</b></p>
<p>Returns the number of elements in this list.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>GetTail</b></p>
<p>Returns the tail element of the list (cannot be empty).</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>GetTailPosition</b></p>
<p>Returns the position of the tail element of the list.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>InsertAfter</b></p>
<p>Inserts a new element after a given position.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>InsertBefore</b></p>
<p>Inserts a new element before a given position.</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>IsEmpty</b></p>
<p>Tests for the empty list condition (no elements).</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>RemoveAll</b></p>
<p>Removes all the elements from this list.</p></td>
</tr>
<tr>
<td class="ts">18</td>
<td><p><b>RemoveAt</b></p>
<p>Removes an element from this list, specified by position.</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><p><b>RemoveHead</b></p>
<p>Removes the element from the head of the list.</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><p><b>RemoveTail</b></p>
<p>Removes the element from the tail of the list.</p></td>
</tr>
<tr>
<td class="ts">21</td>
<td><p><b>SetAt</b></p>
<p>Sets the element at a given position.</p></td>
</tr>
</table>
</div>
</section>
<p>Following are the different operations on CList objects &minus;</p>
<h2>Create CList Object</h2>
<p>To create a collection of CList values or objects, you must first decide the type of values of the collection. You can use one of the existing primitive data types such as int, CString, double etc. as shown below in the following code.</p>
<pre class="prettyprint notranslate">
CList&lt;double, double&gt;m_list;
</pre>
<h2>Add items</h2>
<p>To add an item, you can use CList::AddTail() function. It adds an item at the end of the list. To add an element at the start of the list, you can use the CList::AddHead() function. In the OnInitDialog() CList, object is created and four values are added as shown in the following code.</p>
<pre class="prettyprint notranslate">
CList&lt;double, double&gt;m_list;

//Add items to the list
m_list.AddTail(100.75);
m_list.AddTail(85.26);
m_list.AddTail(95.78);
m_list.AddTail(90.1);

</pre>
<h2>Retrieve Items</h2>
<p>A variable of type POSITION is a key for the list. You can use a POSITION variable as an iterator to traverse a list sequentially.</p>
<p><b>Step 1</b> &minus; To retrieve the element from the list, we can use the following code which will retrieve all the values.</p>
<pre class="prettyprint notranslate">
//iterate the list
POSITION pos = m_list.GetHeadPosition();
while (pos) { 
   double nData = m_list.GetNext(pos);
   CString strVal;
   strVal.Format(L"%.2f\n", nData);
   m_strText.Append(strVal);
}
</pre>
<p><b>Step 2</b> &minus; Here is the complete CMFCCListDemoDlg::OnInitDialog() function.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCListDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);             // Set big icon
   SetIcon(m_hIcon, FALSE);             // Set small icon

   // TODO: Add extra initialization here
   CList&lt;double, double&gt;m_list;

   //Add items to the list
   m_list.AddTail(100.75);
   m_list.AddTail(85.26);
   m_list.AddTail(95.78);
   m_list.AddTail(90.1);

   //iterate the list
   POSITION pos = m_list.GetHeadPosition();
   while (pos) {
      double nData = m_list.GetNext(pos);
      CString strVal;
      strVal.Format(L"%.f\n", nData);
      m_strText.Append(strVal);
   }

   UpdateData(FALSE);
 
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/retrieve.jpg" alt="Retrieve" />
<h2>Add Items in the Middle</h2>
<p>To add item in the middle of the list, you can use the CList::.InsertAfter() and CList::.InsertBefore() functions. It takes two paramerters — First, the position (where it can be added) and Second, the value.</p>
<p><b>Step 1</b> &minus; Let us insert a new item as shown in the followng code.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCListDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();
   
   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);             // Set big icon
   SetIcon(m_hIcon, FALSE);          // Set small icon

   // TODO: Add extra initialization here
   CList&lt;double, double&gt;m_list;

   //Add items to the list
   m_list.AddTail(100.75);
   m_list.AddTail(85.26);
   m_list.AddTail(95.78);
   m_list.AddTail(90.1);

   POSITION position = m_list.Find(85.26);
   m_list.InsertBefore(position, 200.0);
   m_list.InsertAfter(position, 300.0);

   //iterate the list
   POSITION pos = m_list.GetHeadPosition();
   while (pos) {
      double nData = m_list.GetNext(pos);
      CString strVal;
      strVal.Format(L"%.2f\n", nData);
      m_strText.Append(strVal);
   }

   UpdateData(FALSE);

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p><b>Step 2</b> &minus; You can now see see that we first retrieved the position of value 85.26 and then inserted one element before and one element after that value.</p>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/adding_item.jpg" alt="Adding Item" />
<h2>Update Item Value</h2>
<p>To update item at the middle of array, you can use the CArray::.SetAt() function. It takes two paramerters — First, the position and Second, the value.</p>
<p>Let us update the 300.00 to 400 in the list as shown in the following code.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCListDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);              // Set big icon
   SetIcon(m_hIcon, FALSE);            // Set small icon

   // TODO: Add extra initialization here
   CList&lt;double, double&gt;m_list;

   //Add items to the list
   m_list.AddTail(100.75);
   m_list.AddTail(85.26);
   m_list.AddTail(95.78);
   m_list.AddTail(90.1);

   POSITION position = m_list.Find(85.26);
   m_list.InsertBefore(position, 200.0);
   m_list.InsertAfter(position, 300.0);

   position = m_list.Find(300.00);
   m_list.SetAt(position, 400.00);

   //iterate the list
   POSITION pos = m_list.GetHeadPosition();
   while (pos) {
      double nData = m_list.GetNext(pos);
      CString strVal;
      strVal.Format(L"%.2f\n", nData);
      m_strText.Append(strVal);
   }

   UpdateData(FALSE);

   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed, you will see the following output. You can now see that the value of 300.00 is updated to 400.00.</p>
<img src="/mfc/images/updating_item.jpg" alt="Updating Item" />
<h2>Remove Items</h2>
<p>To remove any particular item, you can use CList::RemoveAt() function. To remove all the element from the list, CList::RemoveAll() function can be used.</p>
<p>Let us remove the element, which has 95.78 as its value.</p>
<pre class="prettyprint notranslate">
BOOL CMFCCListDemoDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);              // Set big icon
   SetIcon(m_hIcon, FALSE);             // Set small icon

   // TODO: Add extra initialization here
   CList&lt;double, double&gt;m_list;

   //Add items to the list
   m_list.AddTail(100.75);
   m_list.AddTail(85.26);
   m_list.AddTail(95.78);
   m_list.AddTail(90.1);

   POSITION position = m_list.Find(85.26);
   m_list.InsertBefore(position, 200.0);
   m_list.InsertAfter(position, 300.0);
   
   position = m_list.Find(300.00);
   m_list.SetAt(position, 400.00);

   position = m_list.Find(95.78);
   m_list.RemoveAt(position);

   //iterate the list
   POSITION pos = m_list.GetHeadPosition();
   while (pos) {
      double nData = m_list.GetNext(pos);
      CString strVal;
      strVal.Format(L"%.2f\n", nData);
      m_strText.Append(strVal);
   }
   UpdateData(FALSE);
   
   return TRUE; // return TRUE unless you set the focus to a control
}
</pre>
<p>When the above code is compiled and executed, you will see the following output. You can now see that the value of 95.78 is no longer part of the list.</p>
<img src="/mfc/images/removing_item.jpg" alt="Removing Item" />
<h1>MFC - Database Classes</h1>
<p>A <b>database</b> is a collection of information that is organized so that it can easily be accessed, managed, and updated. The MFC database classes based on ODBC are designed to provide access to any database for which an ODBC driver is available. Because the classes use ODBC, your application can access data in many different data formats and different local/remote configurations.</p>
<p>You do not have to write special-case code to handle different database management systems (DBMSs). As long as your users have an appropriate ODBC driver for the data they want to access, they can use your program to manipulate data in tables stored there. A data source is a specific instance of data hosted by some database management system (DBMS). Examples include Microsoft SQL Server, Microsoft Access, etc.</p>
<h2>CDatabase</h2>
<p>MFC provides a class <b>CDatabase</b> which represents a connection to a data source, through which you can operate on the data source. You can have one or more CDatabase objects active at a time in your application.</p> 
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here is the list of methods in CDatabase class.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>BeginTrans</b></p>
<p>Starts a "transaction" — a series of reversible calls to the AddNew, Edit, Delete, and Update member functions of class <b>CRecordset</b> — on the connected data source. The data source must support transactions for <b>BeginTrans</b> to have any effect.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>BindParameters</b></p>
<p>Allows you to bind parameters before calling <b>ExecuteSQL</b>.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Cancel</b></p>
<p>Cancels an asynchronous operation or a process from a second thread.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>CanTransact</b></p>
<p>Returns nonzero if the data source supports transactions.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>CanUpdate</b></p>
<p>Returns nonzero if the <b>CDatabase</b> object is updatable (not read-only).</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>Close</b></p>
<p>Closes the data source connection.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>CommitTrans</b></p>
<p>Completes a transaction begun by BeginTrans. Commands in the transaction that alter the data source are carried out.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>ExecuteSQL</b></p>
<p>Executes a SQL statement. No data records are returned.</p></td>
</tr>
<tr>
<td class="ts">9</td>
<td><p><b>GetBookmarkPersistence</b></p>
<p>Identifies the operations through which bookmarks persist on recordset objects.</p></td>
</tr>
<tr>
<td class="ts">10</td>
<td><p><b>GetConnect</b></p>
<p>Returns the ODBC connection string used to connect the CDatabase object to a data source.</p></td>
</tr>
<tr>
<td class="ts">11</td>
<td><p><b>GetCursorCommitBehavior</b></p>
<p>Identifies the effect of committing a transaction on an open recordset object.</p></td>
</tr>
<tr>
<td class="ts">12</td>
<td><p><b>GetCursorRollbackBehavior</b></p>
<p>Identifies the effect of rolling back a transaction on an open recordset object.</p></td>
</tr>
<tr>
<td class="ts">13</td>
<td><p><b>GetDatabaseName</b></p>
<p>Returns the name of the database currently in use.</p></td>
</tr>
<tr>
<td class="ts">14</td>
<td><p><b>IsOpen</b></p>
<p>Returns nonzero if the <b>CDatabase</b> object is currently connected to a data source.</p></td>
</tr>
<tr>
<td class="ts">15</td>
<td><p><b>OnSetOptions</b></p>
<p>Called by the framework to set standard connection options. The default implementation sets the query timeout value. You can establish these options ahead of time by calling <b>SetQueryTimeout</b>.</p></td>
</tr>
<tr>
<td class="ts">16</td>
<td><p><b>Open</b></p>
<p>Establishes a connection to a data source (through an ODBC driver).</p></td>
</tr>
<tr>
<td class="ts">17</td>
<td><p><b>OpenEx</b></p>
<p>Establishes a connection to a data source (through an ODBC driver).</p></td>
</tr>
<tr>
<td class="ts">18</td>
<td><p><b>Rollback</b></p>
<p>Reverses changes made during the current transaction. The data source returns to its previous state, as defined at the BeginTrans call, unaltered.</p></td>
</tr>
<tr>
<td class="ts">19</td>
<td><p><b>SetLoginTimeout</b></p>
<p>Sets the number of seconds after which a data source connection attempt will time out.</p></td>
</tr>
<tr>
<td class="ts">20</td>
<td><p><b>SetQueryTimeout</b></p>
<p>Sets the number of seconds after which database query operations will time out. Affects all subsequent recordset Open, AddNew, Edit, and Delete calls.</p></td>
</tr>
</table>
</div>
</section>
<p>Let us look into a simple example by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Change the caption of TODO line to <b>Retrieve Data from Database</b> and drag one button and one List control as shown in the following snapshot.</p>
<img src="/mfc/images/retrieve_data_from_db.jpg" alt="Retrieve Data From DB" />
<p><b>Step 2</b> &minus; Add click event handler for button and control variable m_ListControl for List Control.</p>
<p><b>Step 3</b> &minus; We have simple database which contains one Employees table with some records as shown in the following snapshot.</p>
<img src="/mfc/images/retrieve_employees_record.jpg" alt="Employees Table" />
<p><b>Step 4</b> &minus; We need to include the following headers file so that we can use CDatabase class.</p>
<pre class="prettyprint notranslate">
#include "odbcinst.h"
#include "afxdb.h"
</pre>
<h2>Insert Query</h2>
<p>The SQL INSERT INTO Statement is used to add new rows of data to a table in the database.</p>
<p><b>Step 1</b> &minus; To add new records, we will use the ExecuteSQL() function of CDatabase class as shown in the following code.</p>
<pre class="prettyprint notranslate">
CDatabase database;
CString SqlString;
CString strID, strName, strAge;
CString sDriver = L"MICROSOFT ACCESS DRIVER (*.mdb)";
CString sDsn;
CString sFile = L"D:\\Test.mdb";
// You must change above path if it's different
int iRec = 0;

// Build ODBC connection string
sDsn.Format(L"ODBC;DRIVER={%s};DSN='';DBQ=%s", sDriver, sFile);
TRY {
   // Open the database
   database.Open(NULL,false,false,sDsn);

   SqlString = "INSERT INTO Employees (ID,Name,age) VALUES (5,'Sanjay',69)";
   database.ExecuteSQL(SqlString);
   // Close the database
   database.Close();
}CATCH(CDBException, e) {
   // If a database exception occured, show error msg
   AfxMessageBox(L"Database error: " + e&rarr;m_strError);
}
END_CATCH;
</pre>
<p><b>Step 2</b> &minus; When the above code is compiled and executed, you will see that a new record is added in your database.</p>
<img src="/mfc/images/insert_queue.jpg" alt="Insert Queue" />
<h2>Retrieve Record</h2>
<p>To retrieve the above table in MFC application, we implement the database related operations in the button event handler as shown in the following steps.</p>
<p><b>Step 1</b> &minus; To use CDatabase, construct a CDatabase object and call its Open() function. This will open the connection.</p>
<p><b>Step 2</b> &minus; Construct CRecordset objects for operating on the connected data source, pass the recordset constructor a pointer to your CDatabase object.</p>
<p><b>Step 3</b> &minus; After using the connection, call the Close function and destroy the CDatabase object.</p>
<pre class="prettyprint notranslate">
void CMFCDatabaseDemoDlg::OnBnClickedButtonRead() {
   // TODO: Add your control notification handler code here
   CDatabase database;
   CString SqlString;
   CString strID, strName, strAge;
   CString sDriver = "MICROSOFT ACCESS DRIVER (*.mdb)";
   CString sFile = L"D:\\Test.mdb";
   // You must change above path if it's different
   int iRec = 0;

   // Build ODBC connection string
   sDsn.Format("ODBC;DRIVER={%s};DSN='';DBQ=%s",sDriver,sFile);
   TRY {
      // Open the database
      database.Open(NULL,false,false,sDsn);

      // Allocate the recordset
      CRecordset recset( &amp;database );

      // Build the SQL statement
      SqlString = "SELECT ID, Name, Age " "FROM Employees";

      // Execute the query
	  
      recset.Open(CRecordset::forwardOnly,SqlString,CRecordset::readOnly);
      // Reset List control if there is any data
      ResetListControl();
      // populate Grids
      ListView_SetExtendedListViewStyle(m_ListControl,LVS_EX_GRIDLINES);

      // Column width and heading
      m_ListControl.InsertColumn(0,"Emp ID",LVCFMT_LEFT,-1,0);
      m_ListControl.InsertColumn(1,"Name",LVCFMT_LEFT,-1,1);
      m_ListControl.InsertColumn(2, "Age", LVCFMT_LEFT, -1, 1);
      m_ListControl.SetColumnWidth(0, 120);
      m_ListControl.SetColumnWidth(1, 200);
      m_ListControl.SetColumnWidth(2, 200);

      // Loop through each record
      while( !recset.IsEOF() ) {
         // Copy each column into a variable
         recset.GetFieldValue("ID",strID);
         recset.GetFieldValue("Name",strName);
         recset.GetFieldValue("Age", strAge);

         // Insert values into the list control
         iRec = m_ListControl.InsertItem(0,strID,0);
         m_ListControl.SetItemText(0,1,strName);
         m_ListControl.SetItemText(0, 2, strAge);

         // goto next record
         recset.MoveNext();
      }
      // Close the database
      database.Close();
   }CATCH(CDBException, e) {
      // If a database exception occured, show error msg
      AfxMessageBox("Database error: "+e&rarr;m_strError);
   }
   END_CATCH; 
}

// Reset List control
void CMFCDatabaseDemoDlg::ResetListControl() {
   m_ListControl.DeleteAllItems();
   int iNbrOfColumns;
   CHeaderCtrl* pHeader = (CHeaderCtrl*)m_ListControl.GetDlgItem(0);
   if (pHeader) {
      iNbrOfColumns = pHeader&rarr;GetItemCount();
   }
   for (int i = iNbrOfColumns; i &gt;= 0; i--) {
      m_ListControl.DeleteColumn(i);
   }
}
</pre>
<p><b>Step 4</b> &minus; Here is the header file.</p>
<pre class="prettyprint notranslate">
// MFCDatabaseDemoDlg.h : header file
//

#pragma once
#include "afxcmn.h"


// CMFCDatabaseDemoDlg dialog
class CMFCDatabaseDemoDlg : public CDialogEx {
   // Construction
   public:
      CMFCDatabaseDemoDlg(CWnd* pParent = NULL);    // standard constructor

   // Dialog Data
   #ifdef AFX_DESIGN_TIME
      enum { IDD = IDD_MFCDATABASEDEMO_DIALOG };
   #endif

   protected:
      virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
      void ResetListControl();

   // Implementation
   protected:
      HICON m_hIcon;

      // Generated message map functions
      virtual BOOL OnInitDialog();
      afx_msg void OnPaint();
      afx_msg HCURSOR OnQueryDragIcon();
      DECLARE_MESSAGE_MAP()
   public:
      CListCtrl m_ListControl;
      afx_msg void OnBnClickedButtonRead();
};
</pre>
<p><b>Step 5</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/retrieve_record1.jpg" alt="Retrieve Record" />
<p><b>Step 6</b> &minus; Press the Read button to execute the database operations. It will retrieve the Employees table.</p>
<img src="/mfc/images/retrieve_record2.jpg" alt="Retrieve Record" />
<h2>Update Record</h2>
<p>The SQL UPDATE Query is used to modify the existing records in a table. You can use WHERE clause with UPDATE query to update selected rows otherwise all the rows would be affected.</p>
<p><b>Step 1</b> &minus; Let us look into a simple example by updating the Age where ID is equal to 5.</p>
<pre class="prettyprint notranslate">
SqlString = L"UPDATE Employees SET Age = 59 WHERE ID = 5;";
database.ExecuteSQL(SqlString);
</pre>
<p><b>Step 2</b> &minus; Here is the complete code of button click event.</p>
<pre class="prettyprint notranslate">
void CMFCDatabaseDemoDlg::OnBnClickedButtonRead() {
   // TODO: Add your control notification handler code here
   CDatabase database;
   CString SqlString;
   CString strID, strName, strAge;
   CString sDriver = L"MICROSOFT ACCESS DRIVER (*.mdb)";
   CString sDsn;
   CString sFile =
      L"C:\\Users\\Muhammad.Waqas\\Downloads\\Compressed\\ReadDB_demo\\Test.mdb";
   // You must change above path if it's different
   int iRec = 0;

   // Build ODBC connection string
   sDsn.Format(L"ODBC;DRIVER={%s};DSN='';DBQ=%s", sDriver, sFile);
   TRY {
      // Open the database
      database.Open(NULL,false,false,sDsn);

      // Allocate the recordset
      CRecordset recset(&amp;database);

      SqlString = L"UPDATE Employees SET Age = 59 WHERE ID = 5;";

      database.ExecuteSQL(SqlString);

      SqlString = "SELECT ID, Name, Age FROM Employees";

      // Build the SQL statement
      SqlString = "SELECT ID, Name, Age FROM Employees";

      // Execute the query
      recset.Open(CRecordset::forwardOnly,SqlString,CRecordset::readOnly);

      // Reset List control if there is any data
      ResetListControl();
      // populate Grids
      ListView_SetExtendedListViewStyle(m_listCtrl,LVS_EX_GRIDLINES);

      // Column width and heading
      m_listCtrl.InsertColumn(0,L"Emp ID",LVCFMT_LEFT,-1,0);
      m_listCtrl.InsertColumn(1,L"Name",LVCFMT_LEFT,-1,1);
      m_listCtrl.InsertColumn(2, L"Age", LVCFMT_LEFT, -1, 1);
      m_listCtrl.SetColumnWidth(0, 120);
      m_listCtrl.SetColumnWidth(1, 200);
      m_listCtrl.SetColumnWidth(2, 200);

      // Loop through each record
      while (!recset.IsEOF()) {
         // Copy each column into a variable
         recset.GetFieldValue(L"ID",strID);
         recset.GetFieldValue(L"Name",strName);
         recset.GetFieldValue(L"Age", strAge);

         // Insert values into the list control
         iRec = m_listCtrl.InsertItem(0,strID,0);
         m_listCtrl.SetItemText(0,1,strName);
         m_listCtrl.SetItemText(0, 2, strAge);

         // goto next record
         recset.MoveNext();
      }

      // Close the database
      database.Close();
   }CATCH(CDBException, e) {
      // If a database exception occured, show error msg
      AfxMessageBox(L"Database error: " + e&rarr;m_strError);
   }
   END_CATCH;
}
</pre>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/retrieve_record1.jpg" alt="Retrieve Record" />
<p><b>Step 4</b> &minus; Press the Read button to execute the database operations. It will retrieve the following Employees table.</p>
<img src="/mfc/images/update_record.jpg" alt="Update Record" />
<p><b>Step 5</b> &minus; You can now see that age is updated from 69 to 59.</p>
<h2>Delete Record</h2>
<p>The SQL DELETE Query is used to delete the existing records from a table. You can use WHERE clause with DELETE query to delete selected rows, otherwise all the records would be deleted.</p>
<p><b>Step 1</b> &minus; Let us look into a simple example by deleting the record where ID is equal to 3.</p>
<pre class="prettyprint notranslate">
SqlString = L"DELETE FROM Employees WHERE ID = 3;";

database.ExecuteSQL(SqlString);
</pre>
<p><b>Step 2</b> &minus; Here is the complete code of button click event.</p>
<pre class="prettyprint notranslate">
void CMFCDatabaseDemoDlg::OnBnClickedButtonRead() {
   // TODO: Add your control notification handler code here
   CDatabase database;
   CString SqlString;
   CString strID, strName, strAge;
   CString sDriver = L"MICROSOFT ACCESS DRIVER (*.mdb)";
   CString sDsn;
   CString sFile =
       L"C:\\Users\\Muhammad.Waqas\\Downloads\\Compressed\\ReadDB_demo\\Test.mdb";

   // You must change above path if it's different
   int iRec = 0;

   // Build ODBC connection string
   sDsn.Format(L"ODBC;DRIVER={%s};DSN='';DBQ=%s", sDriver, sFile);
   TRY {
      // Open the database
      database.Open(NULL,false,false,sDsn);

      // Allocate the recordset
      CRecordset recset(&amp;database);

      SqlString = L"DELETE FROM Employees WHERE ID = 3;";

      database.ExecuteSQL(SqlString);

      SqlString = "SELECT ID, Name, Age FROM Employees";

      // Build the SQL statement
      SqlString = "SELECT ID, Name, Age FROM Employees";

      // Execute the query
      recset.Open(CRecordset::forwardOnly,SqlString,CRecordset::readOnly);

      // Reset List control if there is any data
      ResetListControl();
      // populate Grids
      ListView_SetExtendedListViewStyle(m_listCtrl,LVS_EX_GRIDLINES);
      // Column width and heading
      m_listCtrl.InsertColumn(0,L"Emp ID",LVCFMT_LEFT,-1,0);
      m_listCtrl.InsertColumn(1,L"Name",LVCFMT_LEFT,-1,1);
      m_listCtrl.InsertColumn(2, L"Age", LVCFMT_LEFT, -1, 1);
      m_listCtrl.SetColumnWidth(0, 120);
      m_listCtrl.SetColumnWidth(1, 200);
      m_listCtrl.SetColumnWidth(2, 200);

      // Loop through each record
      while (!recset.IsEOF()) {
         // Copy each column into a variable
         recset.GetFieldValue(L"ID",strID);
         recset.GetFieldValue(L"Name",strName);
         recset.GetFieldValue(L"Age", strAge);

         // Insert values into the list control
         iRec = m_listCtrl.InsertItem(0,strID,0);
         m_listCtrl.SetItemText(0,1,strName);
         m_listCtrl.SetItemText(0, 2, strAge);

         // goto next record
         recset.MoveNext();
      }
      // Close the database
      database.Close();
   }CATCH(CDBException, e) {
      // If a database exception occured, show error msg
      AfxMessageBox(L"Database error: " + e&rarr;m_strError);
   }
   END_CATCH;
}
</pre>
<p><b>Step 3</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/retrieve_record1.jpg" alt="Retrieve Record" />
<p><b>Step 4</b> &minus; Press the Read button to execute the database operations. It will retrieve the Employees table.</p>
<img src="/mfc/images/delete_record.jpg" alt="Update Record" />
<h1>MFC - Serialization</h1>
<p><b>Serialization</b> is the process of writing or reading an object to or from a persistent storage medium such as a disk file. Serialization is ideal for situations where it is desired to maintain the state of structured data (such as C++ classes or structures) during or after the execution of a program.</p>
<p>When performing file processing, the values are typically of primitive types (char, short, int, float, or double). In the same way, we can individually save many values, one at a time. This technique doesn't include an object created from (as a variable of) a class.</p>
<p>The MFC library has a high level of support for serialization. It starts with the CObject class that is the ancestor to most MFC classes, which is equipped with a Serialize() member function.</p>
<p>Let us look into a simple example by creating a new MFC project.</p>
<p><b>Step 1</b> &minus; Remove the TODO line and design your dialog box as shown in the following snapshot.</p>
<img src="/mfc/images/remove_todo_line.jpg" alt="Remove TODO Line" />
<p><b>Step 2</b> &minus; Add value variables for all the edit controls. For Emp ID and Age mentioned, the value type is an integer as shown in the following snapshot.</p>
<img src="/mfc/images/serialization_add_var.jpg" alt="Serialization Add Var" />
<p><b>Step 3</b> &minus; Add the event handler for both the buttons.</p>
<p><b>Step 4</b> &minus; Let us now add a simple Employee class, which we need to serialize. Here is the declaration of Employee class in header file.</p>
<pre class="prettyprint notranslate">
class CEmployee : public CObject {
   public:
      int empID;
      CString empName;
      int age;
      CEmployee(void);
      ~CEmployee(void);
   private:

   public:
      void Serialize(CArchive&amp; ar);
      DECLARE_SERIAL(CEmployee);
};
</pre>
<p><b>Step 5</b> &minus; Here is the definition of Employee class in source (*.cpp) file.</p>
<pre class="prettyprint notranslate">
IMPLEMENT_SERIAL(CEmployee, CObject, 0)
CEmployee::CEmployee(void) {

}

CEmployee::~CEmployee(void) {

}

void CEmployee::Serialize(CArchive&amp; ar) {
   CObject::Serialize(ar);

   if (ar.IsStoring())
      ar &lt;&lt; empID &lt;&lt; empName &lt;&lt; age;
   else
      ar &gt;&gt; empID &gt;&gt; empName &gt;&gt; age;
}
</pre>
<p><b>Step 6</b> &minus; Here is the implementation of Save button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCSerializationDlg::OnBnClickedButtonSave() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   CEmployee employee;
   CFile file;
   file.Open(L"EmployeeInfo.hse", CFile::modeCreate | CFile::modeWrite);
   CArchive ar(&amp;file, CArchive::store);
   employee.empID = m_id;
   employee.empName = m_strName;
   employee.age = m_age;
   employee.Serialize(ar);
   ar.Close();
}
</pre>
<p><b>Step 7</b> &minus; Here is the implementation of Open button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCSerializationDlg::OnBnClickedButtonOpen() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);

   CFile file;

   file.Open(L"EmployeeInfo.hse", CFile::modeRead);
   CArchive ar(&amp;file, CArchive::load);
   CEmployee employee;

   employee.Serialize(ar);

   m_id = employee.empID;
   m_strName = employee.empName;
   m_age = employee.age;
   ar.Close();
   file.Close();

   UpdateData(FALSE);
}
</pre>
<p><b>Step 8</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/serialization_result.jpg" alt="Serialization Result" />
<p><b>Step 9</b> &minus; Enter the info in all the fields and click Save and close this program.</p>
<img src="/mfc/images/serialization_insert_info.jpg" alt="Serialization Insert Info" />
<p><b>Step 10</b> &minus; It will save the data. Run the application again and click open. It will load the Employee information.</p>
<img src="/mfc/images/serialization_insert_info.jpg" alt="Serialization Save Info" />
<h1>MFC - Multithreading</h1>
<p>The Microsoft Foundation Class (MFC) library provides support for multithreaded applications. A thread is a path of execution within a process. When you start Notepad, the operating system creates a process and begins executing the primary thread of that process. When this thread terminates, so does the process.</p>
<p>You can create additional threads in your application if you want. All threads in MFC applications are represented by CWinThread objects. In most situations, you do not even have to explicitly create these objects; instead call the framework helper function AfxBeginThread, which creates the CWinThread object for you.</p>
<p>Let us look into a simple example by creating a new MFC dialog based application.</p>
<p><b>Step 1</b> &minus; Change the Caption and ID of Static control to <b>Click on Start Thread button</b> and <b>IDC_STATIC_TEXT</b> respectively.</p>
<p><b>Step 2</b> &minus; Drag two buttons and add click event handlers for these buttons.</p>
<img src="/mfc/images/start_thread_button.jpg" alt="Start Thread Button" />
<p><b>Step 3</b> &minus; Add control variable for static text control.</p>
<p><b>Step 4</b> &minus; Now add the following three global variables at the start of CMFCMultithreadingDlg.cpp file.</p>
<pre class="prettyprint notranslate">
int currValue;
int maxValue;
BOOL stopNow;
</pre>
<p><b>Step 5</b> &minus; Add the WM_TIMER message in CMFCMultithreadingDlg class.</p>
<p>Here is the implementation of OnTimer()</p>
<pre class="prettyprint notranslate">
void CMFCMultithreadingDlg::OnTimer(UINT_PTR nIDEvent) {
   // TODO: Add your message handler code here and/or call default
   CString sStatusMsg;
   sStatusMsg.Format(L"Running: %d", currValue);
   m_ctrlStatus.SetWindowText(sStatusMsg);

   CDialogEx::OnTimer(nIDEvent);
}
</pre>
<p><b>Step 6</b> &minus; Now add a sample function for using in AfxBeginThread in CMFCMultithreadingDlg class.</p>
<pre class="prettyprint notranslate">
UINT MyThreadProc(LPVOID Param) {
   while (!stopNow &amp;&amp; (currValue &lt; maxValue)) {
      currValue++;
      Sleep(50);     // would do some work here
   }
   
   return TRUE;
}
</pre>
<p><b>Step 7</b> &minus; Here is the implementation of event handler for Start Thread button, which will start the thread.</p>
<pre class="prettyprint notranslate">
void CMFCMultithreadingDlg::OnBnClickedButtonStart() {
   // TODO: Add your control notification handler code here
   currValue = 0;
   maxValue = 5000;
   stopNow = 0;
   m_ctrlStatus.SetWindowText(L"Starting...");
   SetTimer(1234, 333, 0); // 3 times per second

   AfxBeginThread(MyThreadProc, 0); // &lt;&lt;== START THE THREAD
}
</pre>
<p><b>Step 8</b> &minus; Here is the implementation of event handler for Stop Thread button, which will stop the thread.</p>
<pre class="prettyprint notranslate">
void CMFCMultithreadingDlg::OnBnClickedButtonStop() {
   
   // TODO: Add your control notification handler code here
   stopNow = TRUE;
   KillTimer(1234);
   m_ctrlStatus.SetWindowText(L"Stopped");
}
</pre>
<p><b>Step 9</b> &minus; Here is the complete source file.</p>
<pre class="prettyprint notranslate">
// MFCMultithreadingDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MFCMultithreading.h"
#include "MFCMultithreadingDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// CMFCMultithreadingDlg dialog

int currValue;
int maxValue;
BOOL stopNow;

CMFCMultithreadingDlg::CMFCMultithreadingDlg(CWnd* pParent /* = NULL*/)
   : CDialogEx(IDD_MFCMULTITHREADING_DIALOG, pParent) {
   m_hIcon = AfxGetApp() -&gt; LoadIcon(IDR_MAINFRAME);
}
void CMFCMultithreadingDlg::DoDataExchange(CDataExchange* pDX) {
   CDialogEx::DoDataExchange(pDX);
   DDX_Control(pDX, IDC_STATIC_TEXT, m_ctrlStatus);
}

BEGIN_MESSAGE_MAP(CMFCMultithreadingDlg, CDialogEx)
   ON_WM_PAINT()
   ON_WM_QUERYDRAGICON()
   ON_BN_CLICKED(IDC_BUTTON_START,
      &amp;CMFCMultithreadingDlg::OnBnClickedButtonStart)
   ON_WM_TIMER()
   ON_BN_CLICKED(IDC_BUTTON_STOP,
      &amp;CMFCMultithreadingDlg::OnBnClickedButtonStop)
END_MESSAGE_MAP()

// CMFCMultithreadingDlg message handlers

BOOL CMFCMultithreadingDlg::OnInitDialog() {
   CDialogEx::OnInitDialog();

   // Set the icon for this dialog. The framework does this automatically
   // when the application's main window is not a dialog
   SetIcon(m_hIcon, TRUE);        // Set big icon
   SetIcon(m_hIcon, FALSE);       // Set small icon

   // TODO: Add extra initialization here

   return TRUE; // return TRUE unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
// to draw the icon. For MFC applications using the document/view model,
// this is automatically done for you by the framework.

void CMFCMultithreadingDlg::OnPaint() {
   if (IsIconic()) {
      CPaintDC dc(this); // device context for painting
      SendMessage(WM_ICONERASEBKGND,
         reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);
			
      // Center icon in client rectangle
      int cxIcon = GetSystemMetrics(SM_CXICON);
      int cyIcon = GetSystemMetrics(SM_CYICON);
      CRect rect;
      GetClientRect(&amp;rect);
      int x = (rect.Width() - cxIcon + 1) / 2;
      int y = (rect.Height() - cyIcon + 1) / 2;

      // Draw the icon
      dc.DrawIcon(x, y, m_hIcon);
   }else {
      CDialogEx::OnPaint();
   }
}
// The system calls this function to obtain the cursor to display while the user drags
// the minimized window.
HCURSOR CMFCMultithreadingDlg::OnQueryDragIcon() {
   return static_cast&lt;HCURSOR&gt;(m_hIcon);
}

UINT /*CThreadDlg::*/MyThreadProc(LPVOID Param) //Sample function for using in
AfxBeginThread {
   while (!stopNow &amp;&amp; (currValue &lt; maxValue)) {
      currValue++;
      Sleep(50); // would do some work here
   }
   return TRUE;
}
void CMFCMultithreadingDlg::OnBnClickedButtonStart() {
   // TODO: Add your control notification handler code here
   currValue = 0;
   maxValue = 5000;
   stopNow = 0;
   m_ctrlStatus.SetWindowText(L"Starting...");
   SetTimer(1234, 333, 0); // 3 times per second

   AfxBeginThread(MyThreadProc, 0); // &lt;&lt;== START THE THREAD
}

void CMFCMultithreadingDlg::OnTimer(UINT_PTR nIDEvent) {
   // TODO: Add your message handler code here and/or call default
   CString sStatusMsg;
   sStatusMsg.Format(L"Running: %d", currValue);
   m_ctrlStatus.SetWindowText(sStatusMsg);

   CDialogEx::OnTimer(nIDEvent);
}

void CMFCMultithreadingDlg::OnBnClickedButtonStop() {
   // TODO: Add your control notification handler code here
   stopNow = TRUE;
   KillTimer(1234);
   m_ctrlStatus.SetWindowText(L"Stopped");
}
</pre>
<p><b>Step 10</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/multithreading_output.jpg" alt="Multithreading" />
<p><b>Step 11</b> &minus; Now click on Start Thread button.</p>
<img src="/mfc/images/star_thread.jpg" alt="Start Thread" />
<p><b>Step 12</b> &minus; Click the Stop Thread button. It will stop the thread.</p>
<img src="/mfc/images/stop_thread.jpg" alt="Stop Thread" />
<h1>MFC - Internet Programming</h1>
<p>Microsoft provides many APIs for programming both client and server applications. Many new applications are being written for the Internet, and as technologies, browser capabilities, and security options change, new types of applications will be written. Your custom application can retrieve information and provide data on the Internet.</p>
<p>MFC provides a class <b>CSocket</b> for writing network communications programs with Windows Sockets.</p>
<p>Here is a list of methods in CSocket class.</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>Attach</b></p>
<p>Attaches a SOCKET handle to a CSocket object.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>CancelBlockingCall</b></p>
<p>Cancels a blocking call that is currently in progress.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>Create</b></p>
<p>Creates a socket.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>FromHandle</b></p>
<p>Returns a pointer to a CSocket object, given a SOCKET handle.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>IsBlocking</b></p>
<p>Determines whether a blocking call is in progress.</p></td>
</tr>
</table>
<p>Let us look into a simple example by creating a MFS SDI application.</p>
<img src="/mfc/images/mfcserver1.jpg" alt="MFCServer" />
<p><b>Step 1</b> &minus; Enter MFCServer in the name field and click OK.</p>
<img src="/mfc/images/mfcserver2.jpg" alt="MFCServer" />
<p><b>Step 2</b> &minus; On Advanced Features tab, check the Windows sockets option.</p>
<p><b>Step 3</b> &minus; Once the project is created, add a new MFC class CServerSocket.</p>
<img src="/mfc/images/mfcserver3.jpg" alt="MFCServer" />
<p><b>Step 4</b> &minus; Select the CSocket as base class and click Finish.</p>
<p><b>Step 5</b> &minus; Add more MFC class CReceivingSocket.</p>
<img src="/mfc/images/mfcserver4.jpg" alt="MFCServer" />
<p><b>Step 6</b> &minus; CRecevingSocket will receive incoming messages from client.</p>
<p>In CMFCServerApp, the header file includes the following files &minus;</p>
<pre class="prettyprint notranslate">
#include "ServerSocket.h"
#include "MFCServerView.h"
</pre>
<p><b>Step 7</b> &minus; Add the following two class variables in CMFCServerApp class.</p>
<pre class="result notranslate">
CServerSocket m_serverSocket;
CMFCServerView m_pServerView;
</pre>
<p><b>Step 8</b> &minus; In CMFCServerApp::InitInstance() method, create the socket and specify the port and then call the Listen method as shown below.</p>
<pre class="result notranslate">
m_serverSocket.Create(6666);
m_serverSocket.Listen();
</pre>
<p><b>Step 9</b> &minus; Include the following header file in CMFCServerView header file.</p>
<pre class="prettyprint notranslate">
#include "MFCServerDoc.h"
</pre>
<p><b>Step 10</b> &minus; Override the OnAccept function from Socket class.</p>
<img src="/mfc/images/mfcserver5.jpg" alt="MFCServer" />
<p><b>Step 11</b> &minus; Select CServerSocket in class view and the highlighted icon in Properties window. Now, Add OnAccept. Here is the implementation of OnAccept function.</p>
<pre class="prettyprint notranslate">
void CServerSocket::OnAccept(int nErrorCode) {

   // TODO: Add your specialized code here and/or call the base class
   AfxMessageBox(L"Connection accepted");
   CSocket::OnAccept(nErrorCode);
}
</pre>
<p><b>Step 12</b> &minus; Add OnReceive() function.</p>
<pre class="prettyprint notranslate">
void CServerSocket::OnReceive(int nErrorCode) { 
   
   // TODO: Add your specialized code here and/or call the base class
   AfxMessageBox(L"Data Received");
   CSocket::OnReceive(nErrorCode);
}
</pre>
<p><b>Step 13</b> &minus; Add OnReceive() function in CReceivingSocket class.</p>
<p>Right-click on the CMFCServerView class in solution explorer and select Add &rarr; AddFunction.</p>
<img src="/mfc/images/mfcserver6.jpg" alt="MFCServer" />
<p><b>Step 14</b> &minus; Enter the above mentioned information and click finish.</p>
<p><b>Step 15</b> &minus; Add the following CStringArray variable in CMFCServerView header file.</p>
<pre class="result notranslate">
CStringArray m_msgArray;
</pre>
<p><b>Step 16</b> &minus; Here is the implementation of AddMsg() function.</p>
<pre class="prettyprint notranslate">
void CMFCServerView::AddMsg(CString message) {

   m_msgArray.Add(message);
   Invalidate();
}
</pre>
<p><b>Step 17</b> &minus; Update the constructor as shown in the following code.</p>
<pre class="prettyprint notranslate">
CMFCServerView::CMFCServerView() {

   ((CMFCServerApp*)AfxGetApp()) -&gt; m_pServerView = this;
}
</pre>
<p><b>Step 18</b> &minus; Here is the implementation of OnDraw() function, which display messages.</p>
<pre class="prettyprint notranslate">
void CMFCServerView::OnDraw(CDC* pDC) {

   int y = 100;
   for (int i = 0; m_msgArray.GetSize(); i++) {
   
      pDC-&gt;TextOut(100, y, m_msgArray.GetAt(i));
      y += 50;
   }
   CMFCServerDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p><b>Step 19</b> &minus; The server side is now complete. It will receive message from the client.</p>
<h3>Create Client Side Application</h3>
<p><b>Step 1</b> &minus; Let us create a new MFC dialog based application for client side application.</p>
<img src="/mfc/images/client_side1.jpg" alt="Client Side" /><p></p>
<img src="/mfc/images/client_side2.jpg" alt="Client Side" />
<p><b>Step 2</b> &minus; On Advanced Features tab, check the Windows sockets option as shown above.</p>
<p><b>Step 3</b> &minus; Once the project is created, design your dialog box as shown in the following snapshot.</p>
<img src="/mfc/images/client_side3.jpg" alt="Client Side" />
<p><b>Step 4</b> &minus; Add event handlers for Connect and Send buttons.</p>
<p><b>Step 5</b> &minus; Add value variables for all the three edit controls. For port edit control, select the variable type UINT.</p>
<img src="/mfc/images/client_side4.jpg" alt="Client Side" />
<p><b>Step 6</b> &minus; Add MFC class for connecting and sending messages.</p>
<img src="/mfc/images/client_side5.jpg" alt="Client Side" />
<p><b>Step 7</b> &minus; Include the header file of CClientSocket class in the header file CMFCClientDemoApp class and add the class variable. Similarly, add the class variable in CMFCClientDemoDlg header file as well.</p>
<pre class="prettyprint notranslate">
CClientSocket m_clientSocket;
</pre>
<p><b>Step 8</b> &minus; Here is the implementation of Connect button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCClientDemoDlg::OnBnClickedButtonConnect() {

   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   m_clientSocket.Create();
   if (m_clientSocket.Connect(m_ipAddress, m_port)) {
      AfxMessageBox(L"Connection Successfull");
   }else {
      AfxMessageBox(L"Connection Failed");
   }
   DWORD error = GetLastError();
}
</pre>
<p><b>Step 9</b> &minus; Here is the implementation of Send button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCClientDemoDlg::OnBnClickedButtonSend() {

   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   if (m_clientSocket.Send(m_message.GetBuffer(m_message.GetLength()), m_message.GetLength())) {
   
   }else {
      AfxMessageBox(L"Failed to send message");
   }
}
</pre>
<p><b>Step 10</b> &minus; First run the Server application and then the client application. Enter the local host ip and port and click Connect.</p>
<img src="/mfc/images/client_side6.jpg" alt="Client Side" />
<p><b>Step 11</b> &minus; You will now see the message on Server side as shown in the following snapshot.</p>
<img src="/mfc/images/client_side7.jpg" alt="Client Side" />
<h1>MFC - GDI</h1>
<p>Windows provides a variety of drawing tools to use in device contexts. It provides pens to draw lines, brushes to fill interiors, and fonts to draw text. MFC provides graphic-object classes equivalent to the drawing tools in Windows.</p>
<h2>Drawing</h2>
<p>A device context is a Windows data structure containing information about the drawing attributes of a device such as a display or a printer. All drawing calls are made through a device-context object, which encapsulates the Windows APIs for drawing lines, shapes, and text.</p>
<p>Device contexts allow device-independent drawing in Windows. Device contexts can be used to draw to the screen, to the printer, or to a metafile.</p>
<p><b>CDC</b> is the most fundamental class to draw in MFC. The CDC object provides member functions to perform the basic drawing steps, as well as members for working with a display context associated with the client area of a window.</p> 
<section class="toggle">
<label>Given below is the list of methods in CDC class.</label>
<div class="toggle-content">
<table class="table table-bordered">
<tr>
<th style="width:15%;">Sr. No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>AbortDoc</b></p>
<p>Terminates the current print job, erasing everything the application has written to the device since the last call of the <b>StartDoc</b> member function.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>AbortPath</b></p>
<p>Closes and discards any paths in the device context.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>AddMetaFileComment</b></p>
<p>Copies the comment from a buffer into a specified enhanced-format metafile.</p></td>
</tr>
<tr>
<td>4</td>
<td><p><b>AlphaBlend</b></p>
<p>Displays bitmaps that have transparent or semitransparent pixels.</p></td>
</tr>
<tr>
<td>5</td>
<td><p><b>AngleArc</b></p>
<p>Draws a line segment and an arc, and moves the current position to the ending point of the arc.</p></td>
</tr>
<tr>
<td>6</td>
<td><p><b>Arc</b></p>
<p>Draws an elliptical arc.</p></td>
</tr>
<tr>
<td>7</td>
<td><p><b>ArcTo</b></p>
<p>Draws an elliptical arc. This function is similar to Arc, except that the current position is updated.</p></td>
</tr>
<tr>
<td>8</td>
<td><p><b>Attach</b></p>
<p>Attaches a Windows device context to this CDC object.</p></td>
</tr>
<tr>
<td>9</td>
<td><p><b>BeginPath</b></p>
<p>Opens a path bracket in the device context.</p></td>
</tr>
<tr>
<td>10</td>
<td><p><b>BitBlt</b></p>
<p>Copies a bitmap from a specified device context.</p></td>
</tr>
<tr>
<td>11</td>
<td><p><b>Chord</b></p>
<p>Draws a chord (a closed figure bounded by the intersection of an ellipse and a line segment).</p></td>
</tr>
<tr>
<td>12</td>
<td><p><b>CloseFigure</b></p>
<p>Closes an open figure in a path.</p></td>
</tr>
<tr>
<td>13</td>
<td><p><b>CreateCompatibleDC</b></p>
<p>Creates a memory-device context that is compatible with another device context. You can use it to prepare images in memory.</p></td>
</tr>
<tr>
<td>14</td>
<td><p><b>CreateDC</b></p>
<p>Creates a device context for a specific device.</p></td>
</tr>
<tr>
<td>15</td>
<td><p><b>CreateIC</b></p>
<p>Creates an information context for a specific device. This provides a fast way to get information about the device without creating a device context.</p></td>
</tr>
<tr>
<td>16</td>
<td><p><b>DeleteDC</b></p>
<p>Deletes the Windows device context associated with this CDC object.</p></td>
</tr>
<tr>
<td>17</td>
<td><p><b>DeleteTempMap</b></p>
<p>Called by the <b>CWinApp</b> idle-time handler to delete any temporary CDC object created by FromHandle. Also detaches the device context.</p></td>
</tr>
<tr>
<td>18</td>
<td><p><b>Detach</b></p>
<p>Detaches the Windows device context from this CDC object.</p></td>
</tr>
<tr>
<td>19</td>
<td><p><b>DPtoHIMETRIC</b></p>
<p>Converts device units into <b>HIMETRIC</b> units.</p></td>
</tr>
<tr>
<td>20</td>
<td><p><b>DPtoLP</b></p>
<p>Converts device units into logical units.</p></td>
</tr>
<tr>
<td>21</td>
<td><p><b>Draw3dRect</b></p>
<p>Draws a three-dimensional rectangle.</p></td>
</tr>
<tr>
<td>22</td>
<td><p><b>DrawDragRect</b></p>
<p>Erases and redraws a rectangle as it is dragged.</p></td>
</tr>
<tr>
<td>23</td>
<td><p><b>DrawEdge</b></p>
<p>Draws the edges of a rectangle.</p></td>
</tr><tr>
<td>24</td>
<td><p><b>DrawEscape</b></p>
<p>Accesses drawing capabilities of a video display that are not directly available through the graphics device interface (GDI).</p></td>
</tr>
<tr>
<td>25</td>
<td><p><b>DrawFocusRect</b></p>
<p>Draws a rectangle in the style used to indicate focus.</p></td>
</tr>
<tr>
<td>26</td>
<td><p><b>DrawFrameControl</b></p>
<p>Draw a frame control.</p></td>
</tr>
<tr>
<td>27</td>
<td><p><b>DrawIcon</b></p>
<p>Draws an icon.</p></td>
</tr>
<tr>
<td>28</td>
<td><p><b>DrawState</b></p>
<p>Displays an image and applies a visual effect to indicate a state.</p></td>
</tr><tr>
<td>29</td>
<td><p><b>DrawText</b></p>
<p>Draws formatted text in the specified rectangle.</p></td>
</tr><tr>
<td>30</td>
<td><p><b>DrawTextEx</b></p>
<p>Draws formatted text in the specified rectangle using additional formats.</p></td>
</tr>
<tr>
<td>31</td>
<td><p><b>Ellipse</b></p>
<p>Draws an ellipse.</p></td>
</tr><tr>
<td>32</td>
<td><p><b>EndDoc</b></p>
<p>Ends a print job started by the StartDoc member function.</p></td>
</tr><tr>
<td>33</td>
<td><p><b>EndPage</b></p>
<p>Informs the device driver that a page is ending.</p></td>
</tr><tr>
<td>34</td>
<td><p><b>EndPath</b></p>
<p>Closes a path bracket and selects the path defined by the bracket into the device context.</p></td>
</tr>
<tr>
<td>35</td>
<td><p><b>EnumObjects</b></p>
<p>Enumerates the pens and brushes available in a device context.</p></td>
</tr><tr>
<td>36</td>
<td><p><b>Escape</b></p>
<p>Allows applications to access facilities that are not directly available from a particular device through GDI. Also allows access to Windows escape functions. Escape calls made by an application are translated and sent to the device driver.</p></td>
</tr><tr>
<td>37</td>
<td><p><b>ExcludeClipRect</b></p>
<p>Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.</p></td>
</tr><tr>
<td>38</td>
<td><p><b>ExcludeUpdateRgn</b></p>
<p>Prevents drawing within invalid areas of a window by excluding an updated region in the window from a clipping region.</p></td>
</tr><tr>
<td>39</td>
<td><p><b>ExtFloodFill</b></p>
<p>Fills an area with the current brush. Provides more flexibility than the <b>FloodFill</b> member function.</p></td>
</tr><tr>
<td>40</td>
<td><p><b>ExtTextOut</b></p>
<p>Writes a character string within a rectangular region using the currently selected font.</p></td>
</tr><tr>
<td>41</td>
<td><p><b>FillPath</b></p>
<p>Closes any open figures in the current path and fills the path's interior by using the current brush and polygonfilling mode.</p></td>
</tr>
<tr>
<td>42</td>
<td><p><b>FillRect</b></p>
<p>Fills a given rectangle by using a specific brush.</p></td>
</tr>
<tr>
<td>43</td>
<td><p><b>FillRgn</b></p>
<p>Fills a specific region with the specified brush.</p></td>
</tr>
<tr>
<td>44</td>
<td><p><b>FillSolidRect</b></p>
<p>Fills a rectangle with a solid color.</p></td>
</tr>
<tr>
<td>45</td>
<td><p><b>FlattenPath</b></p>
<p>Transforms any curves in the path selected into the current device context, and turns each curve into a sequence of lines.</p></td>
</tr>
<tr>
<td>46</td>
<td><p><b>FloodFill</b></p>
<p>Fills an area with the current brush.</p></td>
</tr>
<tr>
<td>47</td>
<td><p><b>FrameRect</b></p>
<p>Draws a border around a rectangle.</p></td>
</tr>
<tr>
<td>48</td>
<td><p><b>FrameRgn</b></p>
<p>Draws a border around a specific region using a brush.</p></td>
</tr>
<tr>
<td>49</td>
<td><p><b>FromHandle</b></p>
<p>Returns a pointer to a CDC object when given a handle to a device context. If a CDC object is not attached to the handle, a temporary CDC object is created and attached.</p></td>
</tr>
<tr>
<td>50</td>
<td><p><b>GetArcDirection</b></p>
<p>Returns the current arc direction for the device context.</p></td>
</tr>
<tr>
<td>51</td>
<td><p><b>GetAspectRatioFilter</b></p>
<p>Retrieves the setting for the current aspect-ratio filter.</p></td>
</tr>
<tr>
<td>52</td>
<td><p><b>GetBkColor</b></p>
<p>Retrieves the current background color.</p></td>
</tr>
<tr>
<td>53</td>
<td><p><b>GetBkMode</b></p>
<p>Retrieves the background mode.</p></td>
</tr>
<tr>
<td>54</td>
<td><p><b>GetBoundsRect</b></p>
<p>Returns the current accumulated bounding rectangle for the specified device context.</p></td>
</tr>
<tr>
<td>55</td>
<td><p><b>GetBrushOrg</b></p>
<p>Retrieves the origin of the current brush.</p></td>
</tr>
<tr>
<td>56</td>
<td><p><b>GetCharABCWidths</b></p>
<p>Retrieves the widths, in logical units, of consecutive characters in a given range from the current font.</p></td>
</tr>
<tr>
<td>57</td>
<td><p><b>GetCharABCWidthsI</b></p>
<p>Retrieves the widths, in logical units, of consecutive glyph indices in a specified range from the current TrueType font.</p></td>
</tr>
<tr>
<td>58</td>
<td><p><b>GetCharacterPlacement</b></p>
<p>Retrieves various types of information on a character string.</p></td>
</tr><tr>
<td>59</td>
<td><p><b>GetCharWidth</b></p>
<p>Retrieves the fractional widths of consecutive characters in a given range from the current font.</p></td>
</tr>
<tr>
<td>60</td>
<td><p><b>GetCharWidthI</b></p>
<p>Retrieves the widths, in logical coordinates, of consecutive glyph indices in a specified range from the current font.</p></td>
</tr>
<tr>
<td>61</td>
<td><p><b>GetClipBox</b></p>
<p>Retrieves the dimensions of the tightest bounding rectangle around the current clipping boundary.</p></td>
</tr>
<tr>
<td>62</td>
<td><p><b>GetColorAdjustment</b></p>
<p>Retrieves the color adjustment values for the device context.</p></td>
</tr><tr>
<td>63</td>
<td><p><b>GetCurrentBitmap</b></p>
<p>Returns a pointer to the currently selected <b>CBitmap</b> object.</p></td>
</tr><tr>
<td>64</td>
<td><p><b>GetCurrentBrush</b></p>
<p>Returns a pointer to the currently selected <b>CBrush</b> object.</p></td>
</tr>
<tr>
<td>65</td>
<td><p><b>GetCurrentFont</b></p>
<p>Returns a pointer to the currently selected <b>CFont</b> object.</p></td>
</tr>
<tr>
<td>66</td>
<td><p><b>GetCurrentPalette</b></p>
<p>Returns a pointer to the currently selected <b>CPalette</b> object.</p></td>
</tr>
<tr>
<td>48</td>
<td><p><b>GetCurrentPen</b></p>
<p>Returns a pointer to the currently selected <b>CPen</b> object.</p></td>
</tr>
<tr>
<td>67</td>
<td><p><b>GetCurrentPosition</b></p>
<p>Retrieves the current position of the pen (in logical coordinates).</p></td>
</tr>
<tr>
<td>68</td>
<td><p><b>GetDCBrushColor</b></p>
<p>Retrieves the current brush color.</p></td>
</tr>
<tr>
<td>69</td>
<td><p><b>GetDCPenColor</b></p>
<p>Retrieves the current pen color.</p></td>
</tr>
<tr>
<td>70</td>
<td><p><b>GetDeviceCaps</b></p>
<p>Retrieves a specified kind of device-specific information about a given display device's capabilities.</p></td>
</tr>
<tr>
<td>71</td>
<td><p><b>GetFontData</b></p>
<p>Retrieves font metric information from a scalable font file. The information to retrieve is identified by specifying an offset into the font file and the length of the information to return.</p></td>
</tr>
<tr>
<td>72</td>
<td><p><b>GetFontLanguageInfo</b></p>
<p>Returns information about the currently selected font for the specified display context.</p></td>
</tr>
<tr>
<td>73</td>
<td><p><b>GetGlyphOutline</b></p>
<p>Retrieves the outline curve or bitmap for an outline character in the current font.</p></td>
</tr>
<tr>
<td>74</td>
<td><p><b>GetGraphicsMode</b></p>
<p>Retrieves the current graphics mode for the specified device context.</p></td>
</tr>
<tr>
<td>75</td>
<td><p><b>GetHalftoneBrush</b></p>
<p>Retrieves a halftone brush.</p></td>
</tr>
<tr>
<td>76</td>
<td><p><b>GetKerningPairs</b></p>
<p>Retrieves the character kerning pairs for the font that is currently selected in the specified device context.</p></td>
</tr>
<tr>
<td>77</td>
<td><p><b>GetLayout</b></p>
<p>Retrieves the layout of a device context (DC). The layout can be either left to right (default) or right to left (mirrored).</p></td>
</tr>
<tr>
<td>78</td>
<td><p><b>GetMapMode</b></p>
<p>Retrieves the current mapping mode.</p></td>
</tr>
<tr>
<td>79</td>
<td><p><b>GetMiterLimit</b></p>
<p>Returns the miter limit for the device context.</p></td>
</tr>
<tr>
<td>80</td>
<td><p><b>GetNearestColor</b></p>
<p>Retrieves the closest logical color to a specified logical color that the given device can represent.</p></td>
</tr>
<tr>
<td>81</td>
<td><p><b>GetOutlineTextMetrics</b></p>
<p>Retrieves font metric information for TrueType fonts.</p></td>
</tr>
<tr>
<td>82</td>
<td><p><b>GetOutputCharWidth</b></p>
<p>Retrieves the widths of individual characters in a consecutive group of characters from the current font using the output device context.</p></td>
</tr>
<tr>
<td>83</td>
<td><p><b>GetOutputTabbedTextExtent</b></p>
<p>Computes the width and height of a character string on the output device context.</p></td>
</tr>
<tr>
<td>84</td>
<td><p><b>GetOutputTextExtent</b></p>
<p>Computes the width and height of a line of text on the output device context using the current font to determine the dimensions.</p></td>
</tr>
<tr>
<td>85</td>
<td><p><b>GetOutputTextMetrics</b></p>
<p>Retrieves the metrics for the current font from the output device context.</p></td>
</tr>
<tr>
<td>86</td>
<td><p><b>GetPath</b></p>
<p>Retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the device context.</p></td>
</tr>
<tr>
<td>87</td>
<td><p><b>GetPixel</b></p>
<p>Retrieves the RGB color value of the pixel at the specified point.</p></td>
</tr>
<tr>
<td>88</td>
<td><p><b>GetPolyFillMode</b></p>
<p>Retrieves the current polygon-filling mode.</p></td>
</tr>
<tr>
<td>89</td>
<td><p><b>GetROP2</b></p>
<p>Retrieves the current drawing mode.</p></td>
</tr>
<tr>
<td>90</td>
<td><p><b>GetSafeHdc</b></p>
<p>Returns <b>m_hDC</b>, the output device context.</p></td>
</tr>
<tr>
<td>91</td>
<td><p><b>GetStretchBltMode</b></p>
<p>Retrieves the current bitmap-stretching mode.</p></td>
</tr>
<tr>
<td>92</td>
<td><p><b>GetTabbedTextExtent</b></p>
<p>Computes the width and height of a character string on the attribute device context.</p></td>
</tr>
<tr>
<td>93</td>
<td><p><b>GetTextAlign</b></p>
<p>Retrieves the text-alignment flags.</p></td>
</tr>
<tr>
<td>94</td>
<td><p><b>GetTextCharacterExtra</b></p>
<p>Retrieves the current setting for the amount of intercharacter spacing.</p></td>
</tr>
<tr>
<td>95</td>
<td><p><b>GetTextColor</b></p>
<p>Retrieves the current text color.</p></td>
</tr>
<tr>
<td>96</td>
<td><p><b>GetTextExtent</b></p>
<p>Computes the width and height of a line of text on the attribute device context using the current font to determine the dimensions.</p></td>
</tr>
<tr>
<td>97</td>
<td><p><b>GetTextExtentExPointI</b></p>
<p>Retrieves the number of characters in a specified string that will fit within a specified space and fills an array with the text extent for each of those characters.</p></td>
</tr>
<tr>
<td>98</td>
<td><p><b>GetTextExtentPointI</b></p>
<p>Retrieves the width and height of the specified array of
glyph indices.</p></td>
</tr>
<tr>
<td>99</td>
<td><p><b>GetTextFace</b></p>
<p>Copies the typeface name of the current font into a buffer as a null-terminated string.</p></td>
</tr>
<tr>
<td>100</td>
<td><p><b>GetTextMetrics</b></p>
<p>Retrieves the metrics for the current font from the attribute device context.</p></td>
</tr>
<tr>
<td>101</td>
<td><p><b>GetViewportExt</b></p>
<p>Retrieves the x- and y-extents of the viewport.</p></td>
</tr>
<tr>
<td>102</td>
<td><p><b>GetViewportOrg</b></p>
<p>Retrieves the x- and y-coordinates of the viewport origin.</p></td>
</tr>
<tr>
<td>103</td>
<td><p><b>GetWindow</b></p>
<p>Returns the window associated with the display device context.</p></td>
</tr>
<tr>
<td>104</td>
<td><p><b>GetWindowExt</b></p>
<p>Retrieves the x- and y-extents of the associated window.</p></td>
</tr>
<tr>
<td>105</td>
<td><p><b>GetWindowOrg</b></p>
<p>Retrieves the x- and y-coordinates of the origin of the associated window.</p></td>
</tr>
<tr>
<td>106</td>
<td><p><b>GetWorldTransform</b></p>
<p>Retrieves the current world-space to page-space transformation.</p></td>
</tr>
<tr>
<td>107</td>
<td><p><b>GradientFill</b></p>
<p>Fills rectangle and triangle structures with a gradating color.</p></td>
</tr>
<tr>
<td>108</td>
<td><p><b>GrayString</b></p>
<p>Draws dimmed (grayed) text at the given location.</p></td>
</tr>
<tr>
<td>109</td>
<td><p><b>HIMETRICtoDP</b></p>
<p>Converts HIMETRIC units into device units.</p></td>
</tr>
<tr>
<td>110</td>
<td><p><b>HIMETRICtoLP</b></p>
<p>Converts HIMETRIC units into logical units.</p></td>
</tr>
<tr>
<td>111</td>
<td><p><b>IntersectClipRect</b></p>
<p>Creates a new clipping region by forming the intersection of the current region and a rectangle.</p></td>
</tr>
<tr>
<td>112</td>
<td><p><b>InvertRect</b></p>
<p>Inverts the contents of a rectangle.</p></td>
</tr>
<tr>
<td>113</td>
<td><p><b>InvertRgn</b></p>
<p>Inverts the colors in a region.</p></td>
</tr>
<tr>
<td>114</td>
<td><p><b>IsPrinting</b></p>
<p>Determines whether the device context is being used for printing.</p></td>
</tr>
<tr>
<td>115</td>
<td><p><b>LineTo</b></p>
<p>Draws a line from the current position up to, but not including, a point.</p></td>
</tr>
<tr>
<td>116</td>
<td><p><b>LPtoDP</b></p>
<p>Converts logical units into device units.</p></td>
</tr><tr>
<td>117</td>
<td><p><b>LPtoHIMETRIC</b></p>
<p>Converts logical units into HIMETRIC units.</p></td>
</tr>
<tr>
<td>118</td>
<td><p><b>MaskBlt</b></p>
<p>Combines the color data for the source and destination bitmaps using the given mask and raster operation.</p></td>
</tr>
<tr>
<td>119</td>
<td><p><b>ModifyWorldTransform</b></p>
<p>Changes the world transformation for a device context using the specified mode.</p></td>
</tr><tr>
<td>120</td>
<td><p><b>MoveTo</b></p>
<p>Moves the current position.</p></td>
</tr>
<tr>
<td>121</td>
<td><p><b>OffsetClipRgn</b></p>
<p>Moves the clipping region of the given device.</p></td>
</tr>
<tr>
<td>122</td>
<td><p><b>OffsetViewportOrg</b></p>
<p>Modifies the viewport origin relative to the coordinates of the current viewport origin.</p></td>
</tr>
<tr>
<td>123</td>
<td><p><b>OffsetWindowOrg</b></p>
<p>Modifies the window origin relative to the coordinates of the current window origin.</p></td>
</tr>
<tr>
<td>124</td>
<td><p><b>PaintRgn</b></p>
<p>Fills a region with the selected brush.</p></td>
</tr>
<tr>
<td>125</td>
<td><p><b>PatBlt</b></p>
<p>Creates a bit pattern.</p></td>
</tr>
<tr>
<td>126</td>
<td><p><b>Pie</b></p>
<p>Draws a pie-shaped wedge.</p></td>
</tr>
<tr>
<td>127</td>
<td><p><b>PlayMetaFile</b></p>
<p>Plays the contents of the specified metafile on the given device. The enhanced version of PlayMetaFile displays the picture stored in the given enhanced-format metafile. The metafile can be played any number of times.</p></td>
</tr>
<tr>
<td>128</td>
<td><p><b>PlgBlt</b></p>
<p>Performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the given device context.</p></td>
</tr>
<tr>
<td>129</td>
<td><p><b>PolyBezier</b></p>
<p>Draws one or more Bzier splines. The current position is neither used nor updated.</p></td>
</tr>
<tr>
<td>130</td>
<td><p><b>PolyBezierTo</b></p>
<p>Draws one or more Bzier splines, and moves the current position to the ending point of the last Bzier spline.</p></td>
</tr>
<tr>
<td>131</td>
<td><p><b>PolyDraw</b></p>
<p>Draws a set of line segments and Bzier splines. This function updates the current position.</p></td>
</tr>
<tr>
<td>132</td>
<td><p><b>Polygon</b></p>
<p>Draws a polygon consisting of two or more points (vertices) connected by lines.</p></td>
</tr>
<tr>
<td>133</td>
<td><p><b>Polyline</b></p>
<p>Draws a set of line segments connecting the specified points.</p></td>
</tr>
<tr>
<td>134</td>
<td><p><b>PolylineTo</b></p>
<p>Draws one or more straight lines and moves the current position to the ending point of the last line.</p></td>
</tr>
<tr>
<td>135</td>
<td><p><b>PolyPolygon</b></p>
<p>Creates two or more polygons that are filled using the current polygon-filling mode. The polygons may be disjoint or they may overlap.</p></td>
</tr>
<tr>
<td>136</td>
<td><p><b>PolyPolyline</b></p>
<p>Draws multiple series of connected line segments. The current position is neither used nor updated by this function.</p></td>
</tr>
<tr>
<td>137</td>
<td><p><b>PtVisible</b></p>
<p>Specifies whether the given point is within the clipping region.</p></td>
</tr>
<tr>
<td>138</td>
<td><p><b>RealizePalette</b></p>
<p>Maps palette entries in the current logical palette to the
system palette.</p></td>
</tr>
<tr>
<td>139</td>
<td><p><b>Rectangle</b></p>
<p>Draws a rectangle using the current pen and fills it using the current brush.</p></td>
</tr>
<tr>
<td>140</td>
<td><p><b>RectVisible</b></p>
<p>Determines whether any part of the given rectangle lies within the clipping region.</p></td>
</tr>
<tr>
<td>141</td>
<td><p><b>ReleaseAttribDC</b></p>
<p>Releases <b>m_hAttribDC</b>, the attribute device context.</p></td>
</tr>
<tr>
<td>142</td>
<td><p><b>ReleaseOutputDC</b></p>
<p>Releases <b>m_hDC</b>, the output device context.</p></td>
</tr>
<tr>
<td>143</td>
<td><p>ResetDC<b></b></p>
<p>Updates the m_hAttribDC device context.</p></td>
</tr>
<tr>
<td>144</td>
<td><p><b>RestoreDC</b></p>
<p>Restores the device context to a previous state saved with <b>SaveDC</b>.</p></td>
</tr>
<tr>
<td>145</td>
<td><p><b>RoundRect</b></p>
<p>Draws a rectangle with rounded corners using the current pen and filled using the current brush.</p></td>
</tr>
<tr>
<td>146</td>
<td><p><b>SaveDC</b></p>
<p>Saves the current state of the device context.</p></td>
</tr>
<tr>
<td>147</td>
<td><p><b>ScaleViewportExt</b></p>
<p>Modifies the viewport extent relative to the current values.</p></td>
</tr>
<tr>
<td>148</td>
<td><p><b>ScaleWindowExt</b></p>
<p>Modifies the window extents relative to the current values.</p></td>
</tr>
<tr>
<td>149</td>
<td><p><b>ScrollDC</b></p>
<p>Scrolls a rectangle of bits horizontally and vertically.</p></td>
</tr>
<tr>
<td>150</td>
<td><p><b>SelectClipPath</b></p>
<p>Selects the current path as a clipping region for the device context, combining the new region with any existing clipping region by using the specified mode.</p></td>
</tr>
<tr>
<td>151</td>
<td><p><b>SelectClipRgn</b></p>
<p>Combines the given region with the current clipping region by using the specified mode.</p></td>
</tr>
<tr>
<td>152</td>
<td><p><b>SelectObject</b></p>
<p>Selects a GDI drawing object such as a pen.</p></td>
</tr>
<tr>
<td>153</td>
<td><p><b>SelectPalette</b></p>
<p>Selects the logical palette.</p></td>
</tr>
<tr>
<td>154</td>
<td><p><b>SelectStockObject</b></p>
<p>Selects one of the predefined stock pens, brushes, or fonts provided by Windows.</p></td>
</tr>
<tr>
<td>155</td>
<td><p><b>SetAbortProc</b></p>
<p>Sets a programmer-supplied callback function that Windows calls if a print job must be aborted.</p></td>
</tr>
<tr>
<td>156</td>
<td><p><b>SetArcDirection</b></p>
<p>Sets the drawing direction to be used for arc and rectangle functions.</p></td>
</tr>
<tr>
<td>157</td>
<td><p><b>SetAttribDC</b></p>
<p>Sets m_hAttribDC, the attribute device context.</p></td>
</tr>
<tr>
<td>158</td>
<td><p><b>SetBkColor</b></p>
<p>Sets the current background color.</p></td>
</tr>
<tr>
<td>159</td>
<td><p><b>SetBkMode</b></p>
<p>Sets the background mode.</p></td>
</tr>
<tr>
<td>160</td>
<td><p><b>SetBoundsRect</b></p>
<p>Controls the accumulation of bounding-rectangle information for the specified device context.</p></td>
</tr>
<tr>
<td>161</td>
<td><p><b>SetBrushOrg</b></p>
<p>Specifies the origin for the next brush selected into a device context.</p></td>
</tr>
<tr>
<td>162</td>
<td><p><b>SetColorAdjustment</b></p>
<p>Sets the color adjustment values for the device context using the specified values.</p></td>
</tr>
<tr>
<td>163</td>
<td><p><b>SetDCBrushColor</b></p>
<p>Sets the current brush color.</p></td>
</tr>
<tr>
<td>164</td>
<td><p><b>SetDCPenColor</b></p>
<p>Sets the current pen color.</p></td>
</tr>
<tr>
<td>165</td>
<td><p><b>SetGraphicsMode</b></p>
<p>Sets the current graphics mode for the specified device context.</p></td>
</tr>
<tr>
<td>166</td>
<td><p><b>SetLayout</b></p>
<p>Changes the layout of a device context (DC).</p></td>
</tr>
<tr>
<td>167</td>
<td><p><b>SetMapMode</b></p>
<p>Sets the current mapping mode.</p></td>
</tr>
<tr>
<td>168</td>
<td><p><b>SetMapperFlags</b></p>
<p>Alters the algorithm that the font mapper uses when it maps logical fonts to physical fonts.</p></td>
</tr>
<tr>
<td>169</td>
<td><p><b>SetMiterLimit</b></p>
<p>Sets the limit for the length of miter joins for the device context.</p></td>
</tr>
<tr>
<td>170</td>
<td><p><b>SetOutputDC</b></p>
<p>Sets m_hDC, the output device context.</p></td>
</tr>
<tr>
<td>171</td>
<td><p><b>SetPixel</b></p>
<p>Sets the pixel at the specified point to the closest approximation of the specified color.</p></td>
</tr>
<tr>
<td>172</td>
<td><p><b>SetPixelV</b></p>
<p>Sets the pixel at the specified coordinates to the closest approximation of the specified color. <b>SetPixelV</b> is faster than <b>SetPixel</b> because it does not need to return the color value of the point actually painted.</p></td>
</tr>
<tr>
<td>173</td>
<td><p><b>SetPolyFillMode</b></p>
<p>Sets the polygon-filling mode.</p></td>
</tr>
<tr>
<td>175</td>
<td><p><b>SetROP2</b></p>
<p>Sets the current drawing mode.</p></td>
</tr>
<tr>
<td>176</td>
<td><p><b>SetStretchBltMode</b></p>
<p>Sets the bitmap-stretching mode.</p></td>
</tr>
<tr>
<td>177</td>
<td><p><b>SetTextAlign</b></p>
<p>Sets the text-alignment flags.</p></td>
</tr><tr>
<td>178</td>
<td><p><b>SetTextCharacterExtra</b></p>
<p>Sets the amount of intercharacter spacing.</p></td>
</tr>
<tr>
<td>179</td>
<td><p><b>SetTextColor</b></p>
<p>Sets the text color.</p></td>
</tr>
<tr>
<td>180</td>
<td><p><b>SetTextJustification</b></p>
<p>Adds space to the break characters in a string.</p></td>
</tr>
<tr>
<td>181</td>
<td><p><b>SetViewportExt</b></p>
<p>Sets the x- and y-extents of the viewport.</p></td>
</tr>
<tr>
<td>182</td>
<td><p><b>SetViewportOrg</b></p>
<p>Sets the viewport origin.</p></td>
</tr>
<tr>
<td>183</td>
<td><p><b>SetWindowExt</b></p>
<p>Sets the x- and y-extents of the associated window.</p></td>
</tr>
<tr>
<td>184</td>
<td><p><b>SetWindowOrg</b></p>
<p>Sets the window origin of the device context.</p></td>
</tr>
<tr>
<td>185</td>
<td><p><b>SetWorldTransform</b></p>
<p>Sets the current world-space to page-space transformation.</p></td>
</tr>
<tr>
<td>186</td>
<td><p><b>StartDoc</b></p>
<p>Informs the device driver that a new print job is starting.</p></td>
</tr>
<tr>
<td>187</td>
<td><p><b>StartPage</b></p>
<p>Informs the device driver that a new page is starting.</p></td>
</tr>
<tr>
<td>188</td>
<td><p><b>StretchBlt</b></p>
<p>Moves a bitmap from a source rectangle and device into a destination rectangle, stretching or compressing the bitmap if necessary to fit the dimensions of the destination rectangle.</p></td>
</tr>
<tr>
<td>189</td>
<td><p><b>StrokeAndFillPath</b></p>
<p>Closes any open figures in a path, strikes the outline of the path by using the current pen, and fills its interior by using the current brush.</p></td>
</tr><tr>
<td>190</td>
<td><p><b>StrokePath</b></p>
<p>Renders the specified path by using the current pen.</p></td>
</tr><tr>
<td>191</td>
<td><p><b>TabbedTextOut</b></p>
<p>Writes a character string at a specified location, expanding tabs to the values specified in an array of tab-stop positions.</p></td>
</tr>
<tr>
<td>192</td>
<td><p><b>TextOut</b></p>
<p>Writes a character string at a specified location using the currently selected font.</p></td>
</tr>
<tr>
<td>193</td>
<td><p><b>TransparentBlt</b></p>
<p>Transfers a bit-block of color data from the specified source device context into a destination device context, rendering a specified color transparent in the transfer.</p></td>
</tr>
<tr>
<td>194</td>
<td><p><b>UpdateColors</b></p>
<p>Updates the client area of the device context by matching the current colors in the client area to the system palette on a pixel-by-pixel basis.</p></td>
</tr>
<tr>
<td>195</td>
<td><p><b>WidenPath</b></p>
<p>Redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the device context.</p></td>
</tr>
</table>
</div>
</section>
<h2>Lines</h2>
<p><b>Step 1</b> &minus; Let us look into a simple example by creating a new MFC based single document project with <b>MFCGDIDemo</b> name.</p>
<img src="/mfc/images/lines1.jpg" alt="Lines" />
<p><b>Step 2</b> &minus; Once the project is created, go the Solution Explorer and double click on the <b>MFCGDIDemoView.cpp</b> file under the Source Files folder.</p>
<p><b>Step 3</b> &minus; Draw the line as shown below in <b>CMFCGDIDemoView::OnDraw()</b> method.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   pDC-&gt;MoveTo(95, 125);
   pDC-&gt;LineTo(230, 125);
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p><b>Step 4</b> &minus; Run this application. You will see the following output.</p>
<img src="/mfc/images/lines2.jpg" alt="Lines" />
<p><b>Step 5</b> &minus; The CDC::MoveTo() method is used to set the starting position of a line.</p>
<p>When using LineTo(), the program starts from the MoveTo() point to the LineTo() end.</p>
<p>After LineTo() when you do not call MoveTo(), and call again LineTo() with other point value, the program will draw a line from the previous LineTo() to the new LineTo() point.</p>
<p><b>Step 6</b> &minus; To draw different lines, you can use this property as shown in the following code.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) { 
   pDC-&gt;MoveTo(95, 125);
   pDC-&gt;LineTo(230, 125);
   pDC-&gt;LineTo(230, 225);
   pDC-&gt;LineTo(95, 325);
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here 
}
</pre>
<p><b>Step 7</b> &minus; Run this application. You will see the following output.</p>
<img src="/mfc/images/lines3.jpg" alt="Lines" />
<h2>Polylines</h2>
<p>A <b>polyline</b> is a series of connected lines. The lines are stored in an array of POINT or CPoint values. To draw a polyline, you use the CDC::Polyline() method. To draw a polyline, at least two points are required. If you define more than two points, each line after the first would be drawn from the previous point to the next point until all points have been included.</p>
<p><b>Step 1</b> &minus; Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   CPoint Pt[7];
   Pt[0] = CPoint(20, 150);
   Pt[1] = CPoint(180, 150);
   Pt[2] = CPoint(180, 20);
   pDC&minus;Polyline(Pt, 3);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p><b>Step 2</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/polylines.jpg" alt="Polylines" />
<h2>Rectangles</h2>
<p>A <b>rectangle</b> is a geometric figure made of four sides that compose four right angles. Like the line, to draw a rectangle, you must define where it starts and where it ends. To draw a rectangle, you can use the CDC::Rectangle() method.</p>
<p><b>Step 1</b> &minus; Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   pDC-&gt;Rectangle(15, 15, 250, 160);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p><b>Step 2</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/rectangles.jpg" alt="Rectangles" />
<h2>Squares</h2>
<p>A <b>square</b> is a geometric figure made of four sides that compose four right angles, but each side must be equal in length.</p>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   pDC-&gt;Rectangle(15, 15, 250, 250);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p>When you run this application, you will see the following output.</p>
<img src="/mfc/images/squares.jpg" alt="Squares" />
<h2>Pies</h2>
<p>A <b>pie</b> is a fraction of an ellipse delimited by two lines that span from the center of the ellipse to one side each. To draw a pie, you can use the CDC::Pie() method as shown below &minus;</p>
<p>BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);</p>
<ul class="list">
<li><p>The (x1, y1) point determines the upper-left corner of the rectangle in which the ellipse that represents the pie fits. The (x2, y2) point is the bottom-right corner of the rectangle.</p></li>
</ul>
<img src="/mfc/images/pies1.jpg" alt="Pies" />
<ul class="list">
<li><p>The (x3, y3) point specifies the starting corner of the pie in a default counterclockwise direction.</p></li>
<li><p>The (x4, y4) point species the end point of the pie.</p></li>
</ul>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   pDC-&gt;Pie(40, 20, 226, 144, 155, 32, 202, 115);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p><b>Step 2</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/pies2.jpg" alt="Pies" />
<h2>Arcs</h2>
<p>An arc is a portion or segment of an ellipse, meaning an arc is a non-complete ellipse. To draw an arc, you can use the CDC::Arc() method.</p>
<p>BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);</p>
<img src="/mfc/images/arcs1.jpg" alt="Arcs" />
<p>The CDC class is equipped with the SetArcDirection() method.</p>
<p>Here is the syntax &minus;</p>
<pre class="result notranslate">
int SetArcDirection(int nArcDirection)
</pre>
<p></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:5%;">Sr.No.</th>
<th style="text-align:center;">Value &amp; Orientation</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>AD_CLOCKWISE</b></p>
<p>The figure is drawn clockwise</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>AD_COUNTERCLOCKWISE</b></p>
<p>The figure is drawn counterclockwise</p></td>
</tr>
</table>
<p><b>Step 1</b> &minus; Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   pDC-&gt;SetArcDirection(AD_COUNTERCLOCKWISE);
   pDC-&gt;Arc(20, 20, 226, 144, 202, 115, 105, 32);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p><b>Step 2</b> &minus; When you run this application, you will see the following output.</p>
<img src="/mfc/images/arcs2.jpg" alt="Arcs" />
<h2>Chords</h2>
<p>The arcs we have drawn so far are considered open figures because they are made of a line that has a beginning and an end (unlike a circle or a rectangle that do not). A <b>chord</b> is an arc whose two ends are connected by a straight line.</p>
<img src="/mfc/images/chords1.jpg" alt="Chords" />
<p>To draw a chord, you can use the CDC::Chord() method.</p>
<p>BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);</p>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   pDC-&gt;SetArcDirection(AD_CLOCKWISE);
   pDC-&gt;Chord(20, 20, 226, 144, 202, 115, 105, 32);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p>When you run the above application, you will see the following output.</p>
<img src="/mfc/images/chords2.jpg" alt="Chords" />
<p>The arc direction in this example is set clockwise.</p>
<h2>Colors</h2>
<p>The <b>color</b> is one the most fundamental objects that enhances the aesthetic appearance of an object. The color is a non-spatial object that is added to an object to modify some of its visual aspects. The MFC library, combined with the Win32 API, provides various actions you can use to take advantage of the various aspects of colors.</p>
<p>The RGB macro behaves like a function and allows you to pass three numeric values separated by a comma. Each value must be between 0 and 255 as shown in the following code.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   COLORREF color = RGB(239, 15, 225);
}
</pre>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   COLORREF color = RGB(239, 15, 225);
   pDC-&gt;SetTextColor(color);
   pDC-&gt;TextOut(100, 80, L"MFC GDI Tutorial", 16);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p>When you run this application, you will see the following output.</p>
<img src="/mfc/images/colors.jpg" alt="Colors" />
<h2>Fonts</h2>
<p><b>CFont</b> encapsulates a Windows graphics device interface (GDI) font and provides member functions for manipulating the font. To use a CFont object, construct a CFont object and attach a Windows font to it, and then use the object's member functions to manipulate the font.</p> 
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here is a list of methods in CFont class.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>CreateFont</b></p>
<p>Initializes a CFont with the specified characteristics.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>CreateFontIndirect</b></p>
<p>Initializes a CFont object with the characteristics given in a <b>LOGFONT</b> structure.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>CreatePointFont</b></p>
<p>Initializes a CFont with the specified height, measured in tenths of a point, and typeface.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>CreatePointFontIndirect</b></p>
<p>Same as <b>CreateFontIndirect</b> except that the font height is measured in tenths of a point rather than logical units.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>FromHandle</b></p>
<p>Returns a pointer to a CFont object when given a Windows <b>HFONT</b>.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>GetLogFont</b></p>
<p>Fills a LOGFONT with information about the logical font attached to the CFont object.</p></td>
</tr>
</table>
</div>
</section>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   CFont font;
   font.CreatePointFont(920, L"Garamond");
   CFont *pFont = pDC-&gt;SelectObject(&amp;font);
   COLORREF color = RGB(239, 15, 225);
   pDC-&gt;SetTextColor(color);
   pDC-&gt;TextOut(100, 80, L"MFC GDI Tutorial", 16);
   pDC-&gt;SelectObject(pFont);
   font.DeleteObject();
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
   return;

   // TODO: add draw code for native data here
}
</pre>
<p>When you run the above application, you will see the following output.</p>
<img src="/mfc/images/fonts.jpg" alt="Fonts" />
<h2>Pens</h2>
<p>A <b>pen</b> is a tool used to draw lines and curves on a device context. In the graphics programming, a pen is also used to draw the borders of a geometric closed shape such as a rectangle or a polygon. Microsoft Windows considers two types of pens — <b>cosmetic</b> and <b>geometric</b>.</p>
<p>A pen is referred to as cosmetic when it can be used to draw only simple lines of a fixed width, less than or equal to 1 pixel. A pen is geometric when it can assume different widths and various ends. MFC provides a class <b>CPen</b> which encapsulates a Windows graphics device interface (GDI) pen.</p> 
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here is a list of methods in CPen class.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:5%;">Sr.No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>CreatePen</b></p>
<p>Creates a logical cosmetic or geometric pen with the specified style, width, and brush attributes, and attaches it to the CPen object.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>CreatePenIndirect</b></p>
<p>Creates a pen with the style, width, and color given in a LOGPEN structure, and attaches it to the CPen object.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>FromHandle</b></p>
<p>Returns a pointer to a CPen object when
given a Windows <b>HPEN</b>.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>GetExtLogPen</b></p>
<p>Gets an EXTLOGPEN underlying structure.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>GetLogPen</b></p>
<p>Gets a <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/ns-wingdi-taglogpen"target="_blank" rel="nofollow">LOGPEN</a> underlying structure.</p></td>
</tr>
</table>
</div>
</section>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here the different style values for pen</label>
<div class="toggle-content" style="display: none;"> 
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:5%;">Sr.No.</th>
<th style="text-align:center;"><b>Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>PS_SOLID</b></p>
<p>A continuous solid line.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>PS_DASH</b></p>
<p>A continuous line with dashed interruptions.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>PS_DOT</b></p>
<p>A line with a dot interruption at every other pixel.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>PS_DASHDOT</b></p>
<p>A combination of alternating dashed and dotted points.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>PS_DASHDOTDOT</b></p>
<p>A combination of dash and double dotted interruptions.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>PS_NULL</b></p>
<p>No visible line.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>PS_INSIDEFRAME</b></p>
<p>A line drawn just inside of the border of a closed shape.</p></td>
</tr>
</table>
</div>
</section>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   CPen pen;
   pen.CreatePen(PS_DASHDOTDOT, 1, RGB(160, 75, 90));
   pDC-&gt;SelectObject(&amp;pen);
   pDC-&gt;Rectangle(25, 35, 250, 125);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p>When you run the above application, you will see the following output.</p>
<img src="/mfc/images/pens.jpg" alt="Pens" />
<h2>Brushes</h2>
<p>A <b>brush</b> is a drawing tool used to fill out closed shaped or the interior of lines. A brush behaves like picking up a bucket of paint and pouring it somewhere. MFC provides a class <b>CBrush</b> which encapsulates a Windows graphics device interface (GDI) brush.</p> 
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Here is a list of methods in CBrush class.</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Sr.NO.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>CreateBrushIndirect</b></p>
<p>Initializes a brush with the style, color, and pattern specified in a LOGBRUSH structure.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>CreateDIBPatternBrush</b></p>
<p>Initializes a brush with a pattern specified by a device-independent bitmap (DIB).</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>CreateHatchBrush</b></p>
<p>Initializes a brush with the specified hatched pattern and color.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>CreatePatternBrush</b></p>
<p>Initializes a brush with a pattern specified by a bitmap.</p></td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>CreateSolidBrush</b></p>
<p>Initializes a brush with the specified solid color.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>CreateSysColorBrush</b></p>
<p>Creates a brush that is the default system color.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td><p><b>FromHandle</b></p>
<p>Returns a pointer to a CBrush object when given a handle to a Windows HBRUSH object.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td><p><b>GetLogBrush</b></p>
<p>Gets a LOGBRUSH structure.</p></td>
</tr>
</table>
</div>
</section>
<p>Let us look into a simple example.</p>
<pre class="prettyprint notranslate">
void CMFCGDIDemoView::OnDraw(CDC* pDC) {
   CBrush brush(RGB(100, 150, 200));
   CBrush *pBrush = pDC-&gt;SelectObject(&amp;brush);
   pDC-&gt;Rectangle(25, 35, 250, 125);
   pDC-&gt;SelectObject(pBrush);
   
   CMFCGDIDemoDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);
   if (!pDoc)
      return;

   // TODO: add draw code for native data here
}
</pre>
<p>When you run this application, you will see the following output.</p>
<img src="/mfc/images/brushes.jpg" alt="Brushes" />
<h1>MFC - Libraries</h1>
<p>A <b>library</b> is a group of functions, classes, or other resources that can be made available to programs that need already implemented entities without the need to know how these functions, classes, or resources were created or how they function. A library makes it easy for a programmer to use functions, classes, and resources etc. created by another person or company and trust that this external source is reliable and efficient. Some unique features related to libraries are &minus;</p>
<ul class="list">
<li><p>A library is created and functions like a normal regular program, using functions or other resources and communicating with other programs.</p></li>
<li><p>To implement its functionality, a library contains functions that other programs would need to complete their functionality.</p></li>
<li><p>At the same time, a library may use some functions that other programs would not need.</p></li>
<li><p>The program that uses the library, are also called the clients of the library.</p></li>
</ul>
<p>There are two types of functions you will create or include in your libraries &minus;</p>
<ul class="list">
<li><p>An internal function is one used only by the library itself and clients of the library will not need access to these functions.</p></li>
<li><p>External functions are those that can be accessed by the clients of the library.</p></li>
</ul>
<p>There are two broad categories of libraries you will deal with in your programs &minus;</p>
<ul class="list">
<li>Static libraries</li>
<li>Dynamic libraries</li>
</ul>
<h2>Static Library</h2>
<p>A <b>static library</b> is a file that contains functions, classes, or resources that an external program can use to complement its functionality. To use a library, the programmer has to create a link to it. The project can be a console application, a Win32 or an MFC application. The library file has the lib extension.</p>
<p><b>Step 1</b> &minus; Let us look into a simple example of static library by creating a new Win32 Project.</p>
<img src="/mfc/images/static_library1.jpg" alt="Static Library" />
<p><b>Step 2</b> &minus; On Application Wizard dialog box, choose the Static Library option.</p>
<img src="/mfc/images/static_library2.jpg" alt="Static Library" />
<p><b>Step 3</b> &minus; Click Finish to continue.</p>
<img src="/mfc/images/static_library3.jpg" alt="Static Library" />
<p><b>Step 4</b> &minus; Right-click on the project in solution explorer and add a header file from Add &rarr; New Item…menu option.</p>
<img src="/mfc/images/static_library4.jpg" alt="Static Library" />
<p><b>Step 5</b> &minus; Enter Calculator.h in the Name field and click Add.</p>
<p>Add the following code in the header file &minus;</p>
<pre class="result notranslate">
#pragma once
#ifndef _CALCULATOR_H_
#define _CALCULATOR_H_
double Min(const double *Numbers, const int Count);
double Max(const double *Numbers, const int Count);
double Sum(const double *Numbers, const int Count);
double Average(const double *Numbers, const int Count);
long GreatestCommonDivisor(long Nbr1, long Nbr2);
#endif // _CALCULATOR_H_
</pre>
<p><b>Step 6</b> &minus; Add a source (*.cpp) file in the project.</p>
<img src="/mfc/images/static_library5.jpg" alt="Static Library" />
<p><b>Step 7</b> &minus; Enter Calculator.cpp in the Name field and click Add.</p>
<p><b>Step 8</b> &minus; Add the following code in the *.cpp file &minus;</p>
<pre class="prettyprint notranslate">
#include "StdAfx.h"
#include "Calculator.h"
double Min(const double *Nbr, const int Total) {
   double Minimum = Nbr[0];
   for (int i = 0; i &lt; Total; i++)
      if (Minimum &gt; Nbr[i])
         Minimum = Nbr[i];
   return Minimum;
}
double Max(const double *Nbr, const int Total) {
   double Maximum = Nbr[0];
   for (int i = 0; i &lt; Total; i++)
      if (Maximum &lt; Nbr[i])
         Maximum = Nbr[i];
   return Maximum;
}
double Sum(const double *Nbr, const int Total) {
   double S = 0;
   for (int i = 0; i &lt; Total; i++)
      S += Nbr[i];
   return S;
}
double Average(const double *Nbr, const int Total) {
   double avg, S = 0;
   for (int i = 0; i &lt; Total; i++)
       S += Nbr[i];
   avg = S / Total;
   return avg;
}
long GreatestCommonDivisor(long Nbr1, long Nbr2) {
   while (true) {
      Nbr1 = Nbr1 % Nbr2;
      if (Nbr1 == 0)
         return Nbr2;
      Nbr2 = Nbr2 % Nbr1;
      if (Nbr2 == 0)
         return Nbr1;
   }
}
</pre>
<p><b>Step 9</b> &minus; Build this library from the main menu, by clicking <b>Build &rarr; Build MFCLib</b>.</p>
<img src="/mfc/images/static_library6.jpg" alt="Static Library" />
<p><b>Step 10</b> &minus; When library is built successfully, it will display the above message.</p>
<p><b>Step 11</b> &minus; To use these functions from the library, let us add another MFC dialog application based from File &rarr; New &rarr; Project.</p>
<img src="/mfc/images/static_library7.jpg" alt="Static Library" />
<p><b>Step 12</b> &minus; Go to the MFCLib\Debug folder and copy the header file and *.lib files to the MFCLibTest project as shown in the following snapshot.</p>
<img src="/mfc/images/static_library8.jpg" alt="Static Library" />
<p><b>Step 13</b> &minus; To add the library to the current project, on the main menu, click Project &rarr; Add Existing Item and select MFCLib.lib.</p>
<p><b>Step 14</b> &minus; Design your dialog box as shown in the following snapshot.</p>
<img src="/mfc/images/static_library9.jpg" alt="Static Library" />
<p><b>Step 15</b> &minus; Add value variable for both edit controls of value type double.</p>
<img src="/mfc/images/static_library10.jpg" alt="Static Library" />
<p><b>Step 16</b> &minus; Add value variable for Static text control, which is at the end of the dialog box.</p>
<img src="/mfc/images/static_library11.jpg" alt="Static Library" />
<p><b>Step 17</b> &minus; Add the event handler for Calculate button.</p>
<p>To add functionality from the library, we need to include the header file in CMFCLibTestDlg.cpp file.</p>
<pre class="result notranslate">
#include "stdafx.h"
#include "MFCLibTest.h"
#include "MFCLibTestDlg.h"
#include "afxdialogex.h"
#include "Calculator.h"
</pre>
<p><b>Step 18</b> &minus; Here is the implementation of button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCLibTestDlg::OnBnClickedButtonCal() {
   // TODO: Add your control notification handler code here
   UpdateData(TRUE);
   CString strTemp;
   double numbers[2];
   numbers[0] = m_Num1;
   numbers[1] = m_Num2;

   strTemp.Format(L"%.2f", Max(numbers,2));
   m_strText.Append(L"Max is:\t" + strTemp);

   strTemp.Format(L"%.2f", Min(numbers, 2));
   m_strText.Append(L"\nMin is:\t" + strTemp);
   
   strTemp.Format(L"%.2f", Sum(numbers, 2));
   m_strText.Append(L"\nSum is:\t" + strTemp);

   strTemp.Format(L"%.2f", Average(numbers, 2));
   m_strText.Append(L"\nAverage is:\t" + strTemp);

   strTemp.Format(L"%d", GreatestCommonDivisor(m_Num1, m_Num2));
   m_strText.Append(L"\nGDC is:\t" + strTemp);

   UpdateData(FALSE);
}
</pre>
<p><b>Step 19</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/static_library12.jpg" alt="Static Library" />
<p><b>Step 20</b> &minus; Enter two values in the edit field and click Calculate. You will now see the result after calculating from the library.</p>
<img src="/mfc/images/static_library13.jpg" alt="Static Library" />
<h2>Dynamic Library</h2>
<p>A Win32 DLL is a library that can be made available to programs that run on a Microsoft Windows computer. As a normal library, it is made of functions and/or other resources grouped in a file.</p>
<p>The DLL abbreviation stands for Dynamic Link Library. This means that, as opposed to a static library, a DLL allows the programmer to decide on when and how other applications will be linked to this type of library.</p>
<p>For example, a DLL allows difference applications to use its library as they see fit and as necessary. In fact, applications created on different programming environments can use functions or resources stored in one particular DLL. For this reason, an application dynamically links to the library.</p>
<p><b>Step 1</b> &minus; Let us look into a simple example by creating a new Win32 Project.</p>
<img src="/mfc/images/dynamic_library1.jpg" alt="Dynamic Library" />
<p><b>Step 2</b> &minus; In the Application Type section, click the DLL radio button.</p>
<img src="/mfc/images/dynamic_library2.jpg" alt="Dynamic Library" />
<p><b>Step 3</b> &minus; Click Finish to continue.</p>
<p><b>Step 4</b> &minus; Add the following functions in MFCDynamicLib.cpp file and expose its definitions by using &minus;</p>
<pre class="result notranslate">
extern "C" _declspec(dllexport)
</pre>
<p><b>Step 5</b> &minus; Use the _declspec(dllexport) modifier for each function that will be accessed outside the DLL.</p>
<pre class="prettyprint notranslate">
// MFCDynamicLib.cpp : Defines the exported functions for the DLL application.//

#include "stdafx.h"

extern "C" _declspec(dllexport) double Min(const double *Numbers, const int Count);
extern "C" _declspec(dllexport) double Max(const double *Numbers, const int Count);
extern "C" _declspec(dllexport) double Sum(const double *Numbers, const int Count);
extern "C" _declspec(dllexport) double Average(const double *Numbers, const int Count);
extern "C" _declspec(dllexport) long GreatestCommonDivisor(long Nbr1, long Nbr2);

double Min(const double *Nbr, const int Total) {
   double Minimum = Nbr[0];
   for (int i = 0; i &lt; Total; i++)
      if (Minimum &gt; Nbr[i])
         Minimum = Nbr[i];
   return Minimum;
}
double Max(const double *Nbr, const int Total) {
   double Maximum = Nbr[0];
   for (int i = 0; i &lt; Total; i++)
      if (Maximum &lt; Nbr[i])
         Maximum = Nbr[i];
   return Maximum;
}
double Sum(const double *Nbr, const int Total) {
   double S = 0;
   for (int i = 0; i &lt; Total; i++)
      S += Nbr[i];
   return S;
}
double Average(const double *Nbr, const int Total){
   double avg, S = 0;
   for (int i = 0; i &lt; Total; i++)
      S += Nbr[i];
   avg = S / Total;
   return avg;
}
long GreatestCommonDivisor(long Nbr1, long Nbr2) {
   while (true) {
      Nbr1 = Nbr1 % Nbr2;
      if (Nbr1 == 0)
         return Nbr2;
      Nbr2 = Nbr2 % Nbr1;
      if (Nbr2 == 0)
         return Nbr1;
   }
}
</pre>
<p><b>Step 6</b> &minus; To create the DLL, on the main menu, click <b>Build &gt; Build MFCDynamicLib</b> from the main menu.</p>
<img src="/mfc/images/dynamic_library3.jpg" alt="Dynamic Library" />
<p><b>Step 7</b> &minus; Once the DLL is successfully created, you will see amessage display in output window.</p>
<p><b>Step 8</b> &minus; Open Windows Explorer and then the Debug folder of the current project.</p>
<p><b>Step 9</b> &minus; Notice that a file with dll extension and another file with lib extension has been created.</p>
<img src="/mfc/images/dynamic_library4.jpg" alt="Dynamic Library" />
<p><b>Step 10</b> &minus; To test this file with dll extension, we need to create a new MFC dialog based application from File &rarr; New &rarr; Project.</p>
<img src="/mfc/images/dynamic_library5.jpg" alt="Dynamic Library" />
<p><b>Step 11</b> &minus; Go to the MFCDynamicLib\Debug folder and copy the *.dll and *.lib files to the MFCLibTest project as shown in the following snapshot.</p>
<img src="/mfc/images/dynamic_library6.jpg" alt="Dynamic Library" />
<p><b>Step 12</b> &minus; To add the DLL to the current project, on the main menu, click Project &rarr; Add Existing Item and then, select MFCDynamicLib.lib file.</p>
<p><b>Step 13</b> &minus; Design your dialog box as shown in the following snapshot.</p>
<img src="/mfc/images/dynamic_library7.jpg" alt="Dynamic Library" />
<p><b>Step 14</b> &minus; Add value variable for both edit controls of value type double.</p>
<img src="/mfc/images/dynamic_library8.jpg" alt="Dynamic Library" />
<p><b>Step 15</b> &minus; Add value variable for Static text control, which is at the end of the dialog box.</p>
<img src="/mfc/images/dynamic_library9.jpg" alt="Dynamic Library" />
<p><b>Step 16</b> &minus; Add the event handler for Calculate button.</p>
<p><b>Step 17</b> &minus; In the project that is using the DLL, each function that will be accessed must be declared using the _declspec(dllimport) modifier.</p>
<p><b>Step 18</b> &minus; Add the following function declaration in MFCLibTestDlg.cpp file.</p>
<pre class="result notranslate">
extern "C" _declspec(dllimport) double Min(const double *Numbers, const int Count);
extern "C" _declspec(dllimport) double Max(const double *Numbers, const int Count);
extern "C" _declspec(dllimport) double Sum(const double *Numbers, const int Count);
extern "C" _declspec(dllimport) double Average(const double *Numbers, const int Count);
extern "C" _declspec(dllimport) long GreatestCommonDivisor(long Nbr1, long Nbr2);
</pre>
<p><b>Step 19</b> &minus; Here is the implementation of button event handler.</p>
<pre class="prettyprint notranslate">
void CMFCLibTestDlg::OnBnClickedButtonCal() {

   // TODO: Add your control notification handler code here
   UpdateData(TRUE);

   CString strTemp;
   double numbers[2];
   numbers[0] = m_Num1;
   numbers[1] = m_Num2;

   strTemp.Format(L"%.2f", Max(numbers,2));
   m_strText.Append(L"Max is:\t" + strTemp);

   strTemp.Format(L"%.2f", Min(numbers, 2));
   m_strText.Append(L"\nMin is:\t" + strTemp);

   strTemp.Format(L"%.2f", Sum(numbers, 2));
   m_strText.Append(L"\nSum is:\t" + strTemp);

   strTemp.Format(L"%.2f", Average(numbers, 2));
   m_strText.Append(L"\nAverage is:\t" + strTemp);

   strTemp.Format(L"%d", GreatestCommonDivisor(m_Num1, m_Num2));
   m_strText.Append(L"\nGDC is:\t" + strTemp);
 
   UpdateData(FALSE);
}
</pre>
<p><b>Step 20</b> &minus; When the above code is compiled and executed, you will see the following output.</p>
<img src="/mfc/images/dynamic_library10.jpg" alt="Dynamic Library" />
<p><b>Step 21</b> &minus; Enter two values in the edit field and click Calculate. You will now see the result after calculating from the DLL.</p>
<img src="/mfc/images/dynamic_library11.jpg" alt="Dynamic Library" />
<div class="mui-container-fluid button-borders show">
<div class="pre-btn">
<a href="/mfc/mfc_libraries.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/mfc/mfc_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="google-bottom-ads">
<div>Advertisements</div>
<script><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class="space-bottom"></div>
</div>
</div>
<!-- Tutorial Content Ends Here -->
<!-- Right Column Starts Here -->
<div class="mui-col-md-2 google-right-ads">
<div class="space-top"></div>
<div class="google-right-ad" style="margin: 0px auto !important;margin-top:5px;">
<script><!--
google_ad_client = "pub-2537027957187252";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9012177"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9012177")})</script>
</div>
<div class="space-bottom"></div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9013289"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9013289")})</script>
</div>
<div class="space-bottom" style="margin-bottom:15px;"></div>
</div>
<!-- Right Column Ends Here -->
</div>
</div>
<div class="clear"></div>
<footer id="footer">
<div class="mui--text-center">
<div class="mui--text-caption mui--text-light">
<a href="/index.htm" class="logo"><img class="img-responsive" src="/images/logo-black.png" alt="Tutorials Point" title="Tutorials Point"></a>
</div>
<ul class="mui-list--inline mui--text-body2 mui--text-light">
<li><a href="/about/index.htm"><i class="fal fa-globe"></i> About us</a></li>
<li><a href="/about/about_terms_of_use.htm"><i class="fal fa-asterisk"></i> Terms of use</a></li>
<li><a href="/about/about_privacy.htm#cookies"> <i class="fal fa-shield-check"></i> Cookies Policy</a></li>
<li><a href="/about/faq.htm"><i class="fal fa-question-circle"></i> FAQ's</a></li>
<li><a href="/about/about_helping.htm"><i class="fal fa-hands-helping"></i> Helping</a></li>
<li><a href="/about/contact_us.htm"><i class="fal fa-map-marker-alt"></i> Contact</a></li>
</ul>
<div class="mui--text-caption mui--text-light bottom-copyright-text">&copy; Copyright 2019. All Rights Reserved.</div>
</div>
<div id="privacy-banner">
  <div>
    <p>
      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.
      <a id="banner-accept" href="#">Accept</a>
      <a id="banner-learn" href="/about/about_cookies.htm" target="_blank">Learn more</a>
    </p>
  </div>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-232293-17"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-232293-6');
</script>
</footer>
</body>
</html>
