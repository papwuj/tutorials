<!DOCTYPE html>
<html lang="en-US">
<head>
<title>WebRTC - Quick Guide</title>
<meta charset="utf-8">
<meta name="description" content="WebRTC - Quick Guide - The Web is no more a stranger to real-time communication as WebRTC (Web Real-Time Communication) comes into play. Although it was released in May 2011, it is st"/>
<meta name="keywords" content="C, C++, Python, Java, HTML, CSS, JavaScript, SQL, PHP, jQuery, XML, DOM, Bootstrap, Tutorials, Articles, Programming, training, learning, quiz, preferences, examples, code"/>
<link rel="canonical" href="https://www.tutorialspoint.com/webrtc/webrtc_quick_guide.htm" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<script src="/theme/js/script-min-v2.js?v=3"></script>
<link rel="stylesheet" href="/theme/css/style-min-v2.css?v=6">
<script src="//services.bilsyndication.com/adv1/?d=901" defer="" async=""></script>
<script> var vitag = vitag || {};</script>
<script> vitag.outStreamConfig = { enablePC: false, enableMobile: false };</script>  
<style>
.right-menu .mui-btn {
    background-color:#df711d;
}
a.demo {
    background:#df711d;
}
li.heading {
    background:#df711d;
}
.course-box{background:#df711d}
.home-intro-sub p{color:#df711d}
</style>
</head>
<body>
<header id="header">
<!-- Top sub-menu Starts Here -->
<div class="mui-appbar mui-container-fulid top-menu">
<div class="mui-container">
<div class="top-menu-item home">
<a href="https://www.tutorialspoint.com/index.htm" target="_blank" title="TutorialsPoint - Home"><i class="fal fa-home"></i> <span>Home</span></a>
</div>
<div class="top-menu-item qa">
<a href="https://www.tutorialspoint.com/about/about_careers.htm" target="_blank" title="Job @ Tutorials Point"><i class="fa fa-suitcase"></i> <span>Jobs</span></a>
</div>
<div class="top-menu-item tools">
<a href="https://www.tutorialspoint.com/online_dev_tools.htm" target="_blank" title="Tools - Online Development and Testing Tools"><i class="fal fa-cogs"></i> <span>Tools</span></a>
</div>
<div class="top-menu-item coding-ground">
<a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" title="Coding Ground - Free Online IDE and Terminal"><i class="fal fa-code"></i> <span>Coding Ground </span></a> 
</div>
<div class="top-menu-item current-affairs">
<a href="https://www.tutorialspoint.com/current_affairs.htm" target="_blank" title="Daily Current Affairs"><i class="fal fa-layer-plus"></i> <span>Current Affairs</span></a>
</div>
<div class="top-menu-item upsc-notes">
<a href="https://www.tutorialspoint.com/upsc_ias_exams.htm" target="_blank" title="UPSC IAS Exams Notes - TutorialsPoint"><i class="fal fa-user-tie"></i> <span>UPSC Notes</span></a>
</div>      
<div class="top-menu-item online-tutoris">
<a href="https://www.tutorialspoint.com/tutor_connect/index.php" target="_blank" title="Top Online Tutors - Tutor Connect"><i class="fal fa-user"></i> <span>Online Tutors</span></a>
</div>
<div class="top-menu-item whiteboard">
<a href="https://www.tutorialspoint.com/whiteboard.htm" target="_blank" title="Free Online Whiteboard"><i class="fal fa-chalkboard"></i> <span>Whiteboard</span></a>
</div>
<div class="top-menu-item net-meeting">
<a href="https://www.tutorialspoint.com/netmeeting.php" target="_blank" title="A free tool for online video conferencing"><i class="fal fa-chalkboard-teacher"></i> <span>Net Meeting</span></a> 
</div>
<div class="top-menu-item articles">
<a href="https://www.tutorix.com" target="_blank" title="Tutorx - The Best Learning App" rel="nofollow"><i class="fal fa-video"></i> <span>Tutorix</span></a> 
</div>        
<div class="social-menu-item">
<a href="https://www.facebook.com/tutorialspointindia" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Facebook"><i class="fab fa-facebook-f"></i></a> 
<a href="https://www.twitter.com/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Twitter"><i class="fab fa-twitter"></i></a>
<a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint @ Linkedin"><i class="fab fa-linkedin-in"></i></a>
<a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" rel="nofollow" data-placement="bottom" title="tutorialspoint YouTube"><i class="fab fa-youtube"></i></a>
</div>        
</div>
</div>
<!-- Top sub-menu Ends Here -->
<!-- Top main-menu Starts Here -->
<div class="mui-appbar mui-container-fulid mui--appbar-line-height mui--z1" id="logo-menu">
<div class="mui-container">
<div class="left-menu">
<a href="https://www.tutorialspoint.com/index.htm" title="Tutorialspoint">
<img class="tp-logo" alt="tutorialspoint" src="/webrtc/images/logo.png">
</a>
<div class="mui-dropdown">
<a class="mui-btn mui-btn--primary categories" data-mui-toggle="dropdown"><i class="fa fa-th-large"></i> 
<span>Categories <span class="mui-caret"></span></span></a>            
<ul class="mui-dropdown__menu cat-menu">
<li>
<ul>
<li><a href="/academic_tutorials.htm"><i class="fa fa-caret-right"></i> Academic Tutorials</a></li>
<li><a href="/big_data_tutorials.htm"><i class="fa fa-caret-right"></i> Big Data &amp; Analytics </a></li>
<li><a href="/computer_programming_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Programming </a></li>
<li><a href="/computer_science_tutorials.htm"><i class="fa fa-caret-right"></i> Computer Science </a></li>
<li><a href="/database_tutorials.htm"><i class="fa fa-caret-right"></i> Databases </a></li>
<li><a href="/devops_tutorials.htm"><i class="fa fa-caret-right"></i> DevOps </a></li>
<li><a href="/digital_marketing_tutorials.htm"><i class="fa fa-caret-right"></i> Digital Marketing </a></li>
<li><a href="/engineering_tutorials.htm"><i class="fa fa-caret-right"></i> Engineering Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> Exams Syllabus </a></li>
<li><a href="/famous_monuments.htm"><i class="fa fa-caret-right"></i> Famous Monuments </a></li>
<li><a href="/gate_exams_tutorials.htm"><i class="fa fa-caret-right"></i> GATE Exams Tutorials</a></li>
<li><a href="/latest_technologies.htm"><i class="fa fa-caret-right"></i> Latest Technologies </a></li>
<li><a href="/machine_learning_tutorials.htm"><i class="fa fa-caret-right"></i> Machine Learning </a></li>
<li><a href="/mainframe_tutorials.htm"><i class="fa fa-caret-right"></i> Mainframe Development </a></li>
<li><a href="/management_tutorials.htm"><i class="fa fa-caret-right"></i> Management Tutorials </a></li>
<li><a href="/maths_tutorials.htm"><i class="fa fa-caret-right"></i> Mathematics Tutorials</a></li>
<li><a href="/microsoft_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Microsoft Technologies </a></li>
<li><a href="/misc_tutorials.htm"><i class="fa fa-caret-right"></i> Misc tutorials </a></li>
<li><a href="/mobile_development_tutorials.htm"><i class="fa fa-caret-right"></i> Mobile Development </a></li>
<li><a href="/java_technology_tutorials.htm"><i class="fa fa-caret-right"></i> Java Technologies </a></li>
<li><a href="/python_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> Python Technologies </a></li>
<li><a href="/sap_tutorials.htm"><i class="fa fa-caret-right"></i> SAP Tutorials </a></li>
<li><a href="/scripting_lnaguage_tutorials.htm"><i class="fa fa-caret-right"></i>Programming Scripts </a></li>
<li><a href="/selected_reading.htm"><i class="fa fa-caret-right"></i> Selected Reading </a></li>
<li><a href="/software_quality_tutorials.htm"><i class="fa fa-caret-right"></i> Software Quality </a></li>
<li><a href="/soft_skill_tutorials.htm"><i class="fa fa-caret-right"></i> Soft Skills </a></li>
<li><a href="/telecom_tutorials.htm"><i class="fa fa-caret-right"></i> Telecom Tutorials </a></li>
<li><a href="/upsc_ias_exams.htm"><i class="fa fa-caret-right"></i> UPSC IAS Exams </a></li>
<li><a href="/web_development_tutorials.htm"><i class="fa fa-caret-right"></i> Web Development </a></li>
<li><a href="/sports_tutorials.htm"><i class="fa fa-caret-right"></i> Sports Tutorials </a></li>
<li><a href="/xml_technologies_tutorials.htm"><i class="fa fa-caret-right"></i> XML Technologies </a></li>
<li><a href="/multi_language_tutorials.htm"><i class="fa fa-caret-right"></i> Multi-Language Tutorials</a></li>
<li><a href="/questions_and_answers.htm"><i class="fa fa-caret-right"></i> Interview Questions</a></li>
</ul>
</li>
</ul>
<div class="clear"></div>
</div> 
</div>
<div class="right-menu">
<div class="toc-toggle">
<a href="javascript:void(0);"><i class="fa fa-bars"></i></a>
</div>
<div class="mobile-search-btn">
<a href="https://www.tutorialspoint.com/search.htm"><i class="fal fa-search"></i></a>
</div>
<div class="search-box">
<form method="get" class="" name="searchform" action="https://www.google.com/search" target="_blank" novalidate="">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com" class="user-valid valid">
<input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
<button><i class="fal fa-search"></i></button>
</form>
</div>
<div class="menu-btn library-btn">
<a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a>
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a> 
</div>
<div class="menu-btn videos-btn">
<a href="https://www.tutorialspoint.com/questions/index.php"><i class="fa fa-location-arrow"></i> <span>Q/A</span></a>
</div>
<div class="menu-btn ebooks-btn">
<a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a>
</div>
<div class="mui-dropdown">
<button class="mui-btn mui-btn--primary" data-mui-toggle="dropdown">
<span class="mui-caret"></span>
</button>
<ul class="mui-dropdown__menu">
<li><a href="https://www.tutorialspoint.com/tutorialslibrary.htm"><i class="fal fa-cubes"></i> <span>Library</span></a></li>
<li><a href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fal fa-video"></i> <span>Videos</span></a></li>
<li><a href="https://store.tutorialspoint.com"><i class="fal fa-book"></i> <span>eBooks</span></a></li>
</ul>
</div>
</div>
</div>
</div>
<!-- Top main-menu Ends Here -->
</header>
<div class="mui-container-fluid content">
<div class="mui-container">
<!-- Tutorial ToC Starts Here -->
<div class="mui-col-md-3 tutorial-toc">
<div class="mini-logo">
<img src="/webrtc/images/webrtc-mini-logo.jpg" alt="WebRTC Tutorial" />
</div>
<ul class="toc chapters">
<li class="heading">WebRTC Tutorial</li>
<li><a href="/webrtc/index.htm">WebRTC - Home</a></li>
<li><a href="/webrtc/webrtc_overview.htm">WebRTC - Overview</a></li>
<li><a href="/webrtc/webrtc_architecture.htm">WebRTC - Architecture</a></li>
<li><a href="/webrtc/webrtc_environment.htm">WebRTC - Environment</a></li>
<li><a href="/webrtc/webrtc_media_stream_apis.htm">WebRTC - MediaStream APIs</a></li>
<li><a href="/webrtc/webrtc_rtcpeerconnection_apis.htm">WebRTC - RTCPeerConnection APIs</a></li>
<li><a href="/webrtc/webrtc_rtcdatachannel_apis.htm">WebRTC - RTCDataChannel APIs</a></li>
<li><a href="/webrtc/webrtc_sending_messages.htm">WebRTC - Sending Messages</a></li>
<li><a href="/webrtc/webrtc_signaling.htm">WebRTC - Signaling</a></li>
<li><a href="/webrtc/webrtc_browser_support.htm">WebRTC - Browser Support</a></li>
<li><a href="/webrtc/webrtc_mobile_support.htm">WebRTC - Mobile Support</a></li>
<li><a href="/webrtc/webrtc_video_demo.htm">WebRTC - Video Demo</a></li>
<li><a href="/webrtc/webrtc_voice_demo.htm">WebRTC - Voice Demo</a></li>
<li><a href="/webrtc/webrtc_text_demo.htm">WebRTC - Text Demo</a></li>
<li><a href="/webrtc/webrtc_security.htm">WebRTC - Security</a></li>
</ul>
<ul class="toc chapters">
<li class="heading">WebRTC Resources</li>
<li><a href="/webrtc/webrtc_quick_guide.htm">WebRTC - Quick Guide</a></li>
<li><a href="/webrtc/webrtc_useful_resources.htm">WebRTC - Useful Resources</a></li>
<li><a href="/webrtc/webrtc_discussion.htm">WebRTC - Discussion</a></li>
</ul>
<ul class="toc reading">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="/upsc_ias_exams.htm">UPSC IAS Exams Notes</a></li>
<li><a target="_top" href="/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</div>
<!-- Tutorial ToC Ends Here -->
<!-- Tutorial Content Starts Here -->
<div class="mui-col-md-6 tutorial-content">
<h1>WebRTC - Quick Guide</h1>
<hr />
<div class="top-ad-heading">Advertisements</div>
<div style="text-align: center;">
<script><!--
google_ad_client = "pub-7133395778201029";
var width = document.getElementsByClassName("tutorial-content")[0].clientWidth - 40;
google_ad_width = width;
google_ad_height = 150;
google_ad_format = width + "x150_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="mui-container-fluid button-borders">
<div class="pre-btn">
<a href="/webrtc/webrtc_security.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/webrtc/webrtc_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="clearer"></div>
<h1>WebRTC - Overview</h1>
<p>The Web is no more a stranger to real-time communication as <b>WebRTC (Web Real-Time Communication)</b> comes into play. Although it was released in May 2011, it is still developing and its standards are changing. A set of protocols is standardized by <i>Real-Time Communication in WEB-browsers Working group</i> at <a target="_blank" rel="nofollow" href="http://tools.ietf.org/wg/rtcweb/">http://tools.ietf.org/wg/rtcweb/</a> of the <b>IETF (Internet Engineering Task Force)</b> while new sets of APIs are standardized by the <i>Web Real-Time Communications Working Groupe</i> at <a target="_blank" rel="nofollow" href="http://www.w3.org/2011/04/webrtc/">http://www.w3.org/2011/04/webrtc/</a> of the <b>W3C (World Wide Web Consortium)</b>. With the appearance of WebRTC, modern web applications can easily stream audio and video content to millions of people.</p>
<h2>Basic Scheme</h2>
<p>WebRTC allows you to set up peer-to-peer connections to other web browsers quickly and easily. To build such an application from scratch, you would need a wealth of frameworks and libraries dealing with typical issues like data loss, connection dropping, and NAT traversal. With WebRTC, all of this comes built-in into the browser out-of-the-box. This technology doesn't need any plugins or third-party software. It is open-sourced and its source code is freely available at <a target="_blank" rel="nofollow" href="http://www.webrtc.org/">http://www.webrtc.org/.</a></p>
<p>The WebRTC API includes media capture, encoding and decoding audio and video, transportation layer, and session management.</p>
<img src="/webrtc/images/basic_scheme.jpg" alt="Basic Scheme" />
<h3>Media Capture</h3>
<p>The first step is to get access to the camera and microphone of the user's device. We detect the type of devices available, get user permission to access these devices and manage the stream.</p>
<h3>Encoding and Decoding Audio and Video</h3>
<p>It is not an easy task to send a stream of audio and video data over the Internet. This is where encoding and decoding are used. This is the process of splitting up video frames and audio waves into smaller chunks and compressing them. This algorithm is called <b>codec</b>. There is an enormous amount of different codecs, which are maintained by different companies with different business goals. There are also many codecs inside WebRTC like H.264, iSAC, Opus and VP8. When two browsers connect together, they choose the most optimal supported codec between two users. Fortunately, WebRTC does most of the encoding behind the scenes.</p>
<h3>Transportation Layer</h3>
<p>The transportation layer manages the order of packets, deal with packet loss and connecting to other users. Again the WebRTC API gives us an easy access to events that tell us when there are issues with the connection.</p>
<h3>Session Management</h3>
<p>The session management deals with managing, opening and organizing connections. This is commonly called <b>signaling</b>. If you transfer audio and video streams to the user it also makes sense to transfer collateral data. This is done by the <b>RTCDataChannel API</b>.</p>
<p>Engineers from companies like Google, Mozilla, Opera and others have done a great job to bring this real-time experience to the Web.</p>
<h2>Browser Compatibility</h2>
<p>The WebRTC standards are one of the fastest evolving on the web, so it doesn't mean that every browser supports all the same features at the same time. To check whether your browser supports WebRTC or not, you may visit <a target="_blank" rel="nofollow" href=" http://caniuse.com/#feat=rtcpeerconnection">http://caniuse.com/#feat=rtcpeerconnection.</a> Throughout all the tutorials, I recommend you to use Chrome for all the examples.</p>
<h3>Trying out WebRTC</h3>
<p>Let's get started using WebRTC right now. Navigate your browser to the demo site at <a target="_blank" rel="nofollow" href="https://apprtc.appspot.com/">https://apprtc.appspot.com/</a></p>
<img src="/webrtc/images/join_button.jpg" alt="Click JOIN" />
<p>Click the “JOIN” button. You should see a drop-down notification.</p>
<img src="/webrtc/images/allow_button.jpg" alt="Click Allow" />
<p>Click the “Allow” button to start streaming your video and audio to the web page. You should see a video stream of yourself.</p>
<img src="/webrtc/images/open_url.jpg" alt="Open the URL" />
<p>Now open the URL you are currently on in a new browser tab and click on “JOIN”. You should see two video streams &minus; one from your first client and another from the second one.</p>
<img src="/webrtc/images/video_stream.jpg" alt="Video Stream" />
<p>Now you should understand why WebRTC is a powerful tool.</p>
<h2>Use Cases</h2>
<p>The real-time web opens the door to a whole new range of applications, including text-based chat, screen and file sharing, gaming, video chat, and more. Besides communication you can use WebRTC for other purposes like &minus;</p>
<ul class="list">
<li>real-time marketing</li>
<li>real-time advertising</li>
<li>back office communications (CRM, ERP, SCM, FFM)</li>
<li>HR management</li>
<li>social networking</li>
<li>dating services</li>
<li>online medical consultations</li>
<li>financial services</li>
<li>surveillance</li>
<li>multiplayer games</li>
<li>live broadcasting</li>
<li>e-learning</li>
</ul>
<h3>Summary</h3>
<p>Now you should have a clear understanding of the term WebRTC. You should also have an idea of what types of applications can be built with WebRTC, as you have already tried it in your browser. To sum up, WebRTC is quite a useful technology.</p>
<h1>WebRTC - Architecture</h1>
<p>The overall WebRTC architecture has a great level of complexity.</p>
<img src="/webrtc/images/architecture.jpg" alt="WebRTC Architecture" />
<p>Here you can find three different layers &minus;</p>
<ul class="list">
<li><p><b>API for web developers</b> &minus; this layer contains all the APIs web developer needed, including RTCPeerConnection, RTCDataChannel, and MediaStrean objects.</p></li>
<li><p>API for browser makers</p></li>
<li><p>Overridable API, which browser makers can hook.</p></li>
</ul>
<p>Transport components allow establishing connections across various types of networks while voice and video engines are frameworks responsible for transferring audio and video streams from a sound card and camera to the network. For Web developers, the most important part is WebRTC API.</p>
<p>If we look at the WebRTC architecture from the client-server side we can see that one of the most commonly used models is inspired by the SIP(Session Initiation Protocol) Trapezoid.</p>
<img src="/webrtc/images/session_initiation_protocol.jpg" alt="SIP Trapezoid" />
<p>In this model, both devices are running a web application from different servers. The RTCPeerConnection object configures streams so they could connect to each other, peer-to-peer. This signaling is done via HTTP or WebSockets.</p>
<p>But the most commonly used model is Triangle &minus;</p>
<img src="/webrtc/images/triangle_model.jpg" alt="Triangle Model" />
<p>In this model both devices use the same web application. It gives web developer more flexibility when managing user connections.</p>
<h2>The WebRTC API</h2>
<p>It consists of a few main javascript objects &minus;</p>
<ul class="list">
<li>RTCPeerConnection</li>
<li>MediaStream</li>
<li>RTCDataChannel</li>
</ul>
<h3>The RTCPeerConnection object</h3>
<p>This object is the main entry point to the WebRTC API. It helps us connect to peers, initialize connections and attach media streams. It also manages a UDP connection with another user.</p>
<p>The main task of the RTCPeerConnection object is to setup and create a peer connection. We can easily hook keys points of the connection because this object fires a set of events when they appear. These events give you access to the configuration of our connection &minus;</p>
<img src="/webrtc/images/rtcpeer_connection_object.jpg" alt="RTCPeerConnection object" />
<p>The RTCPeerConnection is a simple javascript object, which you can simply create this way &minus;</p>
<pre class="prettyprint notranslate">
[code] 
var conn = new RTCPeerConnection(conf); 

conn.onaddstream = function(stream) { 
   // use stream here 
}; 

[/code]
</pre>
<p>The RTCPeerConnection object accepts a <i>conf</i> parameter, which we will cover later in these tutorials. The <i>onaddstream</i> event is fired when the remote user adds a video or audio stream to their peer connection.</p>
<h3>MediaStream API</h3>
<p>Modern browsers give a developer access to the <i>getUserMedia</i> API, also known as the <i>MediaStream</i> API. There are three key points of functionality &minus;</p>
<ul class="list">
<li><p>It gives a developer access to a <i>stream</i> object that represent video and audio streams</p></li>
<li><p>It manages the selection of input user devices in case a user has multiple cameras or microphones on his device</p></li>
<li><p>It provides a security level asking user all the time he wants to fetch s stream</p></li>
</ul>
<p>To test this API let's create a simple HTML page. It will show a single &lt;video&gt; element, ask the user's permission to use the camera and show a live stream from the camera on the page. Create an <i>index.html</i> file and add &minus;</p>
<pre class="prettyprint notranslate">
[code] 
&lt;html&gt;
 
   &lt;head&gt; 
      &lt;meta charset = "utf-8"&gt; 
   &lt;/head&gt;
	
   &lt;body&gt; 
      &lt;video autoplay&gt;&lt;/video&gt; 
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
   &lt;/body&gt; 
	 
&lt;/html&gt; 
[/code]
</pre>
<p>Then add a <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
[code] 
//checks if the browser supports WebRTC 

function hasUserMedia() { 
   navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia 
      || navigator.mozGetUserMedia || navigator.msGetUserMedia; 
   return !!navigator.getUserMedia; 
}
 
if (hasUserMedia()) { 
   navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia
      || navigator.mozGetUserMedia || navigator.msGetUserMedia;
		
   //get both video and audio streams from user's camera 
   navigator.getUserMedia({ video: true, audio: true }, function (stream) { 
      var video = document.querySelector('video'); 
		
      //insert stream into the video tag 
      video.src = window.URL.createObjectURL(stream); 
   }, function (err) {}); 
	
}else {
   alert("Error. WebRTC is not supported!"); 
}
[/code]
</pre>
<p>Now open the <i>index.html</i> and you should see the video stream displaying your face.</p>
<p>But be careful, because WebRTC works only on the server side. If you simply open this page with the browser it won't work. You need to host these files on the Apache or Node servers, or which one you prefer.</p>
<h3>The RTCDataChannel object</h3>
<p>As well as sending media streams between peers, you may also send additional data using <i>DataChannel</i> API. This API is as simple as MediaStream API. The main job is to create a channel coming from an existing RTCPeerConnection object &minus;</p>
<pre class="prettyprint notranslate">
[code] 
var peerConn = new RTCPeerConnection(); 

//establishing peer connection 
//... 
//end of establishing peer connection 
var dataChannel = peerConnection.createDataChannel("myChannel", dataChannelOptions); 

// here we can start sending direct messages to another peer 
[/code]
</pre>
<p>This is all you needed, just two lines of code. Everything else is done on the browser's internal layer. You can create a channel at any peer connection until the <i>RTCPeerConnectionobject</i> is closed.</p>
<h3>Summary</h3>
<p>You should now have a firm grasp of the WebRTC architecture. We also covered MediaStream, RTCPeerConnection, and RTCDataChannel APIs. The WebRTC API is a moving target, so always keep up with the latest specifications.</p>
<h1>WebRTC - Environment</h1>
<p>Before we start building our WebRTC applications, we should set our coding environment. First of all, you should have a text editor or IDE where you can edit HTML and Javascript. There are chances that you have already chosen the preferred one as you are reading this tutorial. As for me, I'm using WebStorm IDE. You can download its trial version at <a target="_blank" rel="nofollow" href="https://www.jetbrains.com/webstorm/">https://www.jetbrains.com/webstorm/</a>. I'm also using Linux Mint as my OS of choice.</p>
<p>The other requirement for common WebRTC applications is having a server to host the HTML and Javascript files. The code will not work just by double-clicking on the files because the browser is not allowed to connect to cameras and microphones unless the files are being served by an actual server. This is done obviously due to the security issues.</p>
<p>There are tons of different web servers, but in this tutorial, we are going to use Node.js with node-static &minus;</p>
<ul class="list">
<li><p>Visit <a target="_blank" rel="nofollow" href="https://nodejs.org/en/">https://nodejs.org/en/</a> and download the latest Node.js version.</p></li>
<li><p>Unpack it to the /usr/local/nodejs directory.</p></li>
<li><p>Open the /home/YOUR_USERNAME/.profile file and add the following line to the end &minus; <i>export PATH=$PATH:/usr/local/nodejs/bin</i></p></li>
<li><p>The you can restart your computer or run source <i>/home/YOUR_USERNAME/.profile</i></p></li>
<li><p>Now the <i>node</i> command should be available from the command line. The <i>npm</i> command is also available. NMP is the package manager for Node.js. You can learn more at <a href="https://www.npmjs.com/" rel="nofollow" target="_blank">https://www.npmjs.com/</a>.</p></li>
<li><p>Open up a terminal and run <i>sudo npm install -g node-static</i>. This will install the static web server for Node.js.</p></li>
<li><p>Now navigate to any directory containing the HTML files and run the <i>static</i> command inside the directory to start your web server.</p></li>
<li><p>You can navigate to <b>http://localhost:8080</b> to see your files.</p></li>
</ul>
<p>There is another way to install nodejs. Just run <i>sudo apt-get install nodejs</i> in the terminal window.</p>
<p>To test your Node.js installation open up your terminal and run the <i>node</i> command. Type a few commands to check how it works &minus;</p>
<img src="/webrtc/images/open_terminal.jpg" alt="Open the terminal" />
<p>Node.js runs Javascript files as well as commands typed in the terminal. Create an <i>index.js</i> file with the following content &minus;</p>
<pre class="result notranslate">
console.log(“Testing Node.js”);
</pre>
<p>Then run the <i>node index</i> command. You will see the following &minus;</p>
<img src="/webrtc/images/run_node_terminal.jpg" alt="Run Node Terminal" />
<p>When building our signaling server we will use a WebSockets library for Node.js. To install in run <i>npm install ws</i> in the terminal.</p>
<p>For testing our signaling server, we will use the wscat utility. To install it run <i>npm install -g wscat</i> in your terminal window.</p>
<table class="table table-bordered">
<tr>
<th>S.No</th>
<th style="text-align:center;">Protocols &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="/webrtc/webrtc_protocols.htm">WebRTC Protocols</a>
<p>WebRTC applications use UDP (User Datagram Protocol) as the transport protocol. Most web applications today are built with the using of the TCP (Transmission Control Protocol)</p></td>
</tr>
<tr>
<td>2</td>
<td><a href="/webrtc/webrtc_session_description_protocol.htm">Session Description Protocol</a>
<p>The SDP is an important part of the WebRTC. It is a protocol that is intended to describe media communication sessions.</p></td>
</tr>
<tr>
<td>3</td>
<td><a href="/webrtc/webrtc_finding_route.htm">Finding a Route</a>
<p>In order to connect to another user, you should find a clear path around your own network and the other user's network. But there are chances that the network you are using has several levels of access control to avoid security issues.</p></td>
</tr>
<tr>
<td>4</td>
<td><a href="/webrtc/webrtc_sctp.htm">Stream Control Transmission Protocol</a>
<p>With the peer connection, we have the ability to send quickly video and audio data. The SCTP protocol is used today to send blob data on top of our currently setup peer connection when using the RTCDataChannel object.</p></td>
</tr>
</table>
<h2>Summary</h2>
<p>In this chapter, we covered several of the technologies that enable peer connections, such as UDP, TCP, STUN, TURN, ICE, and SCTP. You should now have a surface-level understanding of how SDP works and its use cases.</p>
<h1>WebRTC - MediaStream APIs</h1>
<p>The MediaStream API was designed to easy access the media streams from local cameras and microphones. The <i>getUserMedia()</i> method is the primary way to access local input devices.</p>
<p>The API has a few key points &minus;</p>
<ul class="list">
<li><p>A real-time media stream is represented by a <i>stream</i> object in the form of video or audio</p></li>
<li><p>It provides a security level through user permissions asking the user before a web application can start fetching a stream</p></li>
<li><p>The selection of input devices is handled by the MediaStream API (for example, when there are two cameras or microphones connected to the device)</p></li>
</ul>
<p>Each MediaStream object includes several MediaStreamTrack objects. They represent video and audio from different input devices.</p>
<p>Each MediaStreamTrack object may include several channels (right and left audio channels). These are the smallest parts defined by the MediaStream API.</p>
<p>There are two ways to output MediaStream objects. First, we can render output into a  video or audio element. Secondly, we can send output to the RTCPeerConnection object, which then send it to a remote peer.</p>
<h2>Using the MediaStream API</h2>
<p>Let's create a simple WebRTC application. It will show a video element on the screen, ask the user permission to use the camera, and show a live video stream in the browser. Create an <i>index.html</i> file &minus;</p>
<pre class="prettyprint notranslate">
&lt;!DOCTYPE html&gt; 
&lt;html lang = "en"&gt;
 
   &lt;head&gt; 
      &lt;meta charset = "utf-8" /&gt; 
   &lt;/head&gt; 
	
   &lt;body&gt; 
      &lt;video autoplay&gt;&lt;/video&gt; 
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>Then create the <i>client.js file</i> and add the following;</p>
<pre class="prettyprint notranslate">
function hasUserMedia() { 
   //check if the browser supports the WebRTC 
   return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || 
      navigator.mozGetUserMedia); 
} 

if (hasUserMedia()) { 
   navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia
      || navigator.mozGetUserMedia; 
		
   //enabling video and audio channels 
   navigator.getUserMedia({ video: true, audio: true }, function (stream) { 
      var video = document.querySelector('video'); 
		
      //inserting our stream to the video tag     
      video.src = window.URL.createObjectURL(stream); 
   }, function (err) {}); 
} else { 
   alert("WebRTC is not supported"); 
}
</pre>
<p>Here we create the <i>hasUserMedia()</i> function which checks whether WebRTC is supported or not. Then we access the <i>getUserMedia</i> function where the second parameter is a callback that accept the stream coming from the user's device. Then we load our stream into the <i>video</i> element using <i>window.URL.createObjectURL</i> which creates a URL representing the object given in parameter.</p>
<p>Now refresh your page, click Allow, and you should see your face on the screen.</p>
<img src="/webrtc/images/media_stream_api.jpg" alt="Media Stream API" />
<p>Remember to run all your scripts using the web server. We have already installed one in the WebRTC Environment Tutorial.</p>
<h2>MediaStream API</h2>
<h3>Properties</h3>
<ul class="list">
<li><p><b>MediaStream.active (read only)</b> &minus; Returns true if the MediaStream is active, or false otherwise.</p></li>
<li><p><b>MediaStream.ended (read only, deprecated)</b> &minus; Return true if the ended <i>event</i> has been fired on the object, meaning that the stream has been completely read, or false if the end of the stream has not been reached.</p></li>
<li><p><b>MediaStream.id (read only)</b> &minus; A unique identifier for the object.</p></li>
<li><p><b>MediaStream.label (read only, deprecated)</b> &minus; A unique identifier assigned by the user agent.</p></li>
</ul>
<p>You can see how the above properties look in my browser &minus;</p>
<img src="/webrtc/images/properties.jpg" alt="Properties" />
<h3>Event Handlers</h3>
<ul class="list">
<li><p><b>MediaStream.onactive</b> &minus; A handler for an <i>active</i> event that is fired when a MediaStream object becomes active.</p></li>
<li><p><b>MediaStream.onaddtrack</b> &minus; A handler for an <i>addtrack</i> event that is fired when a new <i>MediaStreamTrack</i> object is added.</p></li>
<li><p><b>MediaStream.onended (deprecated)</b> &minus; A handler for an <i>ended</i> event that is fired when the streaming is terminating.</p></li>
<li><p><b>MediaStream.oninactive</b> &minus; A handler for an <i>inactive</i> event that is fired when a <i>MediaStream</i> object becomes inactive.</p></li>
<li><p><b>MediaStream.onremovetrack</b> &minus; A handler for a <i>removetrack</i> event that is fired when a <i>MediaStreamTrack</i> object is removed from it.</p></li>
</ul>
<h3>Methods</h3>
<ul class="list">
<li><p><b>MediaStream.addTrack()</b> &minus; Adds the <i>MediaStreamTrack</i> object given as argument to the MediaStream. If the track has already been added, nothing happens.</p></li>
<li><p><b>MediaStream.clone()</b> &minus; Returns a clone of the MediaStream object with a new ID.</p></li>
<li><p><b>MediaStream.getAudioTracks()</b> &minus; Returns a list of the audio <i>MediaStreamTrack</i> objects from the <i>MediaStream</i> object.</p></li>
<li><p><b>MediaStream.getTrackById()</b> &minus; Returns the track by ID. If the argument is empty or the ID is not found, it returns null. If several tracks have the same ID, it returns the first one.</p></li>
<li><p><b>MediaStream.getTracks()</b> &minus; Returns a list of all <i>MediaStreamTrack</i> objects from the <i>MediaStream</i> object.</p></li>
<li><p><b>MediaStream.getVideoTracks()</b> &minus; Returns a list of the video <i>MediaStreamTrack</i> objects from the <i>MediaStream</i> object.</p></li>
<li><p><b>MediaStream.removeTrack()</b> &minus; Removes the <i>MediaStreamTrack</i> object given as argument from the MediaStream. If the track has already been removed, nothing happens.</p></li>
</ul>
<p>To test the above APIs change change the <i>index.html</i> in the following way &minus;</p>
<pre class="prettyprint notranslate">
&lt;!DOCTYPE html&gt; 
&lt;html lang = "en"&gt;
 
   &lt;head&gt; 
      &lt;meta charset = "utf-8" /&gt; 
   &lt;/head&gt;
	
   &lt;body&gt; 
      &lt;video autoplay&gt;&lt;/video&gt; 
      &lt;div&gt;&lt;button id = "btnGetAudioTracks"&gt;getAudioTracks()
         &lt;/button&gt;&lt;/div&gt; 
      &lt;div&gt;&lt;button id = "btnGetTrackById"&gt;getTrackById()
         &lt;/button&gt;&lt;/div&gt; 
      &lt;div&gt;&lt;button id = "btnGetTracks"&gt;getTracks()&lt;/button&gt;&lt;/div&gt; 
      &lt;div&gt;&lt;button id = "btnGetVideoTracks"&gt;getVideoTracks()
         &lt;/button&gt;&lt;/div&gt; 
      &lt;div&gt;&lt;button id = "btnRemoveAudioTrack"&gt;removeTrack() - audio
         &lt;/button&gt;&lt;/div&gt; 
      &lt;div&gt;&lt;button id = "btnRemoveVideoTrack"&gt;removeTrack() - video
         &lt;/button&gt;&lt;/div&gt; 
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
   &lt;/body&gt; 
	
&lt;/html&gt;
</pre>
<p>We added a few buttons to try out several MediaStream APIs. Then we should add event handlers for our newly created button. Modify the <i>client.js</i> file this way &minus;</p>
<pre class="prettyprint notranslate">
var stream;
  
function hasUserMedia() { 
   //check if the browser supports the WebRTC 
   return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || 
      navigator.mozGetUserMedia); 
} 
 
if (hasUserMedia()) {
   navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia
      || navigator.mozGetUserMedia; 
		
   //enabling video and audio channels 
   navigator.getUserMedia({ video: true, audio: true }, function (s) { 
      stream = s; 
      var video = document.querySelector('video'); 
		
      //inserting our stream to the video tag     
      video.src = window.URL.createObjectURL(stream); 
   }, function (err) {}); 
} else { 
   alert("WebRTC is not supported"); 
}
  
btnGetAudioTracks.addEventListener("click", function(){ 
   console.log("getAudioTracks"); 
   console.log(stream.getAudioTracks()); 
});
  
btnGetTrackById.addEventListener("click", function(){ 
   console.log("getTrackById"); 
   console.log(stream.getTrackById(stream.getAudioTracks()[0].id)); 
});
  
btnGetTracks.addEventListener("click", function(){ 
   console.log("getTracks()"); 
   console.log(stream.getTracks()); 
});
 
btnGetVideoTracks.addEventListener("click", function(){ 
   console.log("getVideoTracks()"); 
   console.log(stream.getVideoTracks()); 
});

btnRemoveAudioTrack.addEventListener("click", function(){ 
   console.log("removeAudioTrack()"); 
   stream.removeTrack(stream.getAudioTracks()[0]); 
});
  
btnRemoveVideoTrack.addEventListener("click", function(){ 
   console.log("removeVideoTrack()"); 
   stream.removeTrack(stream.getVideoTracks()[0]); 
});
</pre>
<p>Now refresh your page. Click on the <i>getAudioTracks()</i> button, then click on the <i>removeTrack() - audio</i> button. The audio track should now be removed. Then do the same for the video track.</p>
<img src="/webrtc/images/get_audio_track.jpg" alt="Click on getAudioTracks" />
<p>If you click the <i>getTracks()</i> button you should see all <i>MediaStreamTracks</i> (all connected video and audio inputs). Then click on the <i>getTrackById()</i> to get audio MediaStreamTrack.</p>
<img src="/webrtc/images/get_track_by_id.jpg" alt="Click on getTrackById" />
<h3>Summary</h3>
<p>In this chapter, we created a simple WebRTC application using the MediaStream API. Now you should have a clear overview of the various MediaStream APIs that make WebRTC work.</p>
<h1>WebRTC - RTCPeerConnection APIs</h1>
<p>The RTCPeerConnection API is the core of the peer-to-peer connection between each of the browsers. To create the RTCPeerConnection objects simply write</p>
<pre class="result notranslate">
var pc = RTCPeerConnection(config);
</pre>
<p>where the <i>config</i> argument contains at least on key, iceServers. It is an array of URL objects containing information about STUN and TURN servers, used during the finding of the ICE candidates. You can find a list of available public STUN servers at <a target="_blank" rel="nofollow" href="https://code.google.com/p/natvpn/source/browse/trunk/stun_server_list">code.google.com</a></p>
<p>Depending upon whether you are the caller or the callee the RTCPeerConnection object is used in a slightly different way on each side of the connection.</p>
<p>Here is an example of the user's flow &minus;</p>
<ul class="list">
<li><p> Register the <i>onicecandidate</i> handler. It sends any ICE candidates to the other peer, as they are received.</p></li>
<li><p>Register the <i>onaddstream</i> handler. It handles the displaying of the video stream once it is received from the remote peer.</p></li>
<li><p>Register the <i>message</i> handler. Your signaling server should also have a handler for messages received from the other peer. If the message contains the <i>RTCSessionDescription</i> object, it should be added to the <i>RTCPeerConnection</i> object using the <i>setRemoteDescription()</i> method. If the message contains the <i>RTCIceCandidate</i> object, it should be added to the <i>RTCPeerConnection</i> object using the <i>addIceCandidate()</i> method.</p></li>
<li><p>Utilize <i>getUserMedia()</i> to set up your local media stream and add it to the <i>RTCPeerConnection</i> object using the <i>addStream()</i> method.</p></li>
<li><p>Start offer/answer negotiation process. This is the only step where the caller's flow is different from the callee's one. The caller starts negotiation using the <i>createOffer()</i> method and registers a callback that receives the <i>RTCSessionDescription</i> object. Then this callback should add this <i>RTCSessionDescription</i> object to your <i>RTCPeerConnection</i> object using <i>setLocalDescription()</i>. And finally, the caller should send this <i>RTCSessionDescription</i> to the remote peer using the signaling server. The callee, on the other, registers the same callback, but in the <i>createAnswer()</i> method. Notice that the callee flow is initiated only after the offer is received from the caller.</p></li>
</ul>
<h2>RTCPeerConnection API</h2>
<h3>Properties</h3>
<ul class="list">
<li><p><b>RTCPeerConnection.iceConnectionState (read only)</b> &minus; Returns an RTCIceConnectionState enum that describes the state of the connection. An iceconnectionstatechange event is fired when this value changes. The possible values &minus;</p>
<ul class="list">
<li><p><b>new</b> &minus; the ICE agent is waiting for remote candidates or gathering addresses</p></li>
<li><p><b>checking</b> &minus; the ICE agent has remote candidates, but it has not found a connection yet</p></li>
<li><p><b>connected</b> &minus; the ICE agent has found a usable connection, but is still checking more remote candidate for better connection.</p></li>
<li><p><b>completed</b> &minus; the ICE agent has found a usable connection and stopped testing remote candidates.</p></li>
<li><p><b>failed</b> &minus; the ICE agent has checked all the remote candidates but didn't find a match for at least one component.</p></li>
<li><p><b>disconnected</b> &minus; at least one component is no longer alive.</p></li>
<li><p><b>closed</b> &minus; the ICE agent is closed.</p></li>
</ul>
</li>
<li><p><b>RTCPeerConnection.iceGatheringState (read only)</b> &minus; Returns a RTCIceGatheringState enum that describes the ICE gathering state for the connection &minus;</p>
<ul class="list">
<li><p><b>new</b> &minus; the object was just created.</p></li>
<li><p><b>gathering</b> &minus; the ICE agent is in the process of gathering candidates</p></li>
<li><p><b>complete</b> the ICE agent has completed gathering.</p></li>
</ul>
</li>
<li><p><b>RTCPeerConnection.localDescription (read only)</b> &minus; Returns an RTCSessionDescription describing the local session. It can be null if it has not yet been set.</p></li>
<li><p><b>RTCPeerConnection.peerIdentity (read only)</b> &minus; Returns an RTCIdentityAssertion. It consists of an idp(domain name) and a name representing the identity of the remote peer.</p></li>
<li><p><b>RTCPeerConnection.remoteDescription (read only)</b> &minus; Return an RTCSessionDescription describing the remote session. It can be null if it has not yet been set.</p></li>
<li><p><b>RTCPeerConnection.signalingState (read only)</b> &minus; Returns an RTCSignalingState enum that describes the signaling state of the local connection. This state describes the SDP offer. A signalingstatechange event is fired when this value changes. The possible values &minus;</p>
<ul class="list">
<li><p><b>stable</b> &minus; The initial state. There is no SDP offer/answer exchange in progress.</p></li>
<li><p><b>have-local-offer</b> &minus; the local side of the connection has locally applied a SDP offer.</p></li>
<li><p><b>have-remote-offer</b> &minus; the remote side of the connection has locally applied a SDP offer.</p></li>
<li><p><b>have-local-pranswer</b> &minus; a remote SDP offer has been applied, and a SDP pranswer applied locally.</p></li>
<li><p><b>have-remote-pranswer</b> &minus; a local SDP has been applied, and a SDP pranswer applied remotely.</p></li>
<li><p><b>closed</b> &minus; the connection is closed.</p></li>
</ul>
</li>
</ul>
<h3>Event Handlers</h3>
<section class="toggle">
<label>Given below are the commonly used Event Handlers of RTCPeerConnection.</label>
<div class="toggle-content">
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>Event Handlers &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>RTCPeerConnection.onaddstream</b></p>
<p>This handler is called when the addstream event is fired. This event is sent when a MediaStream is added to this connection by the remote peer.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>RTCPeerConnection.ondatachannel</b></p>
<p>This handler is called when the datachannel event is fired. This event is sent when a RTCDataChannel is added to this connection.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>RTCPeerConnection.onicecandidate</b></p>
<p>This handler is called when the icecandidate event is fired. This event is sent when a RTCIceCandidate object is added to the script.</p></td>
</tr>
<tr>
<td>4</td>
<td><p><b>RTCPeerConnection.oniceconnectionstatechange</b></p>
<p>This handler is called when the iceconnectionstatechange event is fired. This event is sent when the value of iceConnectionState changes.</p></td>
</tr>
<tr>
<td>5</td>
<td><p><b>RTCPeerConnection.onidentityresult</b></p>
<p>This handler is called when the identityresult event is fired. This event is sent when an identity assertion is generated during the creating of an offer or an answer of via getIdentityAssertion().</p></td>
</tr>
<tr>
<td>6</td>
<td><p><b>RTCPeerConnection.onidpassertionerror</b></p>
<p>This handler is called when the idpassertionerror event is fired. This event is sent when the IdP (Identitry Provider) finds an error while generating an identity assertion.</p></td>
</tr>
<tr>
<td>7</td>
<td><p><b>RTCPeerConnection.onidpvalidation</b></p>
<p>This handler is called when the idpvalidationerror event is fired. This event is sent when the IdP (Identitry Provider) finds an error while validating an identity assertion.</p></td>
</tr>
<tr>
<td>8</td>
<td><p><b>RTCPeerConnection.onnegotiationneeded</b></p>
<p>This handler is called when the negotiationneeded event is fired. This event is sent by the browser to inform the negotiation will be required at some point in the future.</p></td>
</tr>
<tr>
<td>9</td>
<td><p><b>RTCPeerConnection.onpeeridentity</b></p>
<p>This handler is called when the peeridentity event is fired. This event is sent when a peer identity has been set and verified on this connection.</p></td>
</tr>
<tr>
<td>10</td>
<td><p><b>RTCPeerConnection.onremovestream</b></p>
<p>This handler is called when the signalingstatechange event is fired. This event is sent when the value of signalingState changes.</p></td>
</tr>
<tr>
<td>11</td>
<td><p><b>RTCPeerConnection.onsignalingstatechange</b></p>
<p>This handler is called when the removestream event is fired. This event is sent when a MediaStream is removed from this connection.</p></td>
</tr>
</table>
</div>
</section>
<h3>Methods</h3>
<section class="toggle">
<label>Given below are the commonly used methods of RTCPeerConnection.</label>
<div class="toggle-content">
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>Methods &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>RTCPeerConnection()</b></p>
<p>Returns a new RTCPeerConnection object.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>RTCPeerConnection.createOffer()</b></p>
<p>Creates an offer(request) to find a remote peer. The two first parameters of this method are success and error callbacks. The optional third parameter are options, like enabling audio or video streams.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>RTCPeerConnection.createAnswer()</b></p>
<p>Creates an answer to the offer received by the remote peer during the offer/answer negotiation process. The two first parameters of this method are success and error callbacks. The optional third parameter are options for the answer to be created.</p></td>
</tr>
<tr>
<td>4</td>
<td><p><b>RTCPeerConnection.setLocalDescription()</b></p>
<p>Changes the local connection description. The description defines the properties of the connection. The connection must be able to support both old and new descriptions. The method takes three parameters, RTCSessionDescription object, callback if the change of description succeeds, callback if the change of description fails.</p></td>
</tr>
<tr>
<td>5</td>
<td><p><b>RTCPeerConnection.setRemoteDescription()</b></p>
<p>Changes the remote connection description. The description defines the properties of the connection. The connection must be able to support both old and new descriptions. The method takes three parameters, RTCSessionDescription object, callback if the change of description succeeds, callback if the change of description fails.</p></td>
</tr>
<tr>
<td>6</td>
<td><p><b>RTCPeerConnection.updateIce()</b></p>
<p>Updates the ICE agent process of pinging remote candidates and gathering local candidates.</p></td>
</tr>
<tr>
<td>7</td>
<td><p><b>RTCPeerConnection.addIceCandidate()</b></p>
<p>Provides a remote candidate to the ICE agent.</p></td>
</tr>
<tr>
<td>8</td>
<td><p><b>RTCPeerConnection.getConfiguration()</b></p>
<p>Returns a RTCConfiguration object. It represents the configuration of the RTCPeerConnection object.</p></td>
</tr>
<tr>
<td>9</td>
<td><p><b>RTCPeerConnection.getLocalStreams()</b></p>
<p>Returns an array of local MediaStream connection.</p></td>
</tr>
<tr>
<td>10</td>
<td><p><b>RTCPeerConnection.getRemoteStreams()</b></p>
<p>Returns an array of remote MediaStream connection.</p></td>
</tr>
<tr>
<td>11</td>
<td><p><b>RTCPeerConnection.getStreamById()</b></p>
<p>Returns local or remote MediaStream by the given ID.</p></td>
</tr>
<tr>
<td>12</td>
<td><p><b>RTCPeerConnection.addStream()</b></p>
<p>Adds a MediaStream as a local source of video or audio.</p></td>
</tr>
<tr>
<td>13</td>
<td><p><b>RTCPeerConnection.removeStream()</b></p>
<p>Removes a MediaStream as a local source of video or audio.</p></td>
</tr>
<tr>
<td>14</td>
<td><p><b>RTCPeerConnection.close()</b></p>
<p>Closes a connection.</p></td>
</tr>
<tr>
<td>15</td>
<td><p><b>RTCPeerConnection.createDataChannel()</b></p>
<p>Creates a new RTCDataChannel.</p></td>
</tr>
<tr>
<td>16</td>
<td><p><b>RTCPeerConnection.createDTMFSender()</b></p>
<p>Creates a new RTCDTMFSender, associated to a specific MediaStreamTrack. Allows to send DTMF (Dual-tone multifrequency) phone signaling over the connection.</p></td>
</tr>
<tr>
<td>17</td>
<td><p><b>RTCPeerConnection.getStats()</b></p>
<p>Creates a new RTCStatsReport that contains statistics concerning the connection.</p></td>
</tr>
<tr>
<td>18</td>
<td><p><b>RTCPeerConnection.setIdentityProvider()</b></p>
<p>Sets the IdP. Takes three parameters − the name, the protocol used to communicate and an optional username.</p></td>
</tr>
<tr>
<td>19</td>
<td><p><b>RTCPeerConnection.getIdentityAssertion()</b></p>
<p>Gathers an identity assertion. It is not expected to deal with this method in the application. So you may call it explicitly only to anticipate the need.</p></td>
</tr>
</table>
</div>
</section>
<h2>Establishing a Connection</h2>
<p>Now let's create an example application. Firstly, run the signaling server we created in the “signaling server” tutorial via “node server”.</p>
<p>There will be two text inputs on the page, one for a login and one for a username we want to connect to. Create an <i>index.html</i> file and add the following code &minus;</p>
<pre class="prettyprint notranslate">
&lt;html lang = "en"&gt; 
   &lt;head&gt; 
      &lt;meta charset = "utf-8" /&gt; 
   &lt;/head&gt;
	
   &lt;body&gt; 
	
      &lt;div&gt; 
         &lt;input type = "text" id = "loginInput" /&gt; 
         &lt;button id = "loginBtn"&gt;Login&lt;/button&gt; 
      &lt;/div&gt; 
	
      &lt;div&gt; 
         &lt;input type = "text" id = "otherUsernameInput" /&gt;
         &lt;button id = "connectToOtherUsernameBtn"&gt;Establish connection&lt;/button&gt; 
      &lt;/div&gt; 
		
      &lt;script src = "client2.js"&gt;&lt;/script&gt;
		
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>You can see that we've added the text input for a login, the login button, the text input for the other peer username, and the connect-to-him button. Now create a <i>client.js</i> file and add the following code &minus;</p>
<pre class="prettyprint notranslate">
var connection = new WebSocket('ws://localhost:9090'); 
var name = ""; 
 
var loginInput = document.querySelector('#loginInput'); 
var loginBtn = document.querySelector('#loginBtn'); 
var otherUsernameInput = document.querySelector('#otherUsernameInput'); 
var connectToOtherUsernameBtn = document.querySelector('#connectToOtherUsernameBtn'); 
var connectedUser, myConnection;
  
//when a user clicks the login button 
loginBtn.addEventListener("click", function(event){ 
   name = loginInput.value; 
	
   if(name.length &gt; 0){ 
      send({ 
         type: "login", 
         name: name 
      }); 
   } 
	
});
  
//handle messages from the server 
connection.onmessage = function (message) { 
   console.log("Got message", message.data);
   var data = JSON.parse(message.data); 
	
   switch(data.type) { 
      case "login": 
         onLogin(data.success); 
         break; 
      case "offer": 
         onOffer(data.offer, data.name); 
         break; 
      case "answer": 
         onAnswer(data.answer); 
         break; 
      case "candidate": 
         onCandidate(data.candidate); 
         break; 
      default: 
         break; 
   } 
};
  
//when a user logs in 
function onLogin(success) { 

   if (success === false) { 
      alert("oops...try a different username"); 
   } else { 
      //creating our RTCPeerConnection object 
		
      var configuration = { 
         "iceServers": [{ "url": "stun:stun.1.google.com:19302" }] 
      }; 
		
      myConnection = new webkitRTCPeerConnection(configuration); 
      console.log("RTCPeerConnection object was created"); 
      console.log(myConnection); 
  
      //setup ice handling
      //when the browser finds an ice candidate we send it to another peer 
      myConnection.onicecandidate = function (event) { 
		
         if (event.candidate) { 
            send({ 
               type: "candidate", 
               candidate: event.candidate 
            }); 
         } 
      }; 
   } 
};
  
connection.onopen = function () { 
   console.log("Connected"); 
};
  
connection.onerror = function (err) { 
   console.log("Got error", err); 
};
  
// Alias for sending messages in JSON format 
function send(message) { 

   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   connection.send(JSON.stringify(message)); 
};
</pre>
<p>You can see that we establish a socket connection to our signaling server. When a user clicks on the login button the application sends his username to the server. If login is successful the application creates the RTCPeerConnection object and setup onicecandidate handler which sends all found icecandidates to the other peer. Now open the page and try to login. You should see the following console output &minus;</p>
<img src="/webrtc/images/establishing_connection.jpg" alt="Establishing a Connection" />
<p>The next step is to create an offer to the other peer. Add the following code to your <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//setup a peer connection with another user 
connectToOtherUsernameBtn.addEventListener("click", function () { 
 
   var otherUsername = otherUsernameInput.value; 
   connectedUser = otherUsername;
	
   if (otherUsername.length &gt; 0) { 
      //make an offer 
      myConnection.createOffer(function (offer) { 
         console.log(); 
         send({ 
            type: "offer", 
            offer: offer 
         });
			
         myConnection.setLocalDescription(offer); 
      }, function (error) { 
         alert("An error has occurred."); 
      }); 
   } 
}); 
 
//when somebody wants to call us 
function onOffer(offer, name) { 
   connectedUser = name; 
   myConnection.setRemoteDescription(new RTCSessionDescription(offer)); 
	
   myConnection.createAnswer(function (answer) { 
      myConnection.setLocalDescription(answer); 
      send({ 
         type: "answer", 
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("oops...error"); 
   }); 
}
  
//when another user answers to our offer 
function onAnswer(answer) { 
   myConnection.setRemoteDescription(new RTCSessionDescription(answer)); 
} 
 
//when we got ice candidate from another user 
function onCandidate(candidate) { 
   myConnection.addIceCandidate(new RTCIceCandidate(candidate)); 
}	
</pre>
<p>You can see that when a user clicks the “Establish connection” button the application makes an SDP offer to the other peer. We also set <i>onAnswer</i> and <i>onCandidate</i> handlers. Reload your page, open it in two tabs, login with two users and try to establish a connection between them. You should see the following console output &minus;</p>
<img src="/webrtc/images/console_output.jpg" alt="Console Output" />
<p>Now the peer-to-peer connection is established. In the next tutorials, we will add video and audio streams as well as text chat support.</p>
<h1>WebRTC - RTCDataChannel APIs</h1>
<p>WebRTC is not only good at transferring audio and video streams, but any arbitrary data we might have. This is where the RTCDataChannel object comes into play.</p>
<h2>RTCDataChannel API</h2>
<h3>Properties</h3>
<ul class="list">
<li><p><b>RTCDataChannel.label (read only)</b> &minus; Returns a string containing the data channel name.</p></li>
<li><p><b>RTCDataChannel.ordered (read only)</b> &minus; Returns true if the order of delivery of the messages is guaranteed or false if it is not guaranteed.</p></li>
<li><p><b>RTCDataChannel.protocol (read only)</b> &minus; Returns a string containing subprotocol name used for this channel.</p></li>
<li><p><b>RTCDataChannel.id (read only)</b> &minus; Returns a unique id for the channel which is set at the creation of the RTCDataChannel object.</p></li>
<li><p><b>RTCDataChannel.readyState (read only)</b> &minus; Returns the RTCDataChannelState enum representing the state of the connection. The possible values &minus;</p>
<ul class="list">
<li><p><b>connecting</b> &minus; Indicates that the connection is not yet active. This is the initial state.</p></li>
<li><p><b>open</b> &minus; Indicates that the connection is running.</p></li>
<li><p><b>closing</b> &minus; Indicates that the connection is in the process of shutting down. The cached messages are in the process of being sent or received, but no newly created task is accepting.</p></li>
<li><p><b>closed</b> &minus; Indicates that the connection could not be established or has been shut down.</p></li>
</ul>
</li>
<li><p><b>RTCDataChannel.bufferedAmount (read only)</b> &minus; Returns the amount of bytes that have been queued for sending. This is the amount of data that has not been sent yet via RTCDataChannel.send().</p></li>
<li><p><b>RTCDataChannel.bufferedAmountLowThreshold</b> &minus; Returns the number of bytes at which the RTCDataChannel.bufferedAmount is taken up as low. When the RTCDataChannel.bufferedAmount decreases below this threshold, the bufferedamountlow event is fired.</p></li>
<li><p><b>RTCDataChannel.binaryType</b> &minus; Returns the type of the binary data transmitted by the connection. Can be “blob” or “arraybuffer”.</p></li>
<li><p><b>RTCDataChannel.maxPacketLifeType (read only)</b> &minus; Returns an unsigned short that indicates the length in milliseconds of the window in when messaging is going in unreliable mode.</p></li>
<li><p><b>RTCDataChannel.maxRetransmits (read only)</b> &minus; Returns an unsigned short that indicates the maximum number of times a channel will retransmit data if it is not delivered.</p></li>
<li><p><b>RTCDataChannel.negotiated (read only)</b> &minus; Returns a boolean that indicates if the channel has been negotiated by the user-agent, or by the application.</p></li>
<li><p><b>RTCDataChannel.reliable (read only)</b> &minus; Returns a boolean that indicates of the connection can send messages in unreliable mode.</p></li>
<li><p><b>RTCDataChannel.stream (read only)</b> &minus; Synonym for RTCDataChannel.id</p></li>
</ul>
<h3>Event Handlers</h3>
<ul class="list">
<li><p><b>RTCDataChannel.onopen</b> &minus; This event handler is called when the open event is fired. This event is sent when the data connection has been established.</p></li>
<li><p><b>RTCDataChannel.onmessage</b> &minus; This event handler is called when the message event is fired. The event is sent when a message is available on the data channel.</p></li>
<li><p><b>RTCDataChannel.onbufferedamountlow</b> &minus; This event handler is called when the bufferedamoutlow event is fired. This event is sent when RTCDataChannel.bufferedAmount decreases below the RTCDataChannel.bufferedAmountLowThreshold property.</p></li>
<li><p><b>RTCDataChannel.onclose</b> &minus; This event handler is called when the close event is fired. This event is sent when the data connection has been closed.</p></li>
<li><p><b>RTCDataChannel.onerror</b> &minus; This event handler is called when the error event is fired. This event is sent when an error has been encountered.</p></li>
</ul>
<h3>Methods</h3>
<ul class="list">
<li><p><b>RTCDataChannel.close()</b> &minus; Closes the data channel.</p></li>
<li><p><b>RTCDataChannel.send()</b> &minus; Sends the data in the parameter over the channel. The data can be a blob, a string, an ArrayBuffer or an ArrayBufferView.</p></li>
</ul>
<h1>WebRTC - Sending Messages</h1>
<p>Now let's create a simple example. Firstly, run the signaling server we created in the “signaling server” tutorial via “node server”.</p>
<p>There will be three text inputs on the page, one for a login, one for a username, and one for the message we want to send to the other peer. Create an <i>index.html</i> file and add the following code &minus;</p>
<pre class="prettyprint notranslate">
&lt;html lang = "en"&gt; 
   &lt;head&gt; 
      &lt;meta charset = "utf-8" /&gt; 
   &lt;/head&gt;
	
   &lt;body&gt; 
      &lt;div&gt; 
         &lt;input type = "text" id = "loginInput" /&gt; 
         &lt;button id = "loginBtn"&gt;Login&lt;/button&gt; 
      &lt;/div&gt; 
		
      &lt;div&gt; 
         &lt;input type = "text" id = "otherUsernameInput" /&gt; 
         &lt;button id = "connectToOtherUsernameBtn"&gt;Establish connection&lt;/button&gt; 
      &lt;/div&gt; 
		
      &lt;div&gt; 
         &lt;input type = "text" id = "msgInput" /&gt; 
         &lt;button id = "sendMsgBtn"&gt;Send text message&lt;/button&gt; 
      &lt;/div&gt; 
		
      &lt;script src = "client.js"&gt;&lt;/script&gt;
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>We've also added three buttons for login, establishing a connection and sending a message. Now create a <i>client.js</i> file and add the following code &minus;</p>
<pre class="prettyprint notranslate">
var connection = new WebSocket('ws://localhost:9090'); 
var name = "";

var loginInput = document.querySelector('#loginInput'); 
var loginBtn = document.querySelector('#loginBtn'); 

var otherUsernameInput = document.querySelector('#otherUsernameInput'); 
var connectToOtherUsernameBtn = document.querySelector('#connectToOtherUsernameBtn'); 
var msgInput = document.querySelector('#msgInput'); 
var sendMsgBtn = document.querySelector('#sendMsgBtn'); 
var connectedUser, myConnection, dataChannel;
  
//when a user clicks the login button 
loginBtn.addEventListener("click", function(event) { 
   name = loginInput.value; 
	
   if(name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name 
      }); 
   } 
}); 
 
//handle messages from the server 
connection.onmessage = function (message) { 
   console.log("Got message", message.data); 
   var data = JSON.parse(message.data); 
	
   switch(data.type) { 
      case "login": 
         onLogin(data.success); 
         break; 
      case "offer": 
         onOffer(data.offer, data.name); 
         break; 
      case "answer":
         onAnswer(data.answer); 
         break; 
      case "candidate": 
         onCandidate(data.candidate); 
         break; 
      default: 
         break; 
   } 
}; 
 
//when a user logs in 
function onLogin(success) { 

   if (success === false) { 
      alert("oops...try a different username"); 
   } else { 
      //creating our RTCPeerConnection object 
      var configuration = { 
         "iceServers": [{ "url": "stun:stun.1.google.com:19302" }] 
      }; 
		
      myConnection = new webkitRTCPeerConnection(configuration, { 
         optional: [{RtpDataChannels: true}] 
      }); 
		
      console.log("RTCPeerConnection object was created"); 
      console.log(myConnection); 
  
      //setup ice handling 
      //when the browser finds an ice candidate we send it to another peer 
      myConnection.onicecandidate = function (event) { 
		
         if (event.candidate) { 
            send({ 
               type: "candidate", 
               candidate: event.candidate 
            });
         } 
      }; 
		
      openDataChannel();
		
   } 
};
  
connection.onopen = function () { 
   console.log("Connected"); 
}; 
 
connection.onerror = function (err) { 
   console.log("Got error", err); 
};
  
// Alias for sending messages in JSON format 
function send(message) { 
   if (connectedUser) { 
      message.name = connectedUser; 
   }
	
   connection.send(JSON.stringify(message)); 
};
</pre>
<p>You can see that we establish a socket connection to our signaling server. When a user clicks on the login button the application sends his username to the server. If login is successful the application creates the <i>RTCPeerConnection</i> object and setup <i>onicecandidate</i> handler which sends all found icecandidates to the other peer. It also runs the openDataChannel() function which creates a dataChannel. Notice that when creating the RTCPeerConnection object the second argument in the constructor optional: [{RtpDataChannels: true}] is mandatory if you are using Chrome or Opera. The next step is to create an offer to the other peer. Add the following code to your <i>client.js</i> file&minus;</p>
<pre class="prettyprint notranslate">
//setup a peer connection with another user 
connectToOtherUsernameBtn.addEventListener("click", function () {
  
   var otherUsername = otherUsernameInput.value;
   connectedUser = otherUsername;
	
   if (otherUsername.length &gt; 0) { 
      //make an offer 
      myConnection.createOffer(function (offer) { 
         console.log(); 
         send({ 
            type: "offer", 
            offer: offer 
         }); 
			
         myConnection.setLocalDescription(offer); 
      }, function (error) { 
         alert("An error has occurred."); 
      }); 
   } 
});
  
//when somebody wants to call us 
function onOffer(offer, name) { 
   connectedUser = name; 
   myConnection.setRemoteDescription(new RTCSessionDescription(offer));
	
   myConnection.createAnswer(function (answer) { 
      myConnection.setLocalDescription(answer); 
		
      send({ 
         type: "answer", 
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("oops...error"); 
   }); 
}

//when another user answers to our offer 
function onAnswer(answer) { 
   myConnection.setRemoteDescription(new RTCSessionDescription(answer)); 
}
  
//when we got ice candidate from another user 
function onCandidate(candidate) { 
   myConnection.addIceCandidate(new RTCIceCandidate(candidate)); 
}
</pre>
<p>You can see that when a user clicks the “Establish connection” button the application makes an SDP offer to the other peer. We also set <i>onAnswer</i> and <i>onCandidate</i> handlers. Finally, let's implement the <i>openDataChannel()</i> function which creates our dataChannel. Add the following code to your <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//creating data channel 
function openDataChannel() { 

   var dataChannelOptions = { 
      reliable:true 
   }; 
	
   dataChannel = myConnection.createDataChannel("myDataChannel", dataChannelOptions);
	
   dataChannel.onerror = function (error) { 
      console.log("Error:", error); 
   };
	
   dataChannel.onmessage = function (event) { 
      console.log("Got message:", event.data); 
   };  
}
  
//when a user clicks the send message button 
sendMsgBtn.addEventListener("click", function (event) { 
   console.log("send message");
   var val = msgInput.value; 
   dataChannel.send(val); 
});
</pre>
<p>Here we create the dataChannel for our connection and add the event handler for the “send message” button. Now open this page in two tabs, login with two users, establish a connection, and try to send messages. You should see them in the console output. Notice that the above example is tested in Opera.</p>
<img src="/webrtc/images/example_in_opera.jpg" alt="Example in Opera" />
<p>Now you may see that RTCDataChannel is extremely powerful part of the WebRTC API. There are a lot of other use cases for this object, like peer-to-peer gaming or torrent-based file sharing.</p>
<h1>WebRTC - Signaling</h1>
<p>Most WebRTC applications are not just being able to communicate through video and audio. They need many other features. In this chapter, we are going to build a basic signaling server.</p>
<h2>Signaling and Negotiation</h2>
<p>To connect to another user you should know where he is located on the Web. The IP address of your device allows Internet-enabled devices to send data directly between each other. The <i>RTCPeerConnection</i> object is responsible for this. As soon as devices know how to find each other over the Internet, they start exchanging data about which protocols and codecs each device supports.</p>
<p>To communicate with another user you simply need to exchange contact information and the rest will be done by WebRTC. The process of connecting to the other user is also known as signaling and negotiation. It consists of a few steps &minus;</p>
<ul class="list">
<li><p>Create a list of potential candidates for a peer connection.</p></li>
<li><p>The user or an application selects a user to make a connection with.</p></li>
<li><p>The signaling layer notifies another user that someone want to connect to him. He can accept or decline.</p></li>
<li><p>The first user is notified of the acceptance of the offer.</p></li>
<li><p>The first user initiates <i>RTCPeerConnection</i> with another user.</p></li>
<li><p>Both users exchange software and hardware information through the signaling server.</p></li>
<li><p>Both users exchange location information.</p></li>
<li><p>The connection succeeds or fails.</p></li>
</ul>
<p>The WebRTC specification does not contain any standards about exchanging information. So keep in mind that the above is just an example of how signaling may happen. You can use any protocol or technology you like.</p>
<h2>Building the Server</h2>
<p>The server we are going to build will be able to connect two users together who are not located on the same computer. We will create our own signaling mechanism. Our signaling server will allow one user to call another. Once a user has called another, the server passes the offer, answer, ICE candidates between them and setup a WebRTC connection.</p>
<img src="/webrtc/images/building_the_server.jpg" alt="Building the Server" />
<p>The above diagram is the messaging flow between users when using the signaling server. First of all, each user registers with the server. In our case, this will be a simple string username. Once users have registered, they are able to call each other. User 1 makes an offer with the user identifier he wishes to call. The other user should answers. Finally, ICE candidates are sent between users until they can make a connection.</p>
<p>To create a WebRTC connection clients have to be able to transfer messages without using a WebRTC peer connection. This is where we will use HTML5 WebSockets – a bidirectional socket connection between two endpoints – a web server and a web browser. Now let's start using the WebSocket library. Create the <i>server.js</i> file and insert the following code &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 
 
//when a user connects to our sever 
wss.on('connection', function(connection) { 
   console.log("user connected");
	
   //when server gets a message from a connected user 
   connection.on('message', function(message){ 
      console.log("Got message from a user:", message); 
   }); 
	
   connection.send("Hello from server"); 
}); 
</pre>
<p>The first line requires the WebSocket library which we have already installed. Then we create a socket server on the port 9090. Next, we listen to the <i>connection</i> event. This code will be executed when a user makes a WebSocket connection to the server. We then listen to any messages sent by the user. Finally, we send a response to the connected user saying “Hello from server”.</p>
<p>Now run <i>node server</i> and the server should start listening for socket connections.</p>
<p>To test our server, we'll use the <i>wscat</i> utility which we also have already installed. This tool helps in connecting directly to the WebSocket server and test out commands. Run our server in one terminal window, then open another and run the <i>wscat -c ws://localhost:9090</i> command. You should see the following on the client side &minus;</p>
<img src="/webrtc/images/wscat_utility.jpg" alt="use the wscat utility" />
<p>The server should also log the connected user &minus;</p>
<img src="/webrtc/images/connect_user.jpg" alt="Log the Connected User" />
<h2>User Registration</h2>
<p>In our signaling server, we will use a string-based username for each connection so we know where to send messages. Let's change our <i>connection</i> handler a bit &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) { 
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON"); 
      data = {}; 
   } 
	
});
</pre>
<p>This way we accept only JSON messages. Next, we need to store all connected users somewhere. We will use a simple Javascript object for it. Change the top of our file &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server;
 
//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users
var users = {};
</pre>
<p>We are going to add a <i>type</i> field for every message coming from the client. For example if a user wants to login, he sends the <i>login</i> type message. Let's define it &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message){
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON"); 
      data = {}; 
   }
	
   //switching type of the user message 
   switch (data.type) { 
      //when a user tries to login 
      case "login": 
         console.log("User logged:", data.name); 
			
         //if anyone is logged in with this username then refuse 
         if(users[data.name]) { 
            sendTo(connection, { 
               type: "login", 
               success: false 
            }); 
         } else { 
            //save user connection on the server 
            users[data.name] = connection; 
            connection.name = data.name; 
				
            sendTo(connection, { 
               type: "login", 
               success: true 
            });
				
         } 
			
         break;
					 
      default: 
         sendTo(connection, { 
            type: "error", 
            message: "Command no found: " + data.type 
         }); 
			
         break; 
   } 
	
});
</pre>
<p>If the user sends a message with the <i>login</i> type, we &minus;</p>
<ul class="list">
<li><p>Check if anyone has already logged in with this username</p></li>
<li><p>If so, then tell the user that he hasn't successfully logged in</p></li>
<li><p>If no one is using this username, we add username as a key to the connection object.</p></li>
<li><p>If a command is not recognized we send an error.</p></li>
</ul>
<p>The following code is a helper function for sending messages to a connection. Add it to the <i>server.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<p>The above function ensures that all our messages are sent in the JSON format.</p>
<p>When the user disconnects we should clean up its connection. We can delete the user when the <i>close</i> event is fired. Add the following code to the <i>connection</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 
   if(connection.name) { 
      delete users[connection.name]; 
    } 
});
</pre>
<p>Now let's test our server with the login command. Keep in mind that all messages must be encoded in the JSON format. Run our server and try to login. You should see something like this &minus;</p>
<img src="/webrtc/images/login_command.jpg" alt="Test with Login Command" />
<h2>Making a Call</h2>
<p>After successful login the user wants to call another. He should make an <i>offer</i> to another user to achieve it. Add the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "offer": 
   //for ex. UserA wants to call UserB 
   console.log("Sending offer to: ", data.name); 
	
   //if UserB exists then send him offer details 
   var conn = users[data.name]; 
	
   if(conn != null){ 
      //setting that UserA connected with UserB 
      connection.otherName = data.name; 
		
      sendTo(conn, { 
         type: "offer", 
         offer: data.offer, 
         name: connection.name 
      }); 
   }
	
   break;
</pre>
<p>Firstly, we get the <i>connection</i> of the user we are trying to call. If it exists we send him <i>offer</i> details. We also add <i>otherName</i> to the <i>connection</i> object. This is made for the simplicity of finding it later.</p>
<h2>Answering</h2>
<p>Answering to the response has a similar pattern that we used in the <i>offer</i> handler. Our server just passes through all messages as <i>answer</i> to another user. Add the following code after the <i>offer</i> hander &minus;</p>
<pre class="prettyprint notranslate">
case "answer": 
   console.log("Sending answer to: ", data.name); 
	
   //for ex. UserB answers UserA 
   var conn = users[data.name]; 
	
   if(conn != null) { 
      connection.otherName = data.name; 
      sendTo(conn, { 
         type: "answer", 
         answer: data.answer 
      }); 
   }
	
   break;
</pre>
<p>You can see how this is similar to the <i>offer</i> handler. Notice this code follows the <i>createOffer</i> and <i>createAnswer</i> functions on the <i>RTCPeerConnection</i> object.</p>
<p>Now we can test our offer/answer mechanism. Connect two clients at the same time and try to make offer and answer. You should see the following &minus;</p>
<img src="/webrtc/images/connect_two_client.jpg" alt="Connect two clients" />
<p>In this example, <b>offer</b> and <b>answer</b> are simple strings, but in a real application they will be filled in with the SDP data.</p>
<h2>ICE Candidates</h2>
<p>The final part is handling ICE candidate between users. We use the same technique just passing messages between users. The main difference is that candidate messages might happen multiple times per user in any order. Add the <i>candidate</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "candidate": 
   console.log("Sending candidate to:",data.name); 
   var conn = users[data.name]; 
	
   if(conn != null) {
      sendTo(conn, { 
         type: "candidate", 
         candidate: data.candidate 
      }); 
   }
	
   break;
</pre>
<p>It should work similarly to the <i>offer</i> and <i>answer</i> handlers.</p>
<h2>Leaving the Connection</h2>
<p>To allow our users to disconnect from another user we should implement the hanging up function. It will also tell the server to delete all user references. Add the <b>leave</b> handler &minus;</p>
<pre class="prettyprint notranslate">
case "leave": 
   console.log("Disconnecting from", data.name); 
   var conn = users[data.name]; 
   conn.otherName = null; 
	
   //notify the other user so he can disconnect his peer connection 
   if(conn != null) { 
      sendTo(conn, { 
         type: "leave" 
      }); 
   } 
	
   break;
</pre>
<p>This will also send the other user the <i>leave</i> event so he can disconnect his peer connection accordingly. We should also handle the case when a user drops his connection from the signaling server. Let's modify our <i>close</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 

   if(connection.name) { 
      delete users[connection.name]; 
		
      if(connection.otherName) { 
         console.log("Disconnecting from ", connection.otherName); 
         var conn = users[connection.otherName]; 
         conn.otherName = null;
			
         if(conn != null) { 
            sendTo(conn, { 
               type: "leave" 
            }); 
         }  
      } 
   } 
});
</pre>
<p>Now if the connection terminates our users will be disconnected. The <i>close</i> event will be fired when a user closes his browser window while we are still in <i>offer</i>, <i>answer</i> or <i>candidate</i> state.</p>
<h2>Complete Signaling Server</h2>
<p>Here is the entire code of our signaling server &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server;
 
//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};
  
//when a user connects to our sever 
wss.on('connection', function(connection) {
  
   console.log("User connected");
	
   //when server gets a message from a connected user
   connection.on('message', function(message) { 
	
      var data; 
      //accepting only JSON messages 
      try {
         data = JSON.parse(message); 
      } catch (e) { 
         console.log("Invalid JSON"); 
         data = {}; 
      } 
		
      //switching type of the user message 
      switch (data.type) { 
         //when a user tries to login 
			
         case "login": 
            console.log("User logged", data.name); 
				
            //if anyone is logged in with this username then refuse 
            if(users[data.name]) { 
               sendTo(connection, { 
                  type: "login", 
                  success: false 
               }); 
            } else { 
               //save user connection on the server 
               users[data.name] = connection; 
               connection.name = data.name; 
               sendTo(connection, { 
                  type: "login", 
                  success: true 
               }); 
            } 
				
            break; 
				
         case "offer": 
            //for ex. UserA wants to call UserB 
            console.log("Sending offer to: ", data.name); 
				
            //if UserB exists then send him offer details 
            var conn = users[data.name];
				
            if(conn != null) { 
               //setting that UserA connected with UserB 
               connection.otherName = data.name; 
					
               sendTo(conn, { 
                  type: "offer", 
                  offer: data.offer, 
                  name: connection.name 
               }); 
            } 
				
            break;  
				
         case "answer": 
            console.log("Sending answer to: ", data.name); 
            //for ex. UserB answers UserA 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               connection.otherName = data.name; 
               sendTo(conn, { 
                  type: "answer", 
                  answer: data.answer 
               }); 
            } 
				
            break;  
				
         case "candidate": 
            console.log("Sending candidate to:",data.name); 
            var conn = users[data.name];  
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "candidate", 
                  candidate: data.candidate 
               });
            } 
				
            break;  
				
         case "leave": 
            console.log("Disconnecting from", data.name); 
            var conn = users[data.name]; 
            conn.otherName = null; 
				
            //notify the other user so he can disconnect his peer connection 
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
               }); 
            }  
				
            break;  
				
         default: 
            sendTo(connection, { 
               type: "error", 
               message: "Command not found: " + data.type 
            }); 
				
            break; 
      }  
   });  
	
   //when user exits, for example closes a browser window 
   //this may help if we are still in "offer","answer" or "candidate" state 
   connection.on("close", function() { 
	
      if(connection.name) { 
      delete users[connection.name]; 
		
         if(connection.otherName) { 
            console.log("Disconnecting from ", connection.otherName);
            var conn = users[connection.otherName]; 
            conn.otherName = null;  
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
               });
            }  
         } 
      } 
   });  
	
   connection.send("Hello world"); 
	
});  

function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<p>So the work is done and our signaling server is ready. Remember that doing things out of order when making a WebRTC connection can cause issues.</p>
<h2>Summary</h2>
<p>In this chapter, we built simple and straightforward signaling server. We walked through the signaling process, user registration and offer/answer mechanism. We also implemented sending candidates between users.</p>
<h1>WebRTC - Browser Support</h1>
<p>The Web is moving so fast and it is always improving. New standards are created every day. Browsers allow updates to be installed without the user ever knowing, so you should keep up with what is going on in the world of the Web and WebRTC. Here is an overview of what this is up to today.</p>
<h2>Browser Support</h2>
<p>Every browser doesn't have all the same WebRTC features at the same time. Different browsers may be ahead of the curve, which makes some WebRTC features work in one browser and not another. The current support for WebRTC in the browser is shown in the following picture.</p>
<img src="/webrtc/images/browser_support.jpg" alt="Browser Support" />
<p>You can check an up-to-date WebRTC support status at <a target="_blank" rel="nofollow" href="http://caniuse.com/#feat=rtcpeerconnection">http://caniuse.com/#feat=rtcpeerconnection.</a></p>
<h3>Chrome, Firefox, and Opera</h3>
<p>The latest versions of Chrome, Firefox, and Opera on mainstream PC operating systems such as Mac OS X, Windows, and Linux, all support WebRTC out-of-the-box. And most importantly, the engineers from Chrome and Firefox developer teams have been working together to fix issues so these two browsers could communicate with each other easily.</p>
<h3>Android OS</h3>
<p>On Android operating systems, WebRTC applications for Chrome and Firefox should work outof-the-box. They are able to work with other browsers after Android Ice Cream Sandwich version (4.0). This is due to the code sharing between desktop and mobile versions.</p>
<h3>Apple</h3>
<p>Apple has not yet made any announcement about their plans to support WebRTC in Safari on OS X. One of the possible workarounds for hybrid native iOS applications os to embed the WebRTC code directly into the application and load this app into a WebView.</p>
<h3>Internet Explorer</h3>
<p>Microsoft doesn't support WebRTC on desktops. But they have officially confirmed that they are going to implement ORTC (Object Realtime Communications) in future versions of IE(Edge). They are not planning to support WebRTC 1.0. They labeled their ORTC as WebRTC 1.1, although it is just a community enhancement and not the official standard. Recently they've added the ORTC support to the latest Microsoft Edge version. You may learn more at <a target="_blank" rel="nofollow" href="https://blogs.windows.com/msedgedev/2015/09/18/ortc-api-is-now-available-in-microsoft-edge/">https://blogs.windows.com/msedgedev/2015/09/18/ortc-api-is-now-available-in-microsoftedge/.</a></p>
<h3>Summary</h3>
<p>Notice that WebRTC is a collection of APIs and protocols, not a single API. The support for each of these is developing on different browsers and operating systems at a different level. A great way to check the latest level of support is through <a target="_blank" rel="nofollow" href="http://canisue.com/">http://canisue.com.</a> It tracks adoption of modern APIs across multiple browsers. You can also find the latest information on browser supports as well as WebRTC demos at <a target="_blank" rel="nofollow" href="http://www.webrtc.org/">http://www.webrtc.org,</a> which is supported by Mozilla, Google, and Opera.</p>
<h1>WebRTC - Mobile Support</h1>
<p>In the mobile world, the WebRTC support is not on the same level as it is on desktops. Mobile devices have their own way, so WebRTC is also something different on the mobile platforms.</p>
<img src="/webrtc/images/mobile_support.jpg" alt="Mobile Support" />
<p>When developing a WebRTC application for desktop, we consider using Chrome, Firefox or Opera. All of them support WebRTC out of the box. In general, you just need a browser and not bother about the desktop's hardware.</p>
<p>In the mobile world there are three possible modes for WebRTC today &minus;</p>
<ul class="list">
<li>The native application</li>
<li>The browser application</li>
<li>The native browser</li>
</ul>
<h2>Android</h2>
<p>In 2013, the Firefox web browser for Android was presented with WebRTC support out of the box. Now you can make video calls on Android devices using the Firefox mobile browser.</p>
<p>It has three main WebRTC components &minus;</p>
<ul class="list">
<li><p><b>PeerConnection</b> &minus; enables calls between browsers</p></li>
<li><p><b>getUserMedia</b> &minus; provides access to the camera and microphone</p></li>
<li><p><b>DataChannels</b> &minus; provides peer-to-peer data transfer</p></li>
</ul>
<p>Google Chrome for Android provides WebRTC support as well. As you've already noticed, the most interesting features usually first appear in Chrome.</p>
<p>In the past year, the Opera mobile browser appeared with WebRTC support. So for Android you have Chrome, Firefox, and Opera. Other browsers don't support WebRTC.</p>
<h2>iOS</h2>
<p>Unfortunately, WebRTC is not supported on iOS now. Although WebRTC works well on Mac when using Firefox, Opera, or Chrome, it is not supported on iOS.</p>
<p>Nowadays, your WebRTC application won't work on Apple mobile devices out of the box. But there is a browser &minus; Bowser. It is a web browser developed by Ericsson and it supports WebRTC out of the box. You can check its homepage at <a target="_blank" rel="nofollow" href="http://www.openwebrtc.org/bowser/">http://www.openwebrtc.org/bowser/.</a></p>
<p>Today, it is the only friendly way to support your WebRTC application on iOS. Another way is to develop a native application yourself.</p>
<h2>Windows Phones</h2>
<p>Microsoft doesn't support WebRTC on mobile platforms. But they have officially confirmed that they are going to implement ORTC (Object Realtime Communications) in future versions of IE. They are not planning to support WebRTC 1.0. They labeled their ORTC as WebRTC 1.1, although it is just a community enhancement and not the official standard.</p>
<p>So today Window Phone users can't use WebRTC applications and there is no way to beat this situation.</p>
<h2>Blackberry</h2>
<p>WebRTC applications are not supported on Blackberry either, in any way.</p>
<h2>Using a WebRTC Native Browser</h2>
<p>The most convenient and comfortable case for users to utilize WebRTC is using the native browser of the device. In this case, the device is ready to work any additional configurations.</p>
<p>Today only Android devices that are version 4 or higher provide this feature. Apple still doesn't show any activity with WebRTC support. So Safari users can't use WebRTC applications. Microsoft also did not introduce it in Windows Phone 8.</p>
<h2>Using WebRTC via Browser Applications</h2>
<p>This means using a third-party applications (non-native web browsers) in order to provide the WebRTC features. For now, there are two such third-party applications. Bowser, which is the only way to bring WebRTC features to the iOS device and Opera, which is a nice alternative for Android platform. The rest of the available mobile browsers don't support WebRTC.</p>
<h2>Native Mobile Applications</h2>
<p>As you can see, WebRTC does not have a large support in the mobile world yet. So, one of the possible solutions is to develop a native applications that utilize the WebRTC API. But it is not the better choice because the main WebRTC feature is a cross-platform solution. Anyway, in some cases this is the only way because a native application can utilize device-specific functions or features that are not supported by HTML5 browsers.</p>
<h2>Constraining Video Stream for Mobile and Desktop Devices</h2>
<p>The first parameter of the <i>getUserMedia</i> API expects an object of keys and values telling the browser how to process streams. You can check the full set of constraints at <a target="_blank" rel="nofollow" href= "https://tools.ietf.org/html/draft-alvestrand-constraints-resolution-03">https://tools.ietf.org/html/draft-alvestrand-constraints-resolution-03.</a> You can setup video aspect ration, frameRate, and other optional parameters.</p>
<p>Supporting mobile devices is one of the biggest pains because mobile devices have limited screen space along with limited resources. You might want the mobile device to only capture a 480x320 resolution or smaller video stream to save power and bandwidth. Using the user agent string in the browser is a good way to test whether the user is on a mobile device or not. Let's see an example. Create the <i>index.html</i> file &minus;</p>
<pre class="prettyprint notranslate">
&lt;!DOCTYPE html&gt; 
&lt;html lang = "en"&gt;
 
   &lt;head&gt; 
      &lt;meta charset = "utf-8" /&gt; 
   &lt;/head&gt; 
	
   &lt;body&gt; 
      &lt;video autoplay&gt;&lt;/video&gt; 
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>Then create the following <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//constraints for desktop browser 
var desktopConstraints = { 

   video: { 
      mandatory: { 
         maxWidth:800,
         maxHeight:600   
      }  
   }, 
	
   audio: true 
}; 
 
//constraints for mobile browser 
var mobileConstraints = { 

   video: { 
      mandatory: { 
         maxWidth: 480, 
         maxHeight: 320, 
      } 
   }, 
	
   audio: true 
}
  
//if a user is using a mobile browser 
if(/Android|iPhone|iPad/i.test(navigator.userAgent)) { 
   var constraints = mobileConstraints;   
} else { 
   var constraints = desktopConstraints; 
}
  
function hasUserMedia() { 
   //check if the browser supports the WebRTC 
   return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || 
      navigator.mozGetUserMedia); 
}
  
if (hasUserMedia()) {
  
   navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || 
      navigator.mozGetUserMedia;
	
   //enabling video and audio channels 
   navigator.getUserMedia(constraints, function (stream) { 
      var video = document.querySelector('video');
		
      //inserting our stream to the video tag     
      video.src = window.URL.createObjectURL(stream);
		
   }, function (err) {}); 
} else { 
   alert("WebRTC is not supported"); 
}
</pre>
<p>Run the web server using the <i>static</i> command and open the page. You should see it is 800x600. Then open this page in a mobile viewport using chrome tools and check the resolution. It should be 480x320.</p>
<img src="/webrtc/images/run_server_using_static.jpg" alt="Run the web server" />
<p>Constraints are the easiest way to increase the performance of your WebRTC application.</p>
<h2>Summary</h2>
<p>In this chapter, we learned about the issues that can occur when developing WebRTC applications for mobile devices. We discovered different limitations of supporting the WebRTC API on mobile platforms. We also launched a demo application where we set different constraints for desktop and mobile browsers.</p>
<h1>WebRTC - Video Demo</h1>
<p>In this chapter, we are going to build a client application that allows two users on separate devices to communicate using WebRTC. Our application will have two pages. One for login and the other for calling another user.</p>
<img src="/webrtc/images/login_page.jpg" alt="Login Page" />
<p>The two pages will be the <i>div</i> tags. Most input is done through simple event handlers.</p>
<img src="/webrtc/images/calling_page.jpg" alt="Page for Calling." />
<h2>Signaling Server</h2>
<p>To create a WebRTC connection clients have to be able to transfer messages without using a WebRTC peer connection. This is where we will use HTML5 WebSockets &minus; a bidirectional socket connection between two endpoints &minus; a web server and a web browser. Now let's start using the WebSocket library. Create the <i>server.js</i> file and insert the following code &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090});
  
//when a user connects to our sever 
wss.on('connection', function(connection) { 
   console.log("user connected"); 
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) { 
      console.log("Got message from a user:", message); 
   }); 
	
   connection.send("Hello from server");
});
</pre>
<p>The first line requires the WebSocket library which we have already installed. Then we create a socket server on the port 9090. Next, we listen to the <i>connection</i> event. This code will be executed when a user makes a WebSocket connection to the server. We then listen to any messages sent by the user. Finally, we send a response to the connected user saying “Hello from server”.</p>
<p>In our signaling server, we will use a string-based username for each connection so we know where to send messages. Let's change our connection <i>handler</i> a bit &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) { 
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON"); 
      data = {}; 
   } 
});
</pre>
<p>This way we accept only JSON messages. Next, we need to store all connected users somewhere. We will use a simple Javascript object for it. Change the top of our file &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};
</pre>
<p>We are going to add a <i>type</i> field for every message coming from the client. For example if a user wants to login, he sends the <i>login</i> type message. Let's define it &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) { 
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message);
   } catch (e) { 
      console.log("Invalid JSON"); 
      data = {}; 
   } 
	
   //switching type of the user message 
   switch (data.type) { 
      //when a user tries to login 
      case "login": 
         console.log("User logged:", data.name); 
			
         //if anyone is logged in with this username then refuse 
         if(users[data.name]) { 
            sendTo(connection, { 
               type: "login", 
               success: false 
            }); 
         } else { 
            //save user connection on the server 
            users[data.name] = connection; 
            connection.name = data.name; 
				
            sendTo(connection, { 
               type: "login", 
               success: true 
            }); 
         } 
			
         break;
			
      default: 
         sendTo(connection, { 
            type: "error", 
            message: "Command no found: " + data.type 
         }); 
			
         break;
   }  
});					 
</pre>
<p>If the user sends a message with the <i>login</i> type, we &minus;</p>
<ul class="list">
<li><p>Check if anyone has already logged in with this username</p></li>
<li><p>If so, then tell the user that he hasn't successfully logged in</p></li>
<li><p>If no one is using this username, we add username as a key to the connection object.</p></li>
<li><p>If a command is not recognized we send an error.</p></li>
</ul>
<p>The following code is a helper function for sending messages to a connection. Add it to the <i>server.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<p>When the user disconnects we should clean up its connection. We can delete the user when the <i>close</i> event is fired. Add the following code to the <i>connection</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 
   if(connection.name) { 
      delete users[connection.name]; 
   } 
});
</pre>
<p>After successful login the user wants to call another. He should make an <i>offer</i> to another user to achieve it. Add the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "offer": 
   //for ex. UserA wants to call UserB 
   console.log("Sending offer to: ", data.name);
	
   //if UserB exists then send him offer details 
   var conn = users[data.name]; 
	
   if(conn != null) { 
      //setting that UserA connected with UserB 
      connection.otherName = data.name; 
		
      sendTo(conn, { 
         type: "offer",
         offer: data.offer, 
         name: connection.name 
      }); 
		
   }  
	
   break;
</pre>
<p>Firstly, we get the <i>connection</i> of the user we are trying to call. If it exists we send him <i>offer</i> details. We also add <i>otherName</i> to the <i>connection</i> object. This is made for the simplicity of finding it later.</p>
<p>Answering to the response has a similar pattern that we used in the <i>offer</i> handler. Our server just passes through all messages as <i>answer</i> to another user. Add the following code after the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "answer": 
   console.log("Sending answer to: ", data.name); 
	
   //for ex. UserB answers UserA 
   var conn = users[data.name]; 
	
   if(conn != null) { 
      connection.otherName = data.name; 
		
      sendTo(conn, { 
         type: "answer", 
         answer: data.answer 
      }); 
   } 
	
   break;
</pre>
<p>The final part is handling ICE candidate between users. We use the same technique just passing messages between users. The main difference is that candidate messages might happen multiple times per user in any order. Add the <i>candidate</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "candidate": 
   console.log("Sending candidate to:",data.name); 
   var conn = users[data.name];
	
   if(conn != null) { 
      sendTo(conn, { 
         type: "candidate", 
         candidate: data.candidate 
      }); 
   } 
	
   break;
</pre>
<p>To allow our users to disconnect from another user we should implement the hanging up function. It will also tell the server to delete all user references. Add the <i>leave</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "leave": 
   console.log("Disconnecting from", data.name); 
   var conn = users[data.name]; 
   conn.otherName = null; 
	
   //notify the other user so he can disconnect his peer connection 
   if(conn != null) { 
      sendTo(conn, { 
         type: "leave" 
      }); 
   } 
	
   break;
</pre>
<p>This will also send the other user the <i>leave</i> event so he can disconnect his peer connection accordingly. We should also handle the case when a user drops his connection from the signaling server. Let's modify our <i>close</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 

   if(connection.name) { 
      delete users[connection.name]; 
		
      if(connection.otherName) { 
         console.log("Disconnecting from ", connection.otherName); 
         var conn = users[connection.otherName]; 
         conn.otherName = null;  
			
         if(conn != null) { 
            sendTo(conn, { 
               type: "leave" 
            });
         }
			
      } 
   } 
}); 
</pre>
<p>The following is the entire code of our signaling server &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};
  
//when a user connects to our sever 
wss.on('connection', function(connection) {
  
   console.log("User connected");
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) { 
	
      var data; 
		
      //accepting only JSON messages 
      try { 
         data = JSON.parse(message); 
      } catch (e) { 
         console.log("Invalid JSON"); 
         data = {}; 
      }
		
      //switching type of the user message 
      switch (data.type) { 
         //when a user tries to login
         case "login": 
            console.log("User logged", data.name); 
				
            //if anyone is logged in with this username then refuse 
            if(users[data.name]) { 
               sendTo(connection, { 
                  type: "login", 
                  success: false 
               }); 
            } else { 
               //save user connection on the server 
               users[data.name] = connection; 
               connection.name = data.name; 
					
               sendTo(connection, { 
                  type: "login", 
                  success: true 
               }); 
            } 
				
            break;
				
         case "offer": 
            //for ex. UserA wants to call UserB 
            console.log("Sending offer to: ", data.name);
				
            //if UserB exists then send him offer details 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               //setting that UserA connected with UserB 
               connection.otherName = data.name; 
					
               sendTo(conn, { 
                  type: "offer", 
                  offer: data.offer, 
                  name: connection.name 
               }); 
            }
				
            break;
				
         case "answer": 
            console.log("Sending answer to: ", data.name); 
            //for ex. UserB answers UserA 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               connection.otherName = data.name; 
               sendTo(conn, { 
                  type: "answer", 
                  answer: data.answer 
               }); 
            } 
				
            break; 
				
         case "candidate": 
            console.log("Sending candidate to:",data.name); 
            var conn = users[data.name];
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "candidate", 
                  candidate: data.candidate 
               }); 
            } 
				
            break;
				
         case "leave": 
            console.log("Disconnecting from", data.name); 
            var conn = users[data.name]; 
            conn.otherName = null; 
				
            //notify the other user so he can disconnect his peer connection 
            if(conn != null) {
               sendTo(conn, { 
                  type: "leave" 
              }); 
            }
				
            break;
				
         default: 
            sendTo(connection, { 
               type: "error", 
               message: "Command not found: " + data.type 
            }); 
				
            break; 
      }
		
   }); 
	
   //when user exits, for example closes a browser window 
   //this may help if we are still in "offer","answer" or "candidate" state 
   connection.on("close", function() { 
	
      if(connection.name) { 
         delete users[connection.name]; 
			
         if(connection.otherName) { 
            console.log("Disconnecting from ", connection.otherName); 
            var conn = users[connection.otherName]; 
            conn.otherName = null;
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
               }); 
            }
         } 
      }
		
   });  
	
   connection.send("Hello world");  
});
  
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<h2>Client Application</h2>
<p>One way to test this application is opening two browser tabs and trying to call each other.</p>
<p>First of all, we need to install the <i>bootstrap</i> library. Bootstrap is a frontend framework for developing web applications. You can learn more at <a target="_blank" rel="nofollow" href="http://getbootstrap.com/">http://getbootstrap.com/.</a> Create a folder called, for example, “videochat”. This will be our root application folder. Inside this folder create a file <i>package.json</i> (it is necessary for managing npm dependencies) and add the following &minus;</p>
<pre class="prettyprint notranslate">
{ 
   "name": "webrtc-videochat", 
   "version": "0.1.0", 
   "description": "webrtc-videochat", 
   "author": "Author", 
   "license": "BSD-2-Clause" 
}
</pre>
<p>Then run <i>npm install bootstrap</i>. This will install the bootstrap library in the <i>videochat/node_modules</i> folder.</p>
<p>Now we need to create a basic HTML page. Create an <i>index.html</i> file in the root folder with the following code &minus;</p>
<pre class="prettyprint notranslate">
&lt;html&gt; 
 
   &lt;head&gt; 
      &lt;title&gt;WebRTC Video Demo&lt;/title&gt;
      &lt;link rel = "stylesheet" href = "node_modules/bootstrap/dist/css/bootstrap.min.css"/&gt;
   &lt;/head&gt;
	
   &lt;style&gt;
	
      body { 
         background: #eee; 
         padding: 5% 0; 
      } 
		
      video { 
         background: black; 
         border: 1px solid gray; 
      }
		
      .call-page { 
         position: relative; 
         display: block; 
         margin: 0 auto; 
         width: 500px; 
         height: 500px; 
      } 
		
      #localVideo { 
         width: 150px; 
         height: 150px; 
         position: absolute; 
         top: 15px; 
         right: 15px; 
      }
		
      #remoteVideo { 
         width: 500px; 
         height: 500px; 
      }
		
   &lt;/style&gt;
	
   &lt;body&gt;
	
   &lt;div id = "loginPage" class = "container text-center"&gt; 
	
      &lt;div class = "row"&gt; 
         &lt;div class = "col-md-4 col-md-offset-4"&gt;
			
            &lt;h2&gt;WebRTC Video Demo. Please sign in&lt;/h2&gt; 
            &lt;label for = "usernameInput" class = "sr-only"&gt;Login&lt;/label&gt; 
            &lt;input type = "email" id = "usernameInput" c
               lass = "form-control formgroup" placeholder = "Login" 
               required = "" autofocus = ""&gt; 
            &lt;button id = "loginBtn" class = "btn btn-lg btn-primary btnblock"&gt;
               Sign in&lt;/button&gt;
				
         &lt;/div&gt; 
      &lt;/div&gt; 
		
   &lt;/div&gt;
	
   &lt;div id = "callPage" class = "call-page"&gt; 
      &lt;video id = "localVideo" autoplay&gt;&lt;/video&gt; 
      &lt;video id = "remoteVideo" autoplay&gt;&lt;/video&gt;
		
      &lt;div class = "row text-center"&gt; 
         &lt;div class = "col-md-12"&gt; 
            &lt;input id = "callToUsernameInput" type = "text"
               placeholder = "username to call" /&gt; 
            &lt;button id = "callBtn" class = "btn-success btn"&gt;Call&lt;/button&gt; 
            &lt;button id = "hangUpBtn" class = "btn-danger btn"&gt;Hang Up&lt;/button&gt; 
         &lt;/div&gt;	
      &lt;/div&gt; 
		
   &lt;/div&gt;
	
   &lt;script src = "client.js"&gt;&lt;/script&gt; 
	
   &lt;/body&gt;
	
&lt;/html&gt;		  
</pre>
<p>This page should be familiar to you. We have added the <i>bootstrap</i> css file. We have also defined two pages. Finally, we have created several text fields and buttons for getting information from the user. You should see the two video elements for local and remote video streams. Notice that we have added a link to a <i>client.js</i> file.</p>
<p>Now we need to establish a connection with our signaling server. Create the <i>client.js</i> file in the root folder with the following code &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser;
  
//connecting to our signaling server 
var conn = new WebSocket('ws://localhost:9090');
  
conn.onopen = function () { 
   console.log("Connected to the signaling server"); 
};
  
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data);
	
   var data = JSON.parse(msg.data);
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success);
         break; 
      //when somebody wants to call us 
      case "offer": 
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate": 
         handleCandidate(data.candidate); 
         break; 
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   } 
};
  
conn.onerror = function (err) { 
   console.log("Got error", err); 
};
  
//alias for sending JSON encoded messages 
function send(message) { 
   //attach the other peer username to our messages 
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
};
</pre>
<p>Now run our signaling server via <i>node server</i>. Then, inside the root folder run the <i>static</i> command and open the page inside the browser. You should see the following console output &minus;</p>
<img src="/webrtc/images/client_application.jpg" alt="Client Application" />
<p>The next step is implementing a user log in with a unique username. We simply send a username to the server, which then tell us whether it is taken or not. Add the following code to your <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//****** 
//UI selectors block 
//****** 

var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var loginBtn = document.querySelector('#loginBtn'); 

var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput');
var callBtn = document.querySelector('#callBtn'); 

var hangUpBtn = document.querySelector('#hangUpBtn');
  
//hide call page 
callPage.style.display = "none"; 
 
// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value; 
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name 
      }); 
   } 
	
});
 
function handleLogin(success) { 

   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      //display the call page if login is successful 
      loginPage.style.display = "none"; 
      callPage.style.display = "block";  
      //start peer connection 
   } 
};
</pre>
<p>Firstly, we select some references to the elements on the page. The we hide the call page. Then, we add an event listener on the login button. When the user clicks it, we send his username to the server. Finally, we implement the handleLogin callback. If the login was successful, we show the call page and starting to set up a peer connection.</p>
<p>To start a peer connection we need &minus;</p>
<ul class="list">
<li>Obtain a stream from the web camera.</li>
<li>Create the RTCPeerConnection object.</li>
</ul>
<p>Add the following code to the “UI selectors block” &minus;</p>
<pre class="prettyprint notranslate">
var localVideo = document.querySelector('#localVideo'); 
var remoteVideo = document.querySelector('#remoteVideo');
 
var yourConn; 
var stream;
</pre>
<p>Modify the <i>handleLogin</i> function &minus;</p>
<pre class="prettyprint notranslate">
function handleLogin(success) { 

   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block";
		  
      //********************** 
      //Starting a peer connection 
      //********************** 
		
      //getting local video stream 
      navigator.webkitGetUserMedia({ video: true, audio: true }, function (myStream) { 
         stream = myStream; 
			
         //displaying local video stream on the page 
         localVideo.src = window.URL.createObjectURL(stream);
			
         //using Google public stun server 
         var configuration = { 
            "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }] 
         }; 
			
         yourConn = new webkitRTCPeerConnection(configuration);
			
         // setup stream listening 
         yourConn.addStream(stream); 
			
         //when a remote user adds stream to the peer connection, we display it 
         yourConn.onaddstream = function (e) { 
            remoteVideo.src = window.URL.createObjectURL(e.stream); 
         };
			
         // Setup ice handling 
         yourConn.onicecandidate = function (event) {
			
            if (event.candidate) { 
               send({ 
                  type: "candidate", 
                  candidate: event.candidate 
               }); 
            } 
				
         };
			
      }, function (error) { 
         console.log(error); 
      }); 
   } 
};
</pre>
<p>Now if you run the code, the page should allow you to log in and display your local video stream on the page.</p>
<img src="/webrtc/images/allow_log_in.jpg" alt="Local Video Stream" />
<p>Now we are ready to initiate a call. Firstly, we send an <i>offer</i> to another user. Once a user gets the offer, he creates an <i>answer</i> and start trading ICE candidates. Add the following code to the <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//initiating a call 
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value; 
	
   if (callToUsername.length &gt; 0) {
	
      connectedUser = callToUsername;
		
      // create an offer
      yourConn.createOffer(function (offer) { 
         send({ 
            type: "offer", 
            offer: offer 
         }); 
			
         yourConn.setLocalDescription(offer); 
			
      }, function (error) { 
         alert("Error when creating an offer"); 
      });  
   } 
});
  
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer));
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
		
      send({ 
         type: "answer", 
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("Error when creating an answer"); 
   }); 
};
  
//when we got an answer from a remote user 
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer));
}; 
 
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
</pre>
<p>We add a <i>click</i> handler to the Call button, which initiates an offer. Then we implement several handlers expected by the <i>onmessage</i> handler. They will be processed asynchronously until both the users have made a connection.</p>
<p>The last step is implementing the hang-up feature. This will stop transmitting data and tell the other user to close the call. Add the following code &minus;</p>
<pre class="prettyprint notranslate">
//hang up 
hangUpBtn.addEventListener("click", function () { 

   send({ 
      type: "leave" 
   });
	
   handleLeave(); 
});
  
function handleLeave() { 
   connectedUser = null; 
   remoteVideo.src = null; 
	
   yourConn.close(); 
   yourConn.onicecandidate = null; 
   yourConn.onaddstream = null; 
};
</pre>
<p>When the user clicks on the Hang Up button &minus;</p>
<ul class="list">
<li>It will send a “leave” message to the other user</li>
<li>It will close the RTCPeerConnection and destroy the connection locally</li>
</ul>
<p>Now run the code. You should be able to log in to the server using two browser tabs. You can then call the tab and hang up the call.</p>
<img src="/webrtc/images/call_and_hang_up.jpg" alt="call and hang up" />
<p>The following is the entire <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser;
  
//connecting to our signaling server
var conn = new WebSocket('ws://localhost:9090');
  
conn.onopen = function () { 
   console.log("Connected to the signaling server"); 
};
  
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data);
	
   var data = JSON.parse(msg.data); 
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success); 
         break; 
      //when somebody wants to call us 
      case "offer": 
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate": 
         handleCandidate(data.candidate); 
         break; 
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   }
};
  
conn.onerror = function (err) { 
   console.log("Got error", err); 
};
  
//alias for sending JSON encoded messages 
function send(message) { 
   //attach the other peer username to our messages 
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
};
  
//****** 
//UI selectors block 
//******
 
var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var loginBtn = document.querySelector('#loginBtn'); 

var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput');
var callBtn = document.querySelector('#callBtn'); 

var hangUpBtn = document.querySelector('#hangUpBtn');
  
var localVideo = document.querySelector('#localVideo'); 
var remoteVideo = document.querySelector('#remoteVideo'); 

var yourConn; 
var stream;
  
callPage.style.display = "none";

// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value;
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name 
      }); 
   }
	
});
  
function handleLogin(success) { 
   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block";
		
      //********************** 
      //Starting a peer connection 
      //********************** 
		
      //getting local video stream 
      navigator.webkitGetUserMedia({ video: true, audio: true }, function (myStream) { 
         stream = myStream; 
			
         //displaying local video stream on the page 
         localVideo.src = window.URL.createObjectURL(stream);
			
         //using Google public stun server 
         var configuration = { 
            "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }]
         }; 
			
         yourConn = new webkitRTCPeerConnection(configuration); 
			
         // setup stream listening 
         yourConn.addStream(stream); 
			
         //when a remote user adds stream to the peer connection, we display it 
         yourConn.onaddstream = function (e) { 
            remoteVideo.src = window.URL.createObjectURL(e.stream); 
         };
			
         // Setup ice handling 
         yourConn.onicecandidate = function (event) { 
            if (event.candidate) { 
               send({ 
                  type: "candidate", 
                  candidate: event.candidate 
               }); 
            } 
         };  
			
      }, function (error) { 
         console.log(error); 
      }); 
		
   } 
};
  
//initiating a call 
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value;
	
   if (callToUsername.length &gt; 0) { 
	
      connectedUser = callToUsername;
		
      // create an offer 
      yourConn.createOffer(function (offer) { 
         send({ 
            type: "offer", 
            offer: offer 
         }); 
			
         yourConn.setLocalDescription(offer); 
      }, function (error) { 
         alert("Error when creating an offer"); 
      });
		
   } 
});
  
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer));
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
		
      send({ 
         type: "answer", 
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("Error when creating an answer"); 
   }); 
};
  
//when we got an answer from a remote user
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); 
};
  
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
   
//hang up 
hangUpBtn.addEventListener("click", function () { 

   send({ 
      type: "leave" 
   });  
	
   handleLeave(); 
});
  
function handleLeave() { 
   connectedUser = null; 
   remoteVideo.src = null; 
	
   yourConn.close(); 
   yourConn.onicecandidate = null; 
   yourConn.onaddstream = null; 
};
</pre>
<h2>Summary</h2>
<p>This demo provides a baseline of features that every WebRTC application needs. To improve this demo you can add user identification through platforms like Facebook or Google, handle user input for invalid data. Also, the WebRTC connection can fail because of several reasons like not supporting the technology or not being able to traverse firewalls. A worth of work has gone into making any WebRTC application stable.</p>
<h1>WebRTC - Voice Demo</h1>
<p>In this chapter, we are going to build a client application that allows two users on separate devices to communicate using WebRTC audio streams. Our application will have two pages. One for login and the other for making an audio call to another user.</p>
<img src="/webrtc/images/login_and_audio_call_page.jpg" alt="Login and Audio call Page." />
<p>The two pages will be the <i>div</i> tags. Most input is done through simple event handlers.</p>
<h2>Signaling Server</h2>
<p>To create a WebRTC connection clients have to be able to transfer messages without using a WebRTC peer connection. This is where we will use HTML5 WebSockets &minus; a bidirectional socket connection between two endpoints &minus; a web server and a web browser. Now let's start using the WebSocket library. Create the <i>server.js</i> file and insert the following code &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090});
  
//when a user connects to our sever 
wss.on('connection', function(connection) { 
   console.log("user connected"); 
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) { 
      console.log("Got message from a user:", message); 
   }); 
	
   connection.send("Hello from server"); 
});
</pre>
<p>The first line requires the WebSocket library which we have already installed. Then we create a socket server on the port 9090. Next, we listen to the <i>connection</i> event. This code will be executed when a user makes a WebSocket connection to the server. We then listen to any messages sent by the user. Finally, we send a response to the connected user saying “Hello from server”.</p>
<p>In our signaling server, we will use a string-based username for each connection so we know where to send messages. Let's change our <i>connection</i> handler a bit &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) { 
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON");
      data = {}; 
   } 
});
</pre>
<p>This way we accept only JSON messages. Next, we need to store all connected users somewhere. We will use a simple Javascript object for it. Change the top of our file &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};
</pre>
<p>We are going to add a <i>type</i> field for every message coming from the client. For example if a user wants to login, he sends the <i>login</i> type message. Let's define it &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) {
  
   var data; 
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON"); 
      data = {}; 
   } 
	
   //switching type of the user message 
   switch (data.type) { 
      //when a user tries to login 
      case "login": 
         console.log("User logged:", data.name); 
			
         //if anyone is logged in with this username then refuse 
         if(users[data.name]) { 
            sendTo(connection, { 
               type: "login",
               success: false 
            }); 
         } else { 
            //save user connection on the server 
            users[data.name] = connection; 
            connection.name = data.name; 
				
            sendTo(connection, { 
               type: "login", 
               success: true 
            }); 
         } 
			
         break;
			
      default: 
         sendTo(connection, { 
            type: "error", 
            message: "Command no found: " + data.type 
         }); 
			
         break; 
   }  
});
</pre>
<p>If the user sends a message with the <i>login</i> type, we &minus;</p>
<ul class="list">
<li>Check if anyone has already logged in with this username.</li>
<li>If so, then tell the user that he hasn't successfully logged in.</li>
<li>If no one is using this username, we add username as a key to the connection object.</li>
<li>If a command is not recognized we send an error.</li>
</ul>
<p>The following code is a helper function for sending messages to a connection. Add it to the <i>server.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<p>When the user disconnects we should clean up its connection. We can delete the user when the <i>close</i> event is fired. Add the following code to the <i>connection</i> handler&minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 
   if(connection.name) { 
      delete users[connection.name]; 
   } 
});
</pre>
<p>After successful login the user wants to call another. He should make an <i>offer</i> to another user to achieve it. Add the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "offer": 
   //for ex. UserA wants to call UserB 
   console.log("Sending offer to: ", data.name); 
	
   //if UserB exists then send him offer details 
   var conn = users[data.name]; 
	
   if(conn != null) { 
      //setting that UserA connected with UserB 
      connection.otherName = data.name; 
      sendTo(conn, { 
         type: "offer", 
         offer: data.offer, 
         name: connection.name 
      });
   }		
	
   break;
</pre>
<p>Firstly, we get the <i>connection</i> of the user we are trying to call. If it exists we send him <i>offer</i> details. We also add <i>otherName</i> to the <i>connection</i> object. This is made for the simplicity of finding it later.</p>
<p>Answering to the response has a similar pattern that we used in the <i>offer</i> handler. Our server just passes through all messages as <i>answer</i> to another user. Add the following code after the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "answer": 
   console.log("Sending answer to: ", data.name); 
   //for ex. UserB answers UserA
   var conn = users[data.name]; 
	
   if(conn != null) { 
      connection.otherName = data.name;
		
      sendTo(conn, { 
         type: "answer", 
         answer: data.answer 
      }); 
   } 
	
   break;
</pre>
<p>The final part is handling ICE candidate between users. We use the same technique just passing messages between users. The main difference is that candidate messages might happen multiple times per user in any order. Add the <i>candidate</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "candidate": 
   console.log("Sending candidate to:",data.name); 
   var conn = users[data.name];
	
   if(conn != null) { 
      sendTo(conn, { 
         type: "candidate", 
         candidate: data.candidate 
      }); 
   } 
	
   break;
</pre>
<p>To allow our users to disconnect from another user we should implement the hanging up function. It will also tell the server to delete all user references. Add the <i>leave</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "leave": 
   console.log("Disconnecting from", data.name); 
   var conn = users[data.name]; 
   conn.otherName = null; 
	
   //notify the other user so he can disconnect his peer connection 
   if(conn != null) { 
      sendTo(conn, {
         type: "leave" 
      }); 
   }  
	
   break;
</pre>
<p>This will also send the other user the <i>leave</i> event so he can disconnect his peer connection accordingly. We should also handle the case when a user drops his connection from the signaling server. Let's modify our <i>close</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 

   if(connection.name) { 
      delete users[connection.name]; 
		
      if(connection.otherName) { 
         console.log("Disconnecting from ", connection.otherName); 
         var conn = users[connection.otherName]; 
         conn.otherName = null;
			
         if(conn != null) { 
            sendTo(conn, { 
               type: "leave" 
            }); 
         }
			
      } 
   } 
});
</pre>
<p>The following is the entire code of our signaling server &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};

//when a user connects to our sever 
wss.on('connection', function(connection) {
  
   console.log("User connected");
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) { 
	
      var data;
		
      //accepting only JSON messages 
      try { 
         data = JSON.parse(message); 
      } catch (e) { 
         console.log("Invalid JSON"); 
         data = {}; 
      }
		
      //switching type of the user message 
      switch (data.type) { 
         //when a user tries to login 
         case "login": 
            console.log("User logged", data.name); 
				
            //if anyone is logged in with this username then refuse 
            if(users[data.name]) { 
               sendTo(connection, { 
                  type: "login", 
                  success: false 
               }); 
            } else { 
               //save user connection on the server 
               users[data.name] = connection; 
               connection.name = data.name;
               sendTo(connection, { 
                  type: "login", 
                  success: true 
               }); 
            } 
				
            break;
				
         case "offer": 
            //for ex. UserA wants to call UserB 
            console.log("Sending offer to: ", data.name); 
				
            //if UserB exists then send him offer details 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               //setting that UserA connected with UserB 
               connection.otherName = data.name; 
               sendTo(conn, { 
                  type: "offer", 
                  offer: data.offer, 
                  name: connection.name 
               }); 
            } 
				
            break;
				
         case "answer": 
            console.log("Sending answer to: ", data.name); 
            //for ex. UserB answers UserA 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               connection.otherName = data.name; 
               sendTo(conn, { 
                  type: "answer", 
                  answer: data.answer 
               });
            } 
				
            break;
				
         case "candidate": 
            console.log("Sending candidate to:",data.name); 
            var conn = users[data.name];  
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "candidate", 
                  candidate: data.candidate 
               }); 
            } 
				
            break;
				
         case "leave": 
            console.log("Disconnecting from", data.name); 
            var conn = users[data.name]; 
            conn.otherName = null; 
				
            //notify the other user so he can disconnect his peer connection 
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
               }); 
            }  
				
            break;
				
         default: 
            sendTo(connection, { 
               type: "error", 
               message: "Command not found: " + data.type 
            });
				
            break; 
      }  
   });
	
   //when user exits, for example closes a browser window 
   //this may help if we are still in "offer","answer" or "candidate" state 
   connection.on("close", function() { 
	
      if(connection.name) { 
         delete users[connection.name]; 
			
         if(connection.otherName) { 
            console.log("Disconnecting from ", connection.otherName); 
            var conn = users[connection.otherName]; 
            conn.otherName = null;  
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
              }); 
            }  
         } 
      } 
   });  
	
   connection.send("Hello world"); 
}); 
 
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<h2>Client Application</h2>
<p>One way to test this application is opening two browser tabs and trying to make an audio call to each other.</p>
<p>First of all, we need to install the <i>bootstrap</i> library. Bootstrap is a frontend framework for developing web applications. You can learn more at <a target="_blank" rel="nofollow" href="http://getbootstrap.com/">http://getbootstrap.com/.</a> Create a folder called, for example, “audiochat”. This will be our root application folder. Inside this folder create a file <i>package.json</i> (it is necessary for managing npm dependencies) and add the following &minus;</p>
<pre class="prettyprint notranslate">
{ 
   "name": "webrtc-audiochat", 
   "version": "0.1.0", 
   "description": "webrtc-audiochat", 
   "author": "Author", 
   "license": "BSD-2-Clause" 
}
</pre>
<p>Then run <i>npm install bootstrap</i>. This will install the bootstrap library in the <i>audiochat/node_modules</i> folder.</p>
<p>Now we need to create a basic HTML page. Create an <i>index.html</i> file in the root folder with the following code &minus;</p>
<pre class="prettyprint notranslate">
&lt;html&gt;
 
   &lt;head&gt; 
      &lt;title&gt;WebRTC Voice Demo&lt;/title&gt; 
      &lt;link rel = "stylesheet" href = "node_modules/bootstrap/dist/css/bootstrap.min.css"/&gt; 
   &lt;/head&gt;
 
   &lt;style&gt; 
      body { 
         background: #eee; 
         padding: 5% 0; 
      } 
   &lt;/style&gt;
	
   &lt;body&gt; 
      &lt;div id = "loginPage" class = "container text-center"&gt; 
		
         &lt;div class = "row"&gt; 
            &lt;div class = "col-md-4 col-md-offset-4"&gt;
				
               &lt;h2&gt;WebRTC Voice Demo. Please sign in&lt;/h2&gt;
				
               &lt;label for = "usernameInput" class = "sr-only"&gt;Login&lt;/label&gt; 
               &lt;input type = "email" id = "usernameInput" 
                  class = "form-control formgroup"
                  placeholder = "Login" required = "" autofocus = ""&gt; 
               &lt;button id = "loginBtn" class = "btn btn-lg btn-primary btnblock"&gt;
                  Sign in&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt; 
			
      &lt;/div&gt;
		
      &lt;div id = "callPage" class = "call-page"&gt;
		
         &lt;div class = "row"&gt; 
			
            &lt;div class = "col-md-6 text-right"&gt; 
               Local audio: &lt;audio id = "localAudio" 
               controls autoplay&gt;&lt;/audio&gt; 
            &lt;/div&gt;
				
            &lt;div class = "col-md-6 text-left"&gt; 
               Remote audio: &lt;audio id = "remoteAudio" 
                  controls autoplay&gt;&lt;/audio&gt; 
            &lt;/div&gt; 
				
         &lt;/div&gt; 
			
         &lt;div class = "row text-center"&gt; 
            &lt;div class = "col-md-12"&gt; 
               &lt;input id = "callToUsernameInput" 
                  type = "text" placeholder = "username to call" /&gt; 
               &lt;button id = "callBtn" class = "btn-success btn"&gt;Call&lt;/button&gt; 
               &lt;button id = "hangUpBtn" class = "btn-danger btn"&gt;Hang Up&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt;
			
      &lt;/div&gt; 
		
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
		
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>This page should be familiar to you. We have added the <i>bootstrap</i> css file. We have also defined two pages. Finally, we have created several text fields and buttons for getting information from the user. You should see the two audio elements for local and remote audio streams. Notice that we have added a link to a <i>client.js</i> file.</p>
<p>Now we need to establish a connection with our signaling server. Create the <i>client.js</i> file in the root folder with the following code &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser;
  
//connecting to our signaling server 
var conn = new WebSocket('ws://localhost:9090');
  
conn.onopen = function () { 
   console.log("Connected to the signaling server"); 
}; 
 
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data);  
   var data = JSON.parse(msg.data);  
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success); 
         break; 
      //when somebody wants to call us 
      case "offer": 
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate": 
         handleCandidate(data.candidate); 
         break;
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   } 
};
  
conn.onerror = function (err) { 
   console.log("Got error", err); 
};
  
//alias for sending JSON encoded messages 
function send(message) { 
   //attach the other peer username to our messages
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
};
</pre>
<p>Now run our signaling server via <i>node server</i>. Then, inside the root folder run the <i>static</i> command and open the page inside the browser. You should see the following console output &minus;</p>
<img src="/webrtc/images/run_signalling_server.jpg" alt="Run Signaling Server" />
<p>The next step is implementing a user log in with a unique username. We simply send a username to the server, which then tell us whether it is taken or not. Add the following code to your <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//****** 
//UI selectors block 
//******

var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var loginBtn = document.querySelector('#loginBtn');
 
var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput');
var callBtn = document.querySelector('#callBtn');
 
var hangUpBtn = document.querySelector('#hangUpBtn');
  
callPage.style.display = "none";
  
// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value;
	
   if (name.length &gt; 0) { 
      send({
         type: "login", 
         name: name 
      }); 
   } 
	
}); 
 
function handleLogin(success) { 
   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block"; 
		
      //********************** 
      //Starting a peer connection 
      //**********************
		         
   } 
	
};
</pre>
<p>Firstly, we select some references to the elements on the page. The we hide the call page. Then, we add an event listener on the login button. When the user clicks it, we send his username to the server. Finally, we implement the handleLogin callback. If the login was successful, we show the call page and starting to set up a peer connection.</p>
<p>To start a peer connection we need &minus;</p>
<ul class="list">
<li>Obtain an audio stream from a microphone</li>
<li>Create the RTCPeerConnection object</li>
</ul>
<p>Add the following code to the “UI selectors block” &minus;</p>
<pre class="prettyprint notranslate">
var localAudio = document.querySelector('#localAudio'); 
var remoteAudio = document.querySelector('#remoteAudio'); 

var yourConn; 
var stream;
</pre>
<p>Modify the <i>handleLogin</i> function &minus;</p>
<pre class="prettyprint notranslate">
function handleLogin(success) { 
   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block";
		
      //********************** 
      //Starting a peer connection 
      //********************** 
		
      //getting local audio stream 
      navigator.webkitGetUserMedia({ video: false, audio: true }, function (myStream) { 
         stream = myStream; 
			
         //displaying local audio stream on the page
         localAudio.src = window.URL.createObjectURL(stream);
			
         //using Google public stun server 
         var configuration = { 
            "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }] 
         }; 
			
         yourConn = new webkitRTCPeerConnection(configuration); 
			
         // setup stream listening 
         yourConn.addStream(stream); 
			
         //when a remote user adds stream to the peer connection, we display it 
         yourConn.onaddstream = function (e) { 
            remoteAudio.src = window.URL.createObjectURL(e.stream); 
         }; 
			
         // Setup ice handling 
         yourConn.onicecandidate = function (event) { 
            if (event.candidate) { 
               send({ 
                  type: "candidate", 
               }); 
            } 
         };  
			
      }, function (error) { 
         console.log(error); 
      }); 
		
   } 
};
</pre>
<p>Now if you run the code, the page should allow you to log in and display your local audio stream on the page.</p>
<img src="/webrtc/images/local_audio_stream.jpg" alt="Allow to log in" />
<p>Now we are ready to initiate a call. Firstly, we send an <i>offer</i> to another user. Once a user gets the offer, he creates an <i>answer</i> and start trading ICE candidates. Add the following code to the <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//initiating a call 
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value; 
	
   if (callToUsername.length &gt; 0) { 
      connectedUser = callToUsername; 
		
      // create an offer 
      yourConn.createOffer(function (offer) { 
         send({ 
            type: "offer", 
            offer: offer 
         }); 
			
         yourConn.setLocalDescription(offer); 
			
      }, function (error) { 
         alert("Error when creating an offer"); 
      }); 
   } 
	
});
 
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer)); 
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
		
      send({ 
         type: "answer",
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("Error when creating an answer"); 
   }); 
	
};
 
//when we got an answer from a remote user 
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); 
};
 
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
</pre>
<p>We add a <i>click</i> handler to the Call button, which initiates an offer. Then we implement several handlers expected by the <i>onmessage</i> handler. They will be processed asynchronously until both the users have made a connection.</p>
<p>The last step is implementing the hang-up feature. This will stop transmitting data and tell the other user to close the call. Add the following code &minus;</p>
<pre class="prettyprint notranslate">
//hang up 
hangUpBtn.addEventListener("click", function () { 
   send({ 
      type: "leave" 
   });  
	
   handleLeave(); 
});
  
function handleLeave() { 
   connectedUser = null; 
   remoteAudio.src = null;
	
   yourConn.close(); 
   yourConn.onicecandidate = null; 
   yourConn.onaddstream = null;
};
</pre>
<p>When the user clicks on the Hang Up button &minus;</p>
<ul class="list">
<li>It will send a “leave” message to the other user</li>
<li>It will close the RTCPeerConnection and destroy the connection locally</li>
</ul>
<p>Now run the code. You should be able to log in to the server using two browser tabs. You can then make an audio call to the tab and hang up the call.</p>
<img src="/webrtc/images/login_to_the_server.jpg" alt="Login Page" />
<img src="/webrtc/images/voice_call_and_hang_up.jpg" alt="Call and Hang up page" />
<p>The following is the entire <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser;
 
//connecting to our signaling server 
var conn = new WebSocket('ws://localhost:9090');
 
conn.onopen = function () { 
   console.log("Connected to the signaling server"); 
};
 
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data); 
   var data = JSON.parse(msg.data); 
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success); 
         break; 
      //when somebody wants to call us 
      case "offer": 
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate": 
         handleCandidate(data.candidate); 
         break; 
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   } 
}; 

conn.onerror = function (err) { 
   console.log("Got error", err); 
};
 
//alias for sending JSON encoded messages 
function send(message) { 
   //attach the other peer username to our messages 
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
};
 
//****** 
//UI selectors block 
//****** 

var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var loginBtn = document.querySelector('#loginBtn');

var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput');
var callBtn = document.querySelector('#callBtn'); 

var hangUpBtn = document.querySelector('#hangUpBtn'); 
var localAudio = document.querySelector('#localAudio'); 
var remoteAudio = document.querySelector('#remoteAudio'); 

var yourConn; 
var stream; 

callPage.style.display = "none";
 
// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value; 
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name 
      }); 
   } 
	
});
 
function handleLogin(success) { 
   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block"; 
		
      //********************** 
      //Starting a peer connection 
      //********************** 
		
      //getting local audio stream 
      navigator.webkitGetUserMedia({ video: false, audio: true }, function (myStream) { 
         stream = myStream; 
			
         //displaying local audio stream on the page 
         localAudio.src = window.URL.createObjectURL(stream);
			
         //using Google public stun server 
         var configuration = { 
            "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }] 
         }; 
			
         yourConn = new webkitRTCPeerConnection(configuration); 
			
         // setup stream listening 
         yourConn.addStream(stream); 
			
         //when a remote user adds stream to the peer connection, we display it 
         yourConn.onaddstream = function (e) { 
            remoteAudio.src = window.URL.createObjectURL(e.stream); 
         }; 
			
         // Setup ice handling 
         yourConn.onicecandidate = function (event) { 
            if (event.candidate) { 
               send({ 
                  type: "candidate", 
                  candidate: event.candidate 
               }); 
            } 
         }; 
			
      }, function (error) { 
         console.log(error); 
      }); 
		
   } 
};
 
//initiating a call 
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value; 
	
   if (callToUsername.length &gt; 0) { 
      connectedUser = callToUsername; 
		
      // create an offer 
      yourConn.createOffer(function (offer) { 
         send({
            type: "offer", 
            offer: offer 
         }); 
			
         yourConn.setLocalDescription(offer); 
      }, function (error) { 
         alert("Error when creating an offer"); 
      }); 
   } 
});
 
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer)); 
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
		
      send({ 
         type: "answer", 
         answer: answer 
      });
		
   }, function (error) { 
      alert("Error when creating an answer"); 
   }); 
	
};
 
//when we got an answer from a remote user 
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); 
};
 
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
 
//hang up
hangUpBtn.addEventListener("click", function () { 
   send({ 
      type: "leave" 
   }); 
	
   handleLeave(); 
});
 
function handleLeave() { 
   connectedUser = null; 
   remoteAudio.src = null; 
	
   yourConn.close(); 
   yourConn.onicecandidate = null; 
   yourConn.onaddstream = null; 
};
</pre>
<h1>WebRTC - Text Demo</h1>
<p>In this chapter, we are going to build a client application that allows two users on separate devices to send messages each other using WebRTC. Our application will have two pages. One for login and the other for sending messages to another user.</p>
<img src="/webrtc/images/text_demo.jpg" alt="Login and send message page" />
<p>The two pages will be the <i>div</i> tags. Most input is done through simple event handlers.</p>
<h2>Signaling Server</h2>
<p>To create a WebRTC connection clients have to be able to transfer messages without using a WebRTC peer connection. This is where we will use HTML5 WebSockets &minus; a bidirectional socket connection between two endpoints &minus; a web server and a web browser. Now let's start using the WebSocket library. Create the <i>server.js</i> file and insert the following code &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090});
  
//when a user connects to our sever 
wss.on('connection', function(connection) { 
   console.log("user connected"); 
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) { 
      console.log("Got message from a user:", message); 
   }); 
	
   connection.send("Hello from server"); 
});
</pre>
<p>The first line requires the WebSocket library which we have already installed. Then we create a socket server on the port 9090. Next, we listen to the <i>connection</i> event. This code will be executed when a user makes a WebSocket connection to the server. We then listen to any messages sent by the user. Finally, we send a response to the connected user saying “Hello from server”.</p>
<p>In our signaling server, we will use a string-based username for each connection so we know where to send messages. Let's change our <i>connection</i> handler a bit &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) { 
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON");
      data = {}; 
   } 
});
</pre>
<p>This way we accept only JSON messages. Next, we need to store all connected users somewhere. We will use a simple Javascript object for it. Change the top of our file &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};
</pre>
<p>We are going to add a <i>type</i> field for every message coming from the client. For example if a user wants to login, he sends the <i>login</i> type message. Let's define it &minus;</p>
<pre class="prettyprint notranslate">
connection.on('message', function(message) { 
   var data; 
	
   //accepting only JSON messages 
   try { 
      data = JSON.parse(message); 
   } catch (e) { 
      console.log("Invalid JSON"); 
      data = {}; 
   }
	
   //switching type of the user message 
   switch (data.type) { 
      //when a user tries to login 
      case "login": 
         console.log("User logged:", data.name); 
			
         //if anyone is logged in with this username then refuse 
         if(users[data.name]) { 
            sendTo(connection, { 
               type: "login", 
               success: false
            }); 
         } else { 
            //save user connection on the server 
            users[data.name] = connection; 
            connection.name = data.name; 
				
            sendTo(connection, { 
               type: "login", 
               success: true 
            }); 
         } 
			
         break;
			
      default: 
         sendTo(connection, { 
            type: "error", 
            message: "Command no found: " + data.type 
         }); 
			
         break;
   } 
});
</pre>
<p>If the user sends a message with the <i>login</i> type, we &minus;</p>
<ul class="list">
<li>Check if anyone has already logged in with this username.</li>
<li>If so, then tell the user that he hasn't successfully logged in.</li>
<li>If no one is using this username, we add username as a key to the connection object.</li>
<li>If a command is not recognized we send an error.</li>
</ul>
<p>The following code is a helper function for sending messages to a connection. Add it to the <i>server.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<p>When the user disconnects we should clean up its connection. We can delete the user when the <i>close</i> event is fired. Add the following code to the <i>connection</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 
   if(connection.name) { 
      delete users[connection.name]; 
   } 
});
</pre>
<p>After successful login the user wants to call another. He should make an <i>offer</i> to another user to achieve it. Add the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "offer": 
   //for ex. UserA wants to call UserB 
   console.log("Sending offer to: ", data.name); 
	
   //if UserB exists then send him offer details 
   var conn = users[data.name]; 
	
   if(conn != null){ 
   //setting that UserA connected with UserB 
   connection.otherName = data.name; 
	
      sendTo(conn, { 
         type: "offer", 
         offer: data.offer, 
         name: connection.name 
      }); 
     
   break;
</pre>
<p>Firstly, we get the <i>connection</i> of the user we are trying to call. If it exists we send him <i>offer</i> details. We also add <i>otherName</i> to the <i>connection</i> object. This is made for the simplicity of finding it later.</p>
<p>Answering to the response has a similar pattern that we used in the <i>offer</i> handler. Our server just passes through all messages as <i>answer</i> to another user. Add the following code after the <i>offer</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "answer": 
   console.log("Sending answer to: ", data.name); 
	
   //for ex. UserB answers UserA 
   var conn = users[data.name]; 
	
   if(conn != null) { 
      connection.otherName = data.name;
      sendTo(conn, { 
         type: "answer", 
         answer: data.answer 
      }); 
   } 
	
   break;
</pre>
<p>The final part is handling ICE candidate between users. We use the same technique just passing messages between users. The main difference is that candidate messages might happen multiple times per user in any order. Add the <i>candidate</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "candidate": 
   console.log("Sending candidate to:",data.name); 
   var conn = users[data.name];
	
   if(conn != null) { 
      sendTo(conn, { 
         type: "candidate", 
         candidate: data.candidate 
      }); 
   } 
	
   break;
</pre>
<p>To allow our users to disconnect from another user we should implement the hanging up function. It will also tell the server to delete all user references. Add the <i>leave</i> handler &minus;</p>
<pre class="prettyprint notranslate">
case "leave": 
   console.log("Disconnecting from", data.name); 
   var conn = users[data.name]; 
   conn.otherName = null;
	
   //notify the other user so he can disconnect his peer connection 
   if(conn != null) { 
      sendTo(conn, { 
         type: "leave" 
      }); 
   }
	
   break; 
</pre>
<p>This will also send the other user the <i>leave</i> event so he can disconnect his peer connection accordingly. We should also handle the case when a user drops his connection from the signaling server. Let's modify our <i>close</i> handler &minus;</p>
<pre class="prettyprint notranslate">
connection.on("close", function() { 

   if(connection.name) { 
      delete users[connection.name]; 
		
      if(connection.otherName) { 
         console.log("Disconnecting from ", connection.otherName); 
         var conn = users[connection.otherName]; 
         conn.otherName = null;  
			
         if(conn != null) { 
            sendTo(conn, { 
               type: "leave" 
            }); 
         }  
      } 
   } 
});
</pre>
<p>The following is the entire code of our signaling server &minus;</p>
<pre class="prettyprint notranslate">
//require our websocket library 
var WebSocketServer = require('ws').Server;
 
//creating a websocket server at port 9090 
var wss = new WebSocketServer({port: 9090}); 

//all connected to the server users 
var users = {};
  
//when a user connects to our sever 
wss.on('connection', function(connection) {
  
   console.log("User connected");
	 
   //when server gets a message from a connected user 
   connection.on('message', function(message) {
	 
      var data; 
      //accepting only JSON messages 
      try { 
         data = JSON.parse(message); 
      } catch (e) { 
         console.log("Invalid JSON"); 
         data = {}; 
      }
		  
      //switching type of the user message 
      switch (data.type) { 
         //when a user tries to login 
         case "login": 
            console.log("User logged", data.name); 
            //if anyone is logged in with this username then refuse 
            if(users[data.name]) { 
               sendTo(connection, { 
                  type: "login", 
                  success: false 
               }); 
            } else { 
               //save user connection on the server 
               users[data.name] = connection; 
               connection.name = data.name; 
					
                  sendTo(connection, { 
                     type: "login", 
                     success: true 
                  }); 
            }
				
            break;
				
         case "offer": 
            //for ex. UserA wants to call UserB 
            console.log("Sending offer to: ", data.name); 
				
            //if UserB exists then send him offer details 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               //setting that UserA connected with UserB 
               connection.otherName = data.name; 
					
               sendTo(conn, { 
                  type: "offer", 
                  offer: data.offer, 
                  name: connection.name 
               }); 
            } 
				
            break;
				
         case "answer": 
            console.log("Sending answer to: ", data.name); 
            //for ex. UserB answers UserA 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               connection.otherName = data.name; 
               sendTo(conn, { 
                  type: "answer", 
                  answer: data.answer 
               }); 
            } 
				
            break;
				
         case "candidate": 
            console.log("Sending candidate to:",data.name);
            var conn = users[data.name];  
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "candidate", 
                  candidate: data.candidate 
               }); 
            } 
				
            break;
				
         case "leave": 
            console.log("Disconnecting from", data.name); 
            var conn = users[data.name]; 
            conn.otherName = null; 
				
            //notify the other user so he can disconnect his peer connection 
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave"
               });
            }  
				
            break;
				
         default: 
            sendTo(connection, { 
               type: "error", 
               message: "Command not found: " + data.type 
            }); 
				
            break;
				
      }  
   });
	
   //when user exits, for example closes a browser window 
   //this may help if we are still in "offer","answer" or "candidate" state 
   connection.on("close", function() { 
	
      if(connection.name) { 
         delete users[connection.name]; 
			
         if(connection.otherName) { 
            console.log("Disconnecting from ", connection.otherName); 
            var conn = users[connection.otherName]; 
            conn.otherName = null;
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
               }); 
            }  
         } 
      } 
   });
	
   connection.send("Hello world");
	
});
  
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<h2>Client Application</h2>
<p>One way to test this application is opening two browser tabs and trying to send a message each other.</p>
<p>First of all, we need to install the <i>bootstrap</i> library. Bootstrap is a frontend framework for developing web applications. You can learn more at <a target="_blank" rel="nofollow" href="http://getbootstrap.com/">http://getbootstrap.com/.</a>Create a folder called, for example, “textchat”. This will be our root application folder. Inside this folder create a file <i>package.json</i> (it is necessary for managing npm dependencies) and add the following &minus;</p>
<pre class="prettyprint notranslate">
{ 
   "name": "webrtc-textochat", 
   "version": "0.1.0", 
   "description": "webrtc-textchat", 
   "author": "Author", 
   "license": "BSD-2-Clause" 
}
</pre>
<p>Then run <i>npm install bootstrap</i>. This will install the bootstrap library in the <i>textchat/node_modules</i> folder.</p>
<p>Now we need to create a basic HTML page. Create an <i>index.html</i> file in the root folder with the following code &minus;</p>
<pre class="prettyprint notranslate">
&lt;html&gt; 

   &lt;head&gt; 
      &lt;title&gt;WebRTC Text Demo&lt;/title&gt; 
      &lt;link rel = "stylesheet" href = "node_modules/bootstrap/dist/css/bootstrap.min.css"/&gt; 
   &lt;/head&gt;
 
   &lt;style&gt; 
      body { 
         background: #eee; 
         padding: 5% 0; 
      } 
   &lt;/style&gt;
	
   &lt;body&gt; 
      &lt;div id = "loginPage" class = "container text-center"&gt; 
		
         &lt;div class = "row"&gt; 
            &lt;div class = "col-md-4 col-md-offset-4"&gt; 
               &lt;h2&gt;WebRTC Text Demo. Please sign in&lt;/h2&gt; 
               &lt;label for = "usernameInput" class = "sr-only"&gt;Login&lt;/label&gt; 
               &lt;input type = "email" id = "usernameInput" 
                  class = "form-control formgroup" placeholder = "Login" 
                  required = "" autofocus = ""&gt;
               &lt;button id = "loginBtn" class = "btn btn-lg btn-primary btnblock"&gt;
                  Sign in&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt; 
			
      &lt;/div&gt;
		
      &lt;div id = "callPage" class = "call-page container"&gt;
		
         &lt;div class = "row"&gt; 
            &lt;div class = "col-md-4 col-md-offset-4 text-center"&gt; 
               &lt;div class = "panel panel-primary"&gt; 
                  &lt;div class = "panel-heading"&gt;Text chat&lt;/div&gt; 
                  &lt;div id = "chatarea" class = "panel-body text-left"&gt;&lt;/div&gt; 
               &lt;/div&gt; 
            &lt;/div&gt; 
         &lt;/div&gt;
			
         &lt;div class = "row text-center form-group"&gt; 
            &lt;div class = "col-md-12"&gt; 
               &lt;input id = "callToUsernameInput" type = "text" 
                  placeholder = "username to call" /&gt; 
               &lt;button id = "callBtn" class = "btn-success btn"&gt;Call&lt;/button&gt; 
               &lt;button id = "hangUpBtn" class = "btn-danger btn"&gt;Hang Up&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt; 
			
         &lt;div class = "row text-center"&gt; 
            &lt;div class = "col-md-12"&gt; 
               &lt;input id = "msgInput" type = "text" placeholder = "message" /&gt; 
               &lt;button id = "sendMsgBtn" class = "btn-success btn"&gt;Send&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt;
			
      &lt;/div&gt; 
		
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
		
   &lt;/body&gt;
 
&lt;/html&gt;
</pre>
<p>This page should be familiar to you. We have added the <i>bootstrap</i> css file. We have also defined two pages. Finally, we have created several text fields and buttons for getting information from the user. On the “chat” page you should see the div tag with the “chatarea” ID where all our messages will be displayed. Notice that we have added a link to a <i>client.js</i> file.</p>
<p>Now we need to establish a connection with our signaling server. Create the <i>client.js</i> file in the root folder with the following code &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser;
  
//connecting to our signaling server 
var conn = new WebSocket('ws://localhost:9090');
  
conn.onopen = function () { 
   console.log("Connected to the signaling server"); 
}; 
 
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data);
	
   var data = JSON.parse(msg.data);
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success); 
         break; 
      //when somebody wants to call us 
      case "offer": 
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate":
         handleCandidate(data.candidate); 
         break; 
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   } 
};
  
conn.onerror = function (err) { 
   console.log("Got error", err); 
};
  
//alias for sending JSON encoded messages 
function send(message) { 
   //attach the other peer username to our messages 
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
};
</pre>
<p>Now run our signaling server via <i>node server</i>. Then, inside the root folder run the <i>static</i> command and open the page inside the browser. You should see the following console output &minus;</p>
<img src="/webrtc/images/console_output_of_text_demo.jpg" alt="Console Output" />
<p>The next step is implementing a user log in with a unique username. We simply send a username to the server, which then tell us whether it is taken or not. Add the following code to your <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//****** 
//UI selectors block
//****** 

var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var loginBtn = document.querySelector('#loginBtn'); 

var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput'); 
var callBtn = document.querySelector('#callBtn'); 

var hangUpBtn = document.querySelector('#hangUpBtn'); 
callPage.style.display = "none"; 

// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value;
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name 
      }); 
   } 
	
});
 
function handleLogin(success) { 

   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block"; 
		
      //********************** 
      //Starting a peer connection 
      //********************** 
   } 
	
};
</pre>
<p>Firstly, we select some references to the elements on the page. The we hide the call page. Then, we add an event listener on the login button. When the user clicks it, we send his username to the server. Finally, we implement the handleLogin callback. If the login was successful, we show the call page, set up a peer connection, and create a data channel.</p>
<p>To start a peer connection with a data channel we need &minus;</p>
<ul class="list">
<li>Create the RTCPeerConnection object</li>
<li>Create a data channel inside our RTCPeerConnection object</li>
</ul>
<p>Add the following code to the “UI selectors block” &minus;</p>
<pre class="prettyprint notranslate">
var msgInput = document.querySelector('#msgInput'); 
var sendMsgBtn = document.querySelector('#sendMsgBtn'); 
var chatArea = document.querySelector('#chatarea'); 

var yourConn; 
var dataChannel;
</pre>
<p>Modify the <i>handleLogin</i> function &minus;</p>
<pre class="prettyprint notranslate">
function handleLogin(success) { 
   if (success === false) { 
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block";
		
      //********************** 
      //Starting a peer connection 
      //**********************
		
      //using Google public stun server 
      var configuration = { 
         "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }] 
      }; 
		
      yourConn = new webkitRTCPeerConnection(configuration, {optional: [{RtpDataChannels: true}]});
		
      // Setup ice handling 
      yourConn.onicecandidate = function (event) { 
         if (event.candidate) { 
            send({
               type: "candidate", 
               candidate: event.candidate 
            }); 
         } 
      };
		
      //creating data channel 
      dataChannel = yourConn.createDataChannel("channel1", {reliable:true}); 
		
      dataChannel.onerror = function (error) { 
         console.log("Ooops...error:", error); 
      };
		
      //when we receive a message from the other peer, display it on the screen 
      dataChannel.onmessage = function (event) { 
         chatArea.innerHTML += connectedUser + ": " + event.data + "&lt;br /&gt;"; 
      };
		
      dataChannel.onclose = function () { 
         console.log("data channel is closed"); 
      };  
   } 
};
</pre>
<p>If login was successful the application creates the <i>RTCPeerConnection</i> object and setup <i>onicecandidate</i> handler which sends all found icecandidates to the other peer. It also creates a dataChannel. Notice, that when creating the RTCPeerConnection object the second argument in the constructor optional: [{RtpDataChannels: true}] is mandatory if you are using Chrome or Opera. The next step is to create an offer to the other peer. Once a user gets the offer, he creates an <i>answer</i> and start trading ICE candidates. Add the following code to the <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//initiating a call
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value;
	
   if (callToUsername.length &gt; 0) {
	
      connectedUser = callToUsername;
		
      // create an offer 
      yourConn.createOffer(function (offer) { 
		
         send({ 
            type: "offer", 
            offer: offer 
         }); 
			
         yourConn.setLocalDescription(offer); 
			
      }, function (error) { 
         alert("Error when creating an offer"); 
      });  
   } 
});
  
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer));
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
		
      send({ 
         type: "answer", 
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("Error when creating an answer"); 
   });
};
  
//when we got an answer from a remote user 
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); 
};
  
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
</pre>
<p>We add a <i>click</i> handler to the Call button, which initiates an offer. Then we implement several handlers expected by the <i>onmessage</i> handler. They will be processed asynchronously until both the users have made a connection.</p>
<p>The next step is implementing the hang-up feature. This will stop transmitting data and tell the other user to close the data channel. Add the following code &minus;</p>
<pre class="prettyprint notranslate">
//hang up 
hangUpBtn.addEventListener("click", function () { 
   send({ 
      type: "leave" 
   }); 
	
   handleLeave(); 
}); 
 
function handleLeave() { 
   connectedUser = null; 
   yourConn.close(); 
   yourConn.onicecandidate = null; 
};
</pre>
<p>When the user clicks on the Hang Up button &minus;</p>
<ul class="list">
<li>It will send a “leave” message to the other user.</li>
<li>It will close the RTCPeerConnection and as well as data channel.</li>
</ul>
<p>The last step is sending a message to another peer. Add the “click” handler to the “send message” button &minus;</p>
<pre class="prettyprint notranslate">
//when user clicks the "send message" button 
sendMsgBtn.addEventListener("click", function (event) { 
   var val = msgInput.value; 
   chatArea.innerHTML += name + ": " + val + "&lt;br /&gt;"; 
	
   //sending a message to a connected peer 
   dataChannel.send(val); 
   msgInput.value = ""; 
});
</pre>
<p>Now run the code. You should be able to log in to the server using two browser tabs. You can then set up a peer connection to the other user and send him a message as well as close the data channel by clicking the “Hang Up” button.</p>
<img src="/webrtc/images/output_of_text_demo.jpg" alt="Output of the Code" />
<p>The following is the entire <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser; 

//connecting to our signaling server 
var conn = new WebSocket('ws://localhost:9090'); 

conn.onopen = function () { 
   console.log("Connected to the signaling server");
};
 
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data); 
   var data = JSON.parse(msg.data); 
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success); 
         break; 
      //when somebody wants to call us 
      case "offer": 
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate": 
         handleCandidate(data.candidate); 
         break; 
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   } 
}; 

conn.onerror = function (err) { 
   console.log("Got error", err); 
}; 

//alias for sending JSON encoded messages 
function send(message) { 

   //attach the other peer username to our messages
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
};
 
//****** 
//UI selectors block 
//****** 

var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var loginBtn = document.querySelector('#loginBtn'); 

var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput');
var callBtn = document.querySelector('#callBtn'); 

var hangUpBtn = document.querySelector('#hangUpBtn'); 
var msgInput = document.querySelector('#msgInput'); 
var sendMsgBtn = document.querySelector('#sendMsgBtn'); 

var chatArea = document.querySelector('#chatarea'); 
var yourConn; 
var dataChannel; 
callPage.style.display = "none"; 

// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value; 
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name 
      }); 
   } 
	
});
 
function handleLogin(success) { 

   if (success === false) {
      alert("Ooops...try a different username"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block"; 
		
      //********************** 
      //Starting a peer connection 
      //********************** 
		
      //using Google public stun server 
      var configuration = { 
         "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }] 
      }; 
		
      yourConn = new webkitRTCPeerConnection(configuration, {optional: [{RtpDataChannels: true}]}); 
		
      // Setup ice handling 
      yourConn.onicecandidate = function (event) { 
         if (event.candidate) { 
            send({ 
               type: "candidate", 
               candidate: event.candidate 
            }); 
         } 
      }; 
		
      //creating data channel 
      dataChannel = yourConn.createDataChannel("channel1", {reliable:true}); 
		
      dataChannel.onerror = function (error) { 
         console.log("Ooops...error:", error); 
      }; 
		
      //when we receive a message from the other peer, display it on the screen 
      dataChannel.onmessage = function (event) { 
         chatArea.innerHTML += connectedUser + ": " + event.data + "&lt;br /&gt;"; 
      }; 
		
      dataChannel.onclose = function () { 
         console.log("data channel is closed"); 
      };
		
   } 
};
 
//initiating a call 
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value; 
	
   if (callToUsername.length &gt; 0) { 
      connectedUser = callToUsername; 
      // create an offer 
      yourConn.createOffer(function (offer) { 
         send({ 
            type: "offer", 
            offer: offer 
         }); 
         yourConn.setLocalDescription(offer); 
      }, function (error) { 
         alert("Error when creating an offer"); 
      }); 
   } 
	
});
 
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer)); 
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
      send({ 
         type: "answer", 
         answer: answer 
      }); 
   }, function (error) { 
      alert("Error when creating an answer"); 
   });
	
};
 
//when we got an answer from a remote user 
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); 
};
 
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
 
//hang up 
hangUpBtn.addEventListener("click", function () { 
   send({ 
      type: "leave" 
   }); 
	
   handleLeave(); 
}); 

function handleLeave() { 
   connectedUser = null; 
   yourConn.close(); 
   yourConn.onicecandidate = null; 
};
 
//when user clicks the "send message" button 
sendMsgBtn.addEventListener("click", function (event) { 
   var val = msgInput.value; 
   chatArea.innerHTML += name + ": " + val + "&lt;br /&gt;"; 
	
   //sending a message to a connected peer 
   dataChannel.send(val); 
   msgInput.value = ""; 
});
</pre>
<h1>WebRTC - Security</h1>
<p>In this chapter, we are going to add security features to the signaling server we created in the “WebRTC Signaling” chapter. There will be two enhancements &minus;</p>
<ul class="list">
<li>User authentication using Redis database</li>
<li>Enabling secure socket connection</li>
</ul>
<p>Firstly, you should install Redis.</p>
<ul class="list">
<li><p>Download the latest stable release at <a target="_blank" rel="nofollow" href="http://redis.io/download">http://redis.io/download</a>(3.05 in my case)</p></li>
<li><p>Unpack it</p></li>
<li><p>Inside the downloaded folder run <i>sudo make install</i></p></li>
<li><p>After the installation is finished, run <i>make test</i> to check whether everything is working correctly.</p></li>
</ul>
<p>Redis has two executable commands &minus;</p>
<ul class="list">
<li><p><b>redis-cli</b> &minus; command line interface for Redis (client part)</p></li>
<li><p><b>redis-server</b> &minus; Redis data store</p></li>
</ul>
<p>To run the Redis server type <i>redis-server</i> in the terminal console. You should see the following &minus;</p>
<img src="/webrtc/images/redis_server.jpg" alt="Redis Server" />
<p>Now open a new terminal window and run <i>redis-cli</i> to open a client application.</p>
<img src="/webrtc/images/redis_cli.jpg" alt="Redis-cli" />
<p>Basically, Redis is a key-value database. To create a key with a string value, you should use the SET command. To read the key value you should use the GET command. Let's add two users and passwords for them. Keys will be the usernames and values of these keys will be the corresponding passwords.</p>
<img src="/webrtc/images/type_username_and_password.jpg" alt="Add users and passwords" />
<p>Now we should modify our signaling server to add a user authentication. Add the following code to the top of the <i>server.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//require the redis library in Node.js 
var redis = require("redis");
 
//creating the redis client object 
var redisClient = redis.createClient();
</pre>
<p>In the above code, we require the Redis library for Node.js and creating a redis client for our server.</p>
<p>To add the authentication modify the <i>message</i> handler on the connection object &minus;</p>
<pre class="prettyprint notranslate">
//when a user connects to our sever 
wss.on('connection', function(connection) { 
   console.log("user connected");
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) { 
	
      var data; 
      //accepting only JSON messages 
      try { 
         data = JSON.parse(message); 
      } catch (e) { 
         console.log("Invalid JSON"); 
         data = {}; 
      }
		
      //check whether a user is authenticated 
      if(data.type != "login") { 
		
         //if user is not authenticated 
         if(!connection.isAuth) { 
            sendTo(connection, { 
               type: "error", 
               message: "You are not authenticated" 
            }); 
            return; 
         } 
      } 
		
      //switching type of the user message 
      switch (data.type) { 
         //when a user tries to login 
         case "login": 
            console.log("User logged:", data.name); 
            //get password for this username from redis database 
				
            redisClient.get(data.name, function(err, reply) {  
               //check if password matches with the one stored in redis 
               var loginSuccess = reply === data.password;
				
               //if anyone is logged in with this username or incorrect password 
                  then refuse 
               if(users[data.name] || !loginSuccess) { 
                  sendTo(connection, { 
                     type: "login", 
                     success: false 
                  }); 
               } else { 
                  //save user connection on the server 
                  users[data.name] = connection; 
                  connection.name = data.name;
                  connection.isAuth = true; 
						
                  sendTo(connection, { 
                     type: "login", 
                     success: true 
                  }); 
               }  
            }); 
				
            break;
      }
   });
	
}		
		
//... 
//*****other handlers*******
</pre>
<p>In the above code if a user tries to login we get from Redis his password, check if it matches with the stored one, and if it successful we store his username on the server. We also add the <i>isAuth</i> flag to the connection to check whether the user is authenticated. Notice this code &minus;</p>
<pre class="prettyprint notranslate">
//check whether a user is authenticated 
if(data.type != "login") { 

   //if user is not authenticated 
   if(!connection.isAuth) { 
      sendTo(connection, { 
         type: "error", 
         message: "You are not authenticated" 
      });
		
      return; 
   } 
}
</pre>
<p>If an unauthenticated user tries to send offer or leave the connection we simply send an error back.</p>
<p>The next step is enabling a secure socket connection. It is highly recommended for WebRTC applications. PKI (Public Key Infrastructure) is a digital signature from a CA (Certificate Authority). Users then check that the private key used to sign a certificate matches the public key of the CA's certificate. For the development purposes. we will use a self-signed security certificate.</p>
<p>We will use the openssl. It is an open source tool that implements SSL (Secure Sockets Layer) and TLS (Transport Layer Security) protocols. It is often installed by default on Unix systems. Run <i>openssl version -a</i> to check whether it is installed.</p>
<img src="/webrtc/images/use_openssl.jpg" alt="Use Openssl" />
<p>To generate public and private security certificate keys, you should follow the steps given below &minus;</p>
<ul class="list">
<li><p><b>Generate a temporary server password key</b></p></li>
</ul>
<pre class="result notranslate">
openssl genrsa -des3 -passout pass:x -out server.pass.key 2048
</pre>
<p></p>
<img src="/webrtc/images/temporary_password.jpg" alt="temporary server password key" />
<ul class="list">
<li><p><b>Generate a server private key</b></p></li>
</ul>
<pre class="result notranslate">
openssl rsa -passin pass:12345 -in server.pass.key -out server.key
</pre>
<p></p>
<img src="/webrtc/images/server_private_key.jpg" alt="Server Private key" />
<ul class="list">
<li><p><b>Generate a signing request. You will be asked additional questions about your company. Just hit the “Enter” button all the time.</b></p></li>
</ul>
<pre class="result notranslate">
openssl req -new -key server.key -out server.csr
</pre>
<p></p>
<img src="/webrtc/images/signing_request.jpg" alt="Generate a signing request" />
<ul class="list">
<li><p><b>Generate the certificate</b></p></li>
</ul>
<pre class="result notranslate">
openssl x509 -req -days 1095 -in server.csr -signkey server.key -out server.crt
</pre>
<p></p>
<img src="/webrtc/images/generate_certificate.jpg" alt="Generate Certificate" />
<p>Now you have two files, the certificate (server.crt) and the private key (server.key). Copy them into the signaling server root folder.</p>
<p>To enable the secure socket connection modify our signaling server.</p>
<pre class="prettyprint notranslate">
//require file system module 
var fs = require('fs'); 
var httpServ = require('https');
  
//https://github.com/visionmedia/superagent/issues/205 
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
  
//out secure server will bind to the port 9090 
var cfg = { 
   port: 9090, 
   ssl_key: 'server.key', 
   ssl_cert: 'server.crt' 
};
  
//in case of http request just send back "OK" 
var processRequest = function(req, res) { 
   res.writeHead(200); 
   res.end("OK"); 
};
  
//create our server with SSL enabled 
var app = httpServ.createServer({ 
   key: fs.readFileSync(cfg.ssl_key), 
   cert: fs.readFileSync(cfg.ssl_cert) 
}, processRequest).listen(cfg.port);
	
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({server: app}); 

//all connected to the server users 
var users = {};
  
//require the redis library in Node.js
var redis = require("redis"); 

//creating the redis client object 
var redisClient = redis.createClient(); 
 
//when a user connects to our sever 
wss.on('connection', function(connection){ 
//...other code
</pre>
<p>In the above code, we require the <i>fs</i> library to read private key and certificate, create the <i>cfg</i> object with the binding port and paths for private key and certificate. Then, we create an HTTPS server with our keys along with WebSocket server on the port 9090.</p>
<p>Now open <b>https://localhost:9090</b> in Opera. You should see the following &minus;</p>
<img src="/webrtc/images/invalid_certificate.jpg" alt="Invalid Certificate" />
<p>Click the “continue anyway” button. You should see the “OK” message.</p>
<p>To test our secure signaling server, we will modify the chat application we created in the “WebRTC Text Demo” tutorial. We just need to add a password field. The following is the entire <i>index.html</i> file &minus;</p>
<pre class="prettyprint notranslate">
&lt;html&gt;
  
   &lt;head&gt; 
      &lt;title&gt;WebRTC Text Demo&lt;/title&gt;  
      &lt;link rel = "stylesheet" href = "node_modules/bootstrap/dist/css/bootstrap.min.css"/&gt;  
   &lt;/head&gt; 

   &lt;style&gt;  
      body { 
         background: #eee; 
         padding: 5% 0; 
      }  
   &lt;/style&gt;
	
   &lt;body&gt;  
      &lt;div id = "loginPage" class = "container text-center"&gt; 
		
         &lt;div class = "row"&gt; 
            &lt;div class = "col-md-4 col-md-offset-4"&gt;  
               &lt;h2&gt;WebRTC Text Demo. Please sign in&lt;/h2&gt; 
               &lt;label for = "usernameInput" class = "sr-only"&gt;Login&lt;/label&gt; 
               &lt;input type = "email" id = "usernameInput" 
                  class = "form-control formgroup" placeholder = "Login" 
                  required = "" autofocus = ""&gt; 
               &lt;input type = "text" id = "passwordInput" 
                  class = "form-control form-group" placeholder = "Password"
                  required = "" autofocus = ""&gt; 
               &lt;button id = "loginBtn" class = "btn btn-lg btn-primary btnblock"
                  &gt;Sign in&lt;/button&gt;  
            &lt;/div&gt; 
         &lt;/div&gt; 
			
      &lt;/div&gt; 
		
      &lt;div id = "callPage" class = "call-page container"&gt;
		
         &lt;div class = "row"&gt; 
            &lt;div class = "col-md-4 col-md-offset-4 text-center"&gt; 
               &lt;div class = "panel panel-primary"&gt; 
                  &lt;div class = "panel-heading"&gt;Text chat&lt;/div&gt; 
                  &lt;div id = "chatarea" class = "panel-body text-left"&gt;&lt;/div&gt; 
               &lt;/div&gt; 
            &lt;/div&gt; 
         &lt;/div&gt;
			
         &lt;div class = "row text-center form-group"&gt; 
            &lt;div class = "col-md-12"&gt; 
               &lt;input id = "callToUsernameInput" type = "text" 
                  placeholder = "username to call" /&gt; 
               &lt;button id = "callBtn" class = "btn-success btn"&gt;Call&lt;/button&gt; 
               &lt;button id = "hangUpBtn" class = "btn-danger btn"&gt;Hang Up&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt;
			
         &lt;div class = "row text-center"&gt; 
            &lt;div class = "col-md-12"&gt; 
               &lt;input id = "msgInput" type = "text" placeholder = "message" /&gt; 
               &lt;button id = "sendMsgBtn" class = "btn-success btn"&gt;Send&lt;/button&gt; 
            &lt;/div&gt; 
         &lt;/div&gt;
			
      &lt;/div&gt;  
		
      &lt;script src = "client.js"&gt;&lt;/script&gt; 
  
   &lt;/body&gt; 
	
&lt;/html&gt;
</pre>
<p>We also need to enable a secure socket connection in the <i>client.js</i> file through this line <i>var conn = new WebSocket('wss://localhost:9090');</i>. Notice the <i>wss</i> protocol. Then, the login button hander must modified to send password along with username &minus;</p>
<pre class="prettyprint notranslate">
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value; 
   var pwd = passwordInput.value;
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name, 
         password: pwd 
      }); 
   } 
	
});
</pre>
<p>The following is the entire <i>client.js</i> file &minus;</p>
<pre class="prettyprint notranslate">
//our username 
var name; 
var connectedUser;
  
//connecting to our signaling server 
var conn = new WebSocket('wss://localhost:9090');
  
conn.onopen = function () { 
   console.log("Connected to the signaling server"); 
};
  
//when we got a message from a signaling server 
conn.onmessage = function (msg) { 
   console.log("Got message", msg.data);
	
   var data = JSON.parse(msg.data);
	
   switch(data.type) { 
      case "login": 
         handleLogin(data.success); 
         break; 
      //when somebody wants to call us 
      case "offer":
         handleOffer(data.offer, data.name); 
         break; 
      case "answer": 
         handleAnswer(data.answer); 
         break; 
      //when a remote peer sends an ice candidate to us 
      case "candidate": 
         handleCandidate(data.candidate); 
         break; 
      case "leave": 
         handleLeave(); 
         break; 
      default: 
         break; 
   } 
};
  
conn.onerror = function (err) { 
   console.log("Got error", err); 
};  

//alias for sending JSON encoded messages 
function send(message) { 
   //attach the other peer username to our messages 
   if (connectedUser) { 
      message.name = connectedUser; 
   } 
	
   conn.send(JSON.stringify(message)); 
}; 
 
//****** 
//UI selectors block 
//******

var loginPage = document.querySelector('#loginPage'); 
var usernameInput = document.querySelector('#usernameInput'); 
var passwordInput = document.querySelector('#passwordInput'); 
var loginBtn = document.querySelector('#loginBtn'); 

var callPage = document.querySelector('#callPage'); 
var callToUsernameInput = document.querySelector('#callToUsernameInput');
var callBtn = document.querySelector('#callBtn'); 
var hangUpBtn = document.querySelector('#hangUpBtn');
  
var msgInput = document.querySelector('#msgInput'); 
var sendMsgBtn = document.querySelector('#sendMsgBtn'); 
var chatArea = document.querySelector('#chatarea'); 

var yourConn; 
var dataChannel;
  
callPage.style.display = "none";
  
// Login when the user clicks the button 
loginBtn.addEventListener("click", function (event) { 
   name = usernameInput.value; 
   var pwd = passwordInput.value;  
	
   if (name.length &gt; 0) { 
      send({ 
         type: "login", 
         name: name, 
         password: pwd 
      }); 
   } 
	
}); 
 
function handleLogin(success) { 
   if (success === false) {
      alert("Ooops...incorrect username or password"); 
   } else { 
      loginPage.style.display = "none"; 
      callPage.style.display = "block";
		
      //********************** 
      //Starting a peer connection 
      //********************** 
		
      //using Google public stun server 
      var configuration = { 
         "iceServers": [{ "url": "stun:stun2.1.google.com:19302" }] 
      }; 
		
      yourConn = new webkitRTCPeerConnection(configuration, {optional: [{RtpDataChannels: true}]}); 
		
      // Setup ice handling 
      yourConn.onicecandidate = function (event) { 
         if (event.candidate) { 
            send({ 
               type: "candidate", 
               candidate: event.candidate 
            }); 
         } 
      };
		
      //creating data channel 
      dataChannel = yourConn.createDataChannel("channel1", {reliable:true}); 
		
      dataChannel.onerror = function (error) { 
         console.log("Ooops...error:", error); 
      };
		
      //when we receive a message from the other peer, display it on the screen 
      dataChannel.onmessage = function (event) { 
         chatArea.innerHTML += connectedUser + ": " + event.data + "&lt;br /&gt;"; 
      };  
      dataChannel.onclose = function () { 
         console.log("data channel is closed"); 
      };  
   } 
	
};
  
//initiating a call 
callBtn.addEventListener("click", function () { 
   var callToUsername = callToUsernameInput.value;
	
   if (callToUsername.length &gt; 0) {
	
      connectedUser = callToUsername;
		
      // create an offer 
      yourConn.createOffer(function (offer) { 
         send({ 
            type: "offer", 
            offer: offer 
         }); 
			
         yourConn.setLocalDescription(offer); 
			
      }, function (error) { 
         alert("Error when creating an offer"); 
      });  
   } 
});
 
//when somebody sends us an offer 
function handleOffer(offer, name) { 
   connectedUser = name; 
   yourConn.setRemoteDescription(new RTCSessionDescription(offer));
	
   //create an answer to an offer 
   yourConn.createAnswer(function (answer) { 
      yourConn.setLocalDescription(answer); 
		
      send({ 
         type: "answer", 
         answer: answer 
      }); 
		
   }, function (error) { 
      alert("Error when creating an answer"); 
   }); 
	
};
  
//when we got an answer from a remote user 
function handleAnswer(answer) { 
   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); 
};
  
//when we got an ice candidate from a remote user 
function handleCandidate(candidate) { 
   yourConn.addIceCandidate(new RTCIceCandidate(candidate)); 
};
   
//hang up 
hangUpBtn.addEventListener("click", function () { 

   send({ 
      type: "leave"
   }); 
	
   handleLeave(); 
});
  
function handleLeave() { 
   connectedUser = null; 
   yourConn.close(); 
   yourConn.onicecandidate = null; 
}; 
 
//when user clicks the "send message" button 
sendMsgBtn.addEventListener("click", function (event) { 
   var val = msgInput.value; 
   chatArea.innerHTML += name + ": " + val + "&lt;br /&gt;"; 
	
   //sending a message to a connected peer 
   dataChannel.send(val); 
   msgInput.value = ""; 
});
</pre>
<p>Now run our secure signaling server via <i>node server</i>. Run <i>node static</i> inside the modified chat demo folder. Open <b>localhost:8080</b> in two browser tabs. Try to log in. Remember only “user1” with “password1” and “user2” with “password2” are allowed to login. Then establish the RTCPeerConnection(call another user) and try to send a message.</p>
<img src="/webrtc/images/established_rtcpeer_connection.jpg" alt="Establish the RTCPeerConnection" />
<p>The following is the entire code of our secure signaling server &minus;</p>
<pre class="prettyprint notranslate">
//require file system module 
var fs = require('fs'); 
var httpServ = require('https');

//https://github.com/visionmedia/superagent/issues/205 
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
  
//out secure server will bind to the port 9090 
var cfg = { 
   port: 9090, 
   ssl_key: 'server.key', 
   ssl_cert: 'server.crt' 
};
  
//in case of http request just send back "OK" 
var processRequest = function(req, res){ 
   res.writeHead(200); 
   res.end("OK"); 
};
  
//create our server with SSL enabled 
var app = httpServ.createServer({ 
   key: fs.readFileSync(cfg.ssl_key), 
   cert: fs.readFileSync(cfg.ssl_cert) 
}, processRequest).listen(cfg.port);
  
//require our websocket library 
var WebSocketServer = require('ws').Server; 

//creating a websocket server at port 9090 
var wss = new WebSocketServer({server: app}); 

//all connected to the server users 
var users = {};
  
//require the redis library in Node.js 
var redis = require("redis"); 

//creating the redis client object 
var redisClient = redis.createClient();

//when a user connects to our sever 
wss.on('connection', function(connection) { 
   console.log("user connected"); 
	
   //when server gets a message from a connected user 
   connection.on('message', function(message) {  
	
      var data; 
      //accepting only JSON messages 
      try { 
         data = JSON.parse(message); 
      } catch (e) { 
         console.log("Invalid JSON"); 
         data = {}; 
      } 
		
      //check whether a user is authenticated 
      if(data.type != "login") { 
         //if user is not authenticated 
         if(!connection.isAuth) { 
            sendTo(connection, { 
               type: "error", 
               message: "You are not authenticated" 
            }); 
				
            return; 
         } 
      }
		
      //switching type of the user message 
      switch (data.type) { 
         //when a user tries to login 
         case "login":
            console.log("User logged:", data.name); 
            //get password for this username from redis database 
            redisClient.get(data.name, function(err, reply) {
			  
               //check if password matches with the one stored in redis 
               var loginSuccess = reply === data.password;
				  
               //if anyone is logged in with this username or incorrect password 
                  then refuse 
               if(users[data.name] || !loginSuccess) { 
                  sendTo(connection, { 
                     type: "login", 
                     success: false 
                  }); 
               } else { 
                  //save user connection on the server 
                  users[data.name] = connection; 
                  connection.name = data.name; 
                  connection.isAuth = true; 
						
                  sendTo(connection, { 
                     type: "login", 
                     success: true 
                  }); 
               }  
            }); 
				
            break;
				
         case "offer": 
            //for ex. UserA wants to call UserB 
            console.log("Sending offer to: ", data.name); 
				
            //if UserB exists then send him offer details 
            var conn = users[data.name];
				
            if(conn != null) { 
               //setting that UserA connected with UserB 
               connection.otherName = data.name;
					
               sendTo(conn, { 
                  type: "offer", 
                  offer: data.offer, 
                  name: connection.name 
               }); 
            } 
				
            break;
				
         case "answer": 
            console.log("Sending answer to: ", data.name); 
            //for ex. UserB answers UserA 
            var conn = users[data.name]; 
				
            if(conn != null) { 
               connection.otherName = data.name;
					
               sendTo(conn, { 
                  type: "answer", 
                  answer: data.answer 
               }); 
            } 
				
            break;
				
         case "candidate": 
            console.log("Sending candidate to:",data.name); 
            var conn = users[data.name];
				
            if(conn != null) { 
               sendTo(conn, { 
                  type: "candidate", 
                  candidate: data.candidate 
               });
            } 
				
            break;
				
         case "leave": 
            console.log("Disconnecting from", data.name); 
            var conn = users[data.name]; 
            conn.otherName = null; 
				
            //notify the other user so he can disconnect his peer connection 
            if(conn != null) { 
               sendTo(conn, { 
                  type: "leave" 
               }); 
            }  
				
            break;
				
         connection.on("close", function() {
			
            if(connection.name) { 
               delete users[connection.name]; 
					
               if(connection.otherName) { 
                  console.log("Disconnecting from ", connection.otherName); 
                  var conn = users[connection.otherName]; 
                  conn.otherName = null;  
						
                  if(conn != null) { 
                     sendTo(conn, { 
                        type: "leave" 
                    }); 
                  } 
						
               } 
            } 
         });
			
         default: 
            sendTo(connection, { 
               type: "error", 
               message: "Command no found: " + data.type 
            }); 
				
            break; 
      }  
   });
	
   //when user exits, for example closes a browser window 
   //this may help if we are still in "offer","answer" or "candidate" state 
   connection.on("close", function() { 
      if(connection.name) { 
         delete users[connection.name]; 
      } 
   });
	
   connection.send("Hello from server"); 
});
  
function sendTo(connection, message) { 
   connection.send(JSON.stringify(message)); 
}
</pre>
<h2>Summary</h2>
<p>In this chapter, we added user authentication to our signaling server. We also learned how to create self-signed SSL certificates and use them in the scope of WebRTC applications.</p>
<div class="mui-container-fluid button-borders show">
<div class="pre-btn">
<a href="/webrtc/webrtc_security.htm"><i class="fal fa-chevron-circle-left"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="/webrtc/webrtc_useful_resources.htm">Next Page <i class="fal fa-chevron-circle-right"></i>&nbsp;</a>
</div>
</div>
<div class="google-bottom-ads">
<div>Advertisements</div>
<script><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<div class="space-bottom"></div>
</div>
</div>
<!-- Tutorial Content Ends Here -->
<!-- Right Column Starts Here -->
<div class="mui-col-md-2 google-right-ads">
<div class="space-top"></div>
<div class="google-right-ad" style="margin: 0px auto !important;margin-top:5px;">
<script><!--
google_ad_client = "pub-2537027957187252";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9012177"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9012177")})</script>
</div>
<div class="space-bottom"></div>
<div class="google-right-ad">
<div class="adsbyvli" data-ad-slot="vi_9013289"></div>
<script>(vitag.Init = window.vitag.Init || []).push(function(){viAPItag.display("vi_9013289")})</script>
</div>
<div class="space-bottom" style="margin-bottom:15px;"></div>
</div>
<!-- Right Column Ends Here -->
</div>
</div>
<div class="clear"></div>
<footer id="footer">
<div class="mui--text-center">
<div class="mui--text-caption mui--text-light">
<a href="/index.htm" class="logo"><img class="img-responsive" src="/images/logo-black.png" alt="Tutorials Point" title="Tutorials Point"></a>
</div>
<ul class="mui-list--inline mui--text-body2 mui--text-light">
<li><a href="/about/index.htm"><i class="fal fa-globe"></i> About us</a></li>
<li><a href="/about/about_terms_of_use.htm"><i class="fal fa-asterisk"></i> Terms of use</a></li>
<li><a href="/about/about_privacy.htm#cookies"> <i class="fal fa-shield-check"></i> Cookies Policy</a></li>
<li><a href="/about/faq.htm"><i class="fal fa-question-circle"></i> FAQ's</a></li>
<li><a href="/about/about_helping.htm"><i class="fal fa-hands-helping"></i> Helping</a></li>
<li><a href="/about/contact_us.htm"><i class="fal fa-map-marker-alt"></i> Contact</a></li>
</ul>
<div class="mui--text-caption mui--text-light bottom-copyright-text">&copy; Copyright 2019. All Rights Reserved.</div>
</div>
<div id="privacy-banner">
  <div>
    <p>
      We use cookies to provide and improve our services. By using our site, you consent to our Cookies Policy.
      <a id="banner-accept" href="#">Accept</a>
      <a id="banner-learn" href="/about/about_cookies.htm" target="_blank">Learn more</a>
    </p>
  </div>
</div>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-232293-17"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-232293-6');
</script>
</footer>
</body>
</html>
